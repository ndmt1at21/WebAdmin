'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('child_process'),
    spawn = _require.spawn;

var path = require('path');

var _require2 = require('util'),
    format = _require2.format;

var importLazy = require('import-lazy')(require);

var configstore = importLazy('configstore');
var chalk = importLazy('chalk');
var semverDiff = importLazy('semver-diff');
var latestVersion = importLazy('latest-version');
var isNpm = importLazy('is-npm');
var isInstalledGlobally = importLazy('is-installed-globally');
var isYarnGlobal = importLazy('is-yarn-global');
var hasYarn = importLazy('has-yarn');
var boxen = importLazy('boxen');
var xdgBasedir = importLazy('xdg-basedir');
var isCi = importLazy('is-ci');
var pupa = importLazy('pupa');
var ONE_DAY = 1000 * 60 * 60 * 24;

var UpdateNotifier =
/*#__PURE__*/
function () {
  function UpdateNotifier() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UpdateNotifier);

    this.options = options;
    options.pkg = options.pkg || {};
    options.distTag = options.distTag || 'latest'; // Reduce pkg to the essential keys. with fallback to deprecated options
    // TODO: Remove deprecated options at some point far into the future

    options.pkg = {
      name: options.pkg.name || options.packageName,
      version: options.pkg.version || options.packageVersion
    };

    if (!options.pkg.name || !options.pkg.version) {
      throw new Error('pkg.name and pkg.version required');
    }

    this.packageName = options.pkg.name;
    this.packageVersion = options.pkg.version;
    this.updateCheckInterval = typeof options.updateCheckInterval === 'number' ? options.updateCheckInterval : ONE_DAY;
    this.disabled = 'NO_UPDATE_NOTIFIER' in process.env || process.env.NODE_ENV === 'test' || process.argv.includes('--no-update-notifier') || isCi();
    this.shouldNotifyInNpmScript = options.shouldNotifyInNpmScript;

    if (!this.disabled) {
      try {
        var ConfigStore = configstore();
        this.config = new ConfigStore("update-notifier-".concat(this.packageName), {
          optOut: false,
          // Init with the current time so the first check is only
          // after the set interval, so not to bother users right away
          lastUpdateCheck: Date.now()
        });
      } catch (_) {
        // Expecting error code EACCES or EPERM
        var message = chalk().yellow(format(' %s update check failed ', options.pkg.name)) + format('\n Try running with %s or get access ', chalk().cyan('sudo')) + '\n to the local update config store via \n' + chalk().cyan(format(' sudo chown -R $USER:$(id -gn $USER) %s ', xdgBasedir().config));
        process.on('exit', function () {
          console.error(boxen()(message, {
            align: 'center'
          }));
        });
      }
    }
  }

  _createClass(UpdateNotifier, [{
    key: "check",
    value: function check() {
      if (!this.config || this.config.get('optOut') || this.disabled) {
        return;
      }

      this.update = this.config.get('update');

      if (this.update) {
        // Use the real latest version instead of the cached one
        this.update.current = this.packageVersion; // Clear cached information

        this.config["delete"]('update');
      } // Only check for updates on a set interval


      if (Date.now() - this.config.get('lastUpdateCheck') < this.updateCheckInterval) {
        return;
      } // Spawn a detached process, passing the options as an environment property


      spawn(process.execPath, [path.join(__dirname, 'check.js'), JSON.stringify(this.options)], {
        detached: true,
        stdio: 'ignore'
      }).unref();
    }
  }, {
    key: "fetchInfo",
    value: function fetchInfo() {
      var distTag, latest;
      return regeneratorRuntime.async(function fetchInfo$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              distTag = this.options.distTag;
              _context.next = 3;
              return regeneratorRuntime.awrap(latestVersion()(this.packageName, {
                version: distTag
              }));

            case 3:
              latest = _context.sent;
              return _context.abrupt("return", {
                latest: latest,
                current: this.packageVersion,
                type: semverDiff()(this.packageVersion, latest) || distTag,
                name: this.packageName
              });

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "notify",
    value: function notify(options) {
      var suppressForNpm = !this.shouldNotifyInNpmScript && isNpm().isNpmOrYarn;

      if (!process.stdout.isTTY || suppressForNpm || !this.update || this.update.current === this.update.latest) {
        return this;
      }

      options = Object.assign({
        isGlobal: isInstalledGlobally(),
        isYarnGlobal: isYarnGlobal()()
      }, options);
      var installCommand;

      if (options.isYarnGlobal) {
        installCommand = "yarn global add ".concat(this.packageName);
      } else if (options.isGlobal) {
        installCommand = "npm i -g ".concat(this.packageName);
      } else if (hasYarn()()) {
        installCommand = "yarn add ".concat(this.packageName);
      } else {
        installCommand = "npm i ".concat(this.packageName);
      }

      var defaultTemplate = 'Update available ' + chalk().dim('{currentVersion}') + chalk().reset(' â†’ ') + chalk().green('{latestVersion}') + ' \nRun ' + chalk().cyan('{updateCommand}') + ' to update';
      var template = options.message || defaultTemplate;
      options.boxenOptions = options.boxenOptions || {
        padding: 1,
        margin: 1,
        align: 'center',
        borderColor: 'yellow',
        borderStyle: 'round'
      };
      var message = boxen()(pupa()(template, {
        packageName: this.packageName,
        currentVersion: this.update.current,
        latestVersion: this.update.latest,
        updateCommand: installCommand
      }), options.boxenOptions);

      if (options.defer === false) {
        console.error(message);
      } else {
        process.on('exit', function () {
          console.error(message);
        });
        process.on('SIGINT', function () {
          console.error('');
          process.exit();
        });
      }

      return this;
    }
  }]);

  return UpdateNotifier;
}();

module.exports = function (options) {
  var updateNotifier = new UpdateNotifier(options);
  updateNotifier.check();
  return updateNotifier;
};

module.exports.UpdateNotifier = UpdateNotifier;