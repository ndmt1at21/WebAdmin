'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require('stream'),
    PassThrough = _require.PassThrough;

var duplexer3 = require('duplexer3');

var requestAsEventEmitter = require('./request-as-event-emitter');

var _require2 = require('./errors'),
    HTTPError = _require2.HTTPError,
    ReadError = _require2.ReadError;

module.exports = function (options) {
  var input = new PassThrough();
  var output = new PassThrough();
  var proxy = duplexer3(input, output);
  var piped = new Set();
  var isFinished = false;

  options.retry.retries = function () {
    return 0;
  };

  if (options.body) {
    proxy.write = function () {
      throw new Error('Got\'s stream is not writable when the `body` option is used');
    };
  }

  var emitter = requestAsEventEmitter(options, input); // Cancels the request

  proxy._destroy = emitter.abort;
  emitter.on('response', function (response) {
    var statusCode = response.statusCode;
    response.on('error', function (error) {
      proxy.emit('error', new ReadError(error, options));
    });

    if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {
      proxy.emit('error', new HTTPError(response, options), null, response);
      return;
    }

    isFinished = true;
    response.pipe(output);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = piped[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var destination = _step.value;

        if (destination.headersSent) {
          continue;
        }

        for (var _i = 0, _Object$entries = Object.entries(response.headers); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              key = _Object$entries$_i[0],
              value = _Object$entries$_i[1];

          // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.
          // It's not possible to decompress already decompressed data, is it?
          var allowed = options.decompress ? key !== 'content-encoding' : true;

          if (allowed) {
            destination.setHeader(key, value);
          }
        }

        destination.statusCode = response.statusCode;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    proxy.emit('response', response);
  });
  ['error', 'request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(function (event) {
    return emitter.on(event, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return proxy.emit.apply(proxy, [event].concat(args));
    });
  });
  var pipe = proxy.pipe.bind(proxy);
  var unpipe = proxy.unpipe.bind(proxy);

  proxy.pipe = function (destination, options) {
    if (isFinished) {
      throw new Error('Failed to pipe. The response has been emitted already.');
    }

    var result = pipe(destination, options);

    if (Reflect.has(destination, 'setHeader')) {
      piped.add(destination);
    }

    return result;
  };

  proxy.unpipe = function (stream) {
    piped["delete"](stream);
    return unpipe(stream);
  };

  return proxy;
};