'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('url'),
    URL = _require.URL,
    URLSearchParams = _require.URLSearchParams; // TODO: Use the `URL` global when targeting Node.js 10


var urlLib = require('url');

var is = require('@sindresorhus/is');

var urlParseLax = require('url-parse-lax');

var lowercaseKeys = require('lowercase-keys');

var urlToOptions = require('./utils/url-to-options');

var isFormData = require('./utils/is-form-data');

var merge = require('./merge');

var knownHookEvents = require('./known-hook-events');

var retryAfterStatusCodes = new Set([413, 429, 503]); // `preNormalize` handles static options (e.g. headers).
// For example, when you create a custom instance and make a request
// with no static changes, they won't be normalized again.
//
// `normalize` operates on dynamic options - they cannot be saved.
// For example, `body` is everytime different per request.
// When it's done normalizing the new options, it performs merge()
// on the prenormalized options and the normalized ones.

var preNormalize = function preNormalize(options, defaults) {
  if (is.nullOrUndefined(options.headers)) {
    options.headers = {};
  } else {
    options.headers = lowercaseKeys(options.headers);
  }

  if (options.baseUrl && !options.baseUrl.toString().endsWith('/')) {
    options.baseUrl += '/';
  }

  if (options.stream) {
    options.json = false;
  }

  if (is.nullOrUndefined(options.hooks)) {
    options.hooks = {};
  } else if (!is.object(options.hooks)) {
    throw new TypeError("Parameter `hooks` must be an object, not ".concat(is(options.hooks)));
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = knownHookEvents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var event = _step.value;

      if (is.nullOrUndefined(options.hooks[event])) {
        if (defaults) {
          options.hooks[event] = _toConsumableArray(defaults.hooks[event]);
        } else {
          options.hooks[event] = [];
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (is.number(options.timeout)) {
    options.gotTimeout = {
      request: options.timeout
    };
  } else if (is.object(options.timeout)) {
    options.gotTimeout = options.timeout;
  }

  delete options.timeout;
  var retry = options.retry;
  options.retry = {
    retries: 0,
    methods: [],
    statusCodes: [],
    errorCodes: []
  };

  if (is.nonEmptyObject(defaults) && retry !== false) {
    options.retry = _objectSpread({}, defaults.retry);
  }

  if (retry !== false) {
    if (is.number(retry)) {
      options.retry.retries = retry;
    } else {
      options.retry = _objectSpread({}, options.retry, {}, retry);
    }
  }

  if (options.gotTimeout) {
    options.retry.maxRetryAfter = Math.min.apply(Math, _toConsumableArray([options.gotTimeout.request, options.gotTimeout.connection].filter(function (n) {
      return !is.nullOrUndefined(n);
    })));
  }

  if (is.array(options.retry.methods)) {
    options.retry.methods = new Set(options.retry.methods.map(function (method) {
      return method.toUpperCase();
    }));
  }

  if (is.array(options.retry.statusCodes)) {
    options.retry.statusCodes = new Set(options.retry.statusCodes);
  }

  if (is.array(options.retry.errorCodes)) {
    options.retry.errorCodes = new Set(options.retry.errorCodes);
  }

  return options;
};

var normalize = function normalize(url, options, defaults) {
  if (is.plainObject(url)) {
    options = _objectSpread({}, url, {}, options);
    url = options.url || {};
    delete options.url;
  }

  if (defaults) {
    options = merge({}, defaults.options, options ? preNormalize(options, defaults.options) : {});
  } else {
    options = merge({}, preNormalize(options));
  }

  if (!is.string(url) && !is.object(url)) {
    throw new TypeError("Parameter `url` must be a string or object, not ".concat(is(url)));
  }

  if (is.string(url)) {
    if (options.baseUrl) {
      if (url.toString().startsWith('/')) {
        url = url.toString().slice(1);
      }

      url = urlToOptions(new URL(url, options.baseUrl));
    } else {
      url = url.replace(/^unix:/, 'http://$&');
      url = urlParseLax(url);
    }
  } else if (is(url) === 'URL') {
    url = urlToOptions(url);
  } // Override both null/undefined with default protocol


  options = merge({
    path: ''
  }, url, {
    protocol: url.protocol || 'https:'
  }, options);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = options.hooks.init[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var hook = _step2.value;
      var called = hook(options);

      if (is.promise(called)) {
        throw new TypeError('The `init` hook must be a synchronous function');
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _options = options,
      baseUrl = _options.baseUrl;
  Object.defineProperty(options, 'baseUrl', {
    set: function set() {
      throw new Error('Failed to set baseUrl. Options are normalized already.');
    },
    get: function get() {
      return baseUrl;
    }
  });
  var _options2 = options,
      query = _options2.query;

  if (is.nonEmptyString(query) || is.nonEmptyObject(query) || query instanceof URLSearchParams) {
    if (!is.string(query)) {
      options.query = new URLSearchParams(query).toString();
    }

    options.path = "".concat(options.path.split('?')[0], "?").concat(options.query);
    delete options.query;
  }

  if (options.hostname === 'unix') {
    var matches = /(.+?):(.+)/.exec(options.path);

    if (matches) {
      var _matches = _slicedToArray(matches, 3),
          socketPath = _matches[1],
          path = _matches[2];

      options = _objectSpread({}, options, {
        socketPath: socketPath,
        path: path,
        host: null
      });
    }
  }

  var _options3 = options,
      headers = _options3.headers;

  for (var _i2 = 0, _Object$entries = Object.entries(headers); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    if (is.nullOrUndefined(value)) {
      delete headers[key];
    }
  }

  if (options.json && is.undefined(headers.accept)) {
    headers.accept = 'application/json';
  }

  if (options.decompress && is.undefined(headers['accept-encoding'])) {
    headers['accept-encoding'] = 'gzip, deflate';
  }

  var _options4 = options,
      body = _options4.body;

  if (is.nullOrUndefined(body)) {
    options.method = options.method ? options.method.toUpperCase() : 'GET';
  } else {
    var isObject = is.object(body) && !is.buffer(body) && !is.nodeStream(body);

    if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(options.form || options.json)) {
      throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');
    }

    if (options.json && !(isObject || is.array(body))) {
      throw new TypeError('The `body` option must be an Object or Array when the `json` option is used');
    }

    if (options.form && !isObject) {
      throw new TypeError('The `body` option must be an Object when the `form` option is used');
    }

    if (isFormData(body)) {
      // Special case for https://github.com/form-data/form-data
      headers['content-type'] = headers['content-type'] || "multipart/form-data; boundary=".concat(body.getBoundary());
    } else if (options.form) {
      headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded';
      options.body = new URLSearchParams(body).toString();
    } else if (options.json) {
      headers['content-type'] = headers['content-type'] || 'application/json';
      options.body = JSON.stringify(body);
    }

    options.method = options.method ? options.method.toUpperCase() : 'POST';
  }

  if (!is["function"](options.retry.retries)) {
    var retries = options.retry.retries;

    options.retry.retries = function (iteration, error) {
      if (iteration > retries) {
        return 0;
      }

      if ((!error || !options.retry.errorCodes.has(error.code)) && (!options.retry.methods.has(error.method) || !options.retry.statusCodes.has(error.statusCode))) {
        return 0;
      }

      if (Reflect.has(error, 'headers') && Reflect.has(error.headers, 'retry-after') && retryAfterStatusCodes.has(error.statusCode)) {
        var after = Number(error.headers['retry-after']);

        if (is.nan(after)) {
          after = Date.parse(error.headers['retry-after']) - Date.now();
        } else {
          after *= 1000;
        }

        if (after > options.retry.maxRetryAfter) {
          return 0;
        }

        return after;
      }

      if (error.statusCode === 413) {
        return 0;
      }

      var noise = Math.random() * 100;
      return Math.pow(2, iteration - 1) * 1000 + noise;
    };
  }

  return options;
};

var reNormalize = function reNormalize(options) {
  return normalize(urlLib.format(options), options);
};

module.exports = normalize;
module.exports.preNormalize = preNormalize;
module.exports.reNormalize = reNormalize;