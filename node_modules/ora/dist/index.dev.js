'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var chalk = require('chalk');

var cliCursor = require('cli-cursor');

var cliSpinners = require('cli-spinners');

var logSymbols = require('log-symbols');

var stripAnsi = require('strip-ansi');

var wcwidth = require('wcwidth');

var TEXT = Symbol('text');

var Ora =
/*#__PURE__*/
function () {
  function Ora(options) {
    _classCallCheck(this, Ora);

    if (typeof options === 'string') {
      options = {
        text: options
      };
    }

    this.options = Object.assign({
      text: '',
      color: 'cyan',
      stream: process.stderr
    }, options);
    var sp = this.options.spinner;
    this.spinner = _typeof(sp) === 'object' ? sp : process.platform === 'win32' ? cliSpinners.line : cliSpinners[sp] || cliSpinners.dots; // eslint-disable-line no-nested-ternary

    if (this.spinner.frames === undefined) {
      throw new Error('Spinner must define `frames`');
    }

    this.color = this.options.color;
    this.hideCursor = this.options.hideCursor !== false;
    this.interval = this.options.interval || this.spinner.interval || 100;
    this.stream = this.options.stream;
    this.id = null;
    this.frameIndex = 0;
    this.enabled = typeof this.options.enabled === 'boolean' ? this.options.enabled : this.stream && this.stream.isTTY && !process.env.CI; // Set *after* `this.stream`

    this.text = this.options.text;
    this.linesToClear = 0;
  }

  _createClass(Ora, [{
    key: "frame",
    value: function frame() {
      var frames = this.spinner.frames;
      var frame = frames[this.frameIndex];

      if (this.color) {
        frame = chalk[this.color](frame);
      }

      this.frameIndex = ++this.frameIndex % frames.length;
      return frame + ' ' + this.text;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (!this.enabled) {
        return this;
      }

      for (var i = 0; i < this.linesToClear; i++) {
        if (i > 0) {
          this.stream.moveCursor(0, -1);
        }

        this.stream.clearLine();
        this.stream.cursorTo(0);
      }

      this.linesToClear = 0;
      return this;
    }
  }, {
    key: "render",
    value: function render() {
      this.clear();
      this.stream.write(this.frame());
      this.linesToClear = this.lineCount;
      return this;
    }
  }, {
    key: "start",
    value: function start(text) {
      if (text) {
        this.text = text;
      }

      if (!this.enabled || this.isSpinning) {
        return this;
      }

      if (this.hideCursor) {
        cliCursor.hide(this.stream);
      }

      this.render();
      this.id = setInterval(this.render.bind(this), this.interval);
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.enabled) {
        return this;
      }

      clearInterval(this.id);
      this.id = null;
      this.frameIndex = 0;
      this.clear();

      if (this.hideCursor) {
        cliCursor.show(this.stream);
      }

      return this;
    }
  }, {
    key: "succeed",
    value: function succeed(text) {
      return this.stopAndPersist({
        symbol: logSymbols.success,
        text: text
      });
    }
  }, {
    key: "fail",
    value: function fail(text) {
      return this.stopAndPersist({
        symbol: logSymbols.error,
        text: text
      });
    }
  }, {
    key: "warn",
    value: function warn(text) {
      return this.stopAndPersist({
        symbol: logSymbols.warning,
        text: text
      });
    }
  }, {
    key: "info",
    value: function info(text) {
      return this.stopAndPersist({
        symbol: logSymbols.info,
        text: text
      });
    }
  }, {
    key: "stopAndPersist",
    value: function stopAndPersist(options) {
      if (!this.enabled) {
        return this;
      } // TODO: Remove in the next major version


      if (typeof options === 'string') {
        throw new TypeError('This argument now accepts an options object, not a string');
      }

      options = options || {};
      this.stop();
      this.stream.write("".concat(options.symbol || ' ', " ").concat(options.text || this.text, "\n"));
      return this;
    }
  }, {
    key: "text",
    get: function get() {
      return this[TEXT];
    },
    set: function set(value) {
      this[TEXT] = value;
      var columns = this.stream.columns || 80;
      this.lineCount = stripAnsi('--' + value).split('\n').reduce(function (count, line) {
        return count + Math.max(1, Math.ceil(wcwidth(line) / columns));
      }, 0);
    }
  }, {
    key: "isSpinning",
    get: function get() {
      return this.id !== null;
    }
  }]);

  return Ora;
}();

module.exports = function (opts) {
  return new Ora(opts);
};

module.exports.promise = function (action, options) {
  if (typeof action.then !== 'function') {
    throw new TypeError('Parameter `action` must be a Promise');
  }

  var spinner = new Ora(options);
  spinner.start();
  action.then(function () {
    spinner.succeed();
  }, function () {
    spinner.fail();
  });
  return spinner;
};