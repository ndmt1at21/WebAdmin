'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EventEmitter = require('events');

var urlLib = require('url');

var normalizeUrl = require('normalize-url');

var getStream = require('get-stream');

var CachePolicy = require('http-cache-semantics');

var Response = require('responselike');

var lowercaseKeys = require('lowercase-keys');

var cloneResponse = require('clone-response');

var Keyv = require('keyv');

var CacheableRequest =
/*#__PURE__*/
function () {
  function CacheableRequest(request, cacheAdapter) {
    _classCallCheck(this, CacheableRequest);

    if (typeof request !== 'function') {
      throw new TypeError('Parameter `request` must be a function');
    }

    this.cache = new Keyv({
      uri: typeof cacheAdapter === 'string' && cacheAdapter,
      store: typeof cacheAdapter !== 'string' && cacheAdapter,
      namespace: 'cacheable-request'
    });
    return this.createCacheableRequest(request);
  }

  _createClass(CacheableRequest, [{
    key: "createCacheableRequest",
    value: function createCacheableRequest(request) {
      var _this = this;

      return function (opts, cb) {
        var url;

        if (typeof opts === 'string') {
          url = normalizeUrlObject(urlLib.parse(opts));
          opts = {};
        } else if (opts instanceof urlLib.URL) {
          url = normalizeUrlObject(urlLib.parse(opts.toString()));
          opts = {};
        } else {
          var _split = (opts.path || '').split('?'),
              _split2 = _toArray(_split),
              pathname = _split2[0],
              searchParts = _split2.slice(1);

          var search = searchParts.length > 0 ? "?".concat(searchParts.join('?')) : '';
          url = normalizeUrlObject(_objectSpread({}, opts, {
            pathname: pathname,
            search: search
          }));
        }

        opts = _objectSpread({
          headers: {},
          method: 'GET',
          cache: true,
          strictTtl: false,
          automaticFailover: false
        }, opts, {}, urlObjectToRequestOptions(url));
        opts.headers = lowercaseKeys(opts.headers);
        var ee = new EventEmitter();
        var normalizedUrlString = normalizeUrl(urlLib.format(url), {
          stripWWW: false,
          removeTrailingSlash: false,
          stripAuthentication: false
        });
        var key = "".concat(opts.method, ":").concat(normalizedUrlString);
        var revalidate = false;
        var madeRequest = false;

        var makeRequest = function makeRequest(opts) {
          madeRequest = true;
          var requestErrored = false;
          var requestErrorCallback;
          var requestErrorPromise = new Promise(function (resolve) {
            requestErrorCallback = function requestErrorCallback() {
              if (!requestErrored) {
                requestErrored = true;
                resolve();
              }
            };
          });

          var handler = function handler(response) {
            if (revalidate && !opts.forceRefresh) {
              response.status = response.statusCode;
              var revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);

              if (!revalidatedPolicy.modified) {
                var headers = revalidatedPolicy.policy.responseHeaders();
                response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                response.cachePolicy = revalidatedPolicy.policy;
                response.fromCache = true;
              }
            }

            if (!response.fromCache) {
              response.cachePolicy = new CachePolicy(opts, response, opts);
              response.fromCache = false;
            }

            var clonedResponse;

            if (opts.cache && response.cachePolicy.storable()) {
              clonedResponse = cloneResponse(response);

              (function _callee() {
                var bodyPromise, body, value, ttl;
                return regeneratorRuntime.async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        bodyPromise = getStream.buffer(response);
                        _context.next = 4;
                        return regeneratorRuntime.awrap(Promise.race([requestErrorPromise, new Promise(function (resolve) {
                          return response.once('end', resolve);
                        })]));

                      case 4:
                        if (!requestErrored) {
                          _context.next = 6;
                          break;
                        }

                        return _context.abrupt("return");

                      case 6:
                        _context.next = 8;
                        return regeneratorRuntime.awrap(bodyPromise);

                      case 8:
                        body = _context.sent;
                        value = {
                          cachePolicy: response.cachePolicy.toObject(),
                          url: response.url,
                          statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                          body: body
                        };
                        ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;

                        if (opts.maxTtl) {
                          ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
                        }

                        _context.next = 14;
                        return regeneratorRuntime.awrap(_this.cache.set(key, value, ttl));

                      case 14:
                        _context.next = 19;
                        break;

                      case 16:
                        _context.prev = 16;
                        _context.t0 = _context["catch"](0);
                        ee.emit('error', new CacheableRequest.CacheError(_context.t0));

                      case 19:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, null, null, [[0, 16]]);
              })();
            } else if (opts.cache && revalidate) {
              (function _callee2() {
                return regeneratorRuntime.async(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.prev = 0;
                        _context2.next = 3;
                        return regeneratorRuntime.awrap(_this.cache["delete"](key));

                      case 3:
                        _context2.next = 8;
                        break;

                      case 5:
                        _context2.prev = 5;
                        _context2.t0 = _context2["catch"](0);
                        ee.emit('error', new CacheableRequest.CacheError(_context2.t0));

                      case 8:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, null, null, [[0, 5]]);
              })();
            }

            ee.emit('response', clonedResponse || response);

            if (typeof cb === 'function') {
              cb(clonedResponse || response);
            }
          };

          try {
            var req = request(opts, handler);
            req.once('error', requestErrorCallback);
            req.once('abort', requestErrorCallback);
            ee.emit('request', req);
          } catch (error) {
            ee.emit('error', new CacheableRequest.RequestError(error));
          }
        };

        (function _callee3() {
          var get, errorHandler;
          return regeneratorRuntime.async(function _callee3$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  get = function get(opts) {
                    var cacheEntry, policy, headers, response;
                    return regeneratorRuntime.async(function get$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return regeneratorRuntime.awrap(Promise.resolve());

                          case 2:
                            if (!opts.cache) {
                              _context3.next = 8;
                              break;
                            }

                            _context3.next = 5;
                            return regeneratorRuntime.awrap(_this.cache.get(key));

                          case 5:
                            _context3.t0 = _context3.sent;
                            _context3.next = 9;
                            break;

                          case 8:
                            _context3.t0 = undefined;

                          case 9:
                            cacheEntry = _context3.t0;

                            if (!(typeof cacheEntry === 'undefined')) {
                              _context3.next = 12;
                              break;
                            }

                            return _context3.abrupt("return", makeRequest(opts));

                          case 12:
                            policy = CachePolicy.fromObject(cacheEntry.cachePolicy);

                            if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {
                              headers = policy.responseHeaders();
                              response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                              response.cachePolicy = policy;
                              response.fromCache = true;
                              ee.emit('response', response);

                              if (typeof cb === 'function') {
                                cb(response);
                              }
                            } else {
                              revalidate = cacheEntry;
                              opts.headers = policy.revalidationHeaders(opts);
                              makeRequest(opts);
                            }

                          case 14:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    });
                  };

                  errorHandler = function errorHandler(error) {
                    return ee.emit('error', new CacheableRequest.CacheError(error));
                  };

                  _this.cache.once('error', errorHandler);

                  ee.on('response', function () {
                    return _this.cache.removeListener('error', errorHandler);
                  });
                  _context4.prev = 4;
                  _context4.next = 7;
                  return regeneratorRuntime.awrap(get(opts));

                case 7:
                  _context4.next = 13;
                  break;

                case 9:
                  _context4.prev = 9;
                  _context4.t0 = _context4["catch"](4);

                  if (opts.automaticFailover && !madeRequest) {
                    makeRequest(opts);
                  }

                  ee.emit('error', new CacheableRequest.CacheError(_context4.t0));

                case 13:
                case "end":
                  return _context4.stop();
              }
            }
          }, null, null, [[4, 9]]);
        })();

        return ee;
      };
    }
  }]);

  return CacheableRequest;
}();

function urlObjectToRequestOptions(url) {
  var options = _objectSpread({}, url);

  options.path = "".concat(url.pathname || '/').concat(url.search || '');
  delete options.pathname;
  delete options.search;
  return options;
}

function normalizeUrlObject(url) {
  // If url was parsed by url.parse or new URL:
  // - hostname will be set
  // - host will be hostname[:port]
  // - port will be set if it was explicit in the parsed string
  // Otherwise, url was from request options:
  // - hostname or host may be set
  // - host shall not have port encoded
  return {
    protocol: url.protocol,
    auth: url.auth,
    hostname: url.hostname || url.host || 'localhost',
    port: url.port,
    pathname: url.pathname,
    search: url.search
  };
}

CacheableRequest.RequestError =
/*#__PURE__*/
function (_Error) {
  _inherits(_class, _Error);

  function _class(error) {
    var _this2;

    _classCallCheck(this, _class);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, error.message));
    _this2.name = 'RequestError';
    Object.assign(_assertThisInitialized(_this2), error);
    return _this2;
  }

  return _class;
}(_wrapNativeSuper(Error));

CacheableRequest.CacheError =
/*#__PURE__*/
function (_Error2) {
  _inherits(_class2, _Error2);

  function _class2(error) {
    var _this3;

    _classCallCheck(this, _class2);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(_class2).call(this, error.message));
    _this3.name = 'CacheError';
    Object.assign(_assertThisInitialized(_this3), error);
    return _this3;
  }

  return _class2;
}(_wrapNativeSuper(Error));

module.exports = CacheableRequest;