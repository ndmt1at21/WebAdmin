"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Module dependencies.
 */
var EventEmitter = require('events').EventEmitter;

var spawn = require('child_process').spawn;

var path = require('path');

var fs = require('fs'); // @ts-check


var Option =
/*#__PURE__*/
function () {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} description
   * @api public
   */
  function Option(flags, description) {
    _classCallCheck(this, Option);

    this.flags = flags;
    this.required = flags.indexOf('<') >= 0; // A value must be supplied when the option is specified.

    this.optional = flags.indexOf('[') >= 0; // A value is optional when the option is specified.

    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.

    this.negate = flags.indexOf('-no-') !== -1;
    var flagParts = flags.split(/[ ,|]+/);
    if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) this["short"] = flagParts.shift();
    this["long"] = flagParts.shift();
    this.description = description || '';
    this.defaultValue = undefined;
  }
  /**
   * Return option name.
   *
   * @return {string}
   * @api private
   */


  _createClass(Option, [{
    key: "name",
    value: function name() {
      return this["long"].replace(/^--/, '');
    }
  }, {
    key: "attributeName",

    /**
     * Return option name, in a camelcase format that can be used
     * as a object attribute key.
     *
     * @return {string}
     * @api private
     */
    value: function attributeName() {
      return camelcase(this.name().replace(/^no-/, ''));
    }
  }, {
    key: "is",

    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {string} arg
     * @return {boolean}
     * @api private
     */
    value: function is(arg) {
      return this["short"] === arg || this["long"] === arg;
    }
  }]);

  return Option;
}();
/**
 * CommanderError class
 * @class
 */


var CommanderError =
/*#__PURE__*/
function (_Error) {
  _inherits(CommanderError, _Error);

  /**
   * Constructs the CommanderError class
   * @param {number} exitCode suggested exit code which could be used with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @constructor
   */
  function CommanderError(exitCode, code, message) {
    var _this;

    _classCallCheck(this, CommanderError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CommanderError).call(this, message)); // properly capture stack trace in Node.js

    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    _this.name = _this.constructor.name;
    _this.code = code;
    _this.exitCode = exitCode;
    _this.nestedError = undefined;
    return _this;
  }

  return CommanderError;
}(_wrapNativeSuper(Error));

var Command =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Command, _EventEmitter);

  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   * @api public
   */
  function Command(name) {
    var _this2;

    _classCallCheck(this, Command);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Command).call(this));
    _this2.commands = [];
    _this2.options = [];
    _this2.parent = null;
    _this2._allowUnknownOption = false;
    _this2._args = [];
    _this2.rawArgs = null;
    _this2._scriptPath = null;
    _this2._name = name || '';
    _this2._optionValues = {};
    _this2._storeOptionsAsProperties = true; // backwards compatible by default

    _this2._passCommandToAction = true; // backwards compatible by default

    _this2._actionResults = [];
    _this2._actionHandler = null;
    _this2._executableHandler = false;
    _this2._executableFile = null; // custom name for executable

    _this2._defaultCommandName = null;
    _this2._exitCallback = null;
    _this2._aliases = [];
    _this2._hidden = false;
    _this2._helpFlags = '-h, --help';
    _this2._helpDescription = 'display help for command';
    _this2._helpShortFlag = '-h';
    _this2._helpLongFlag = '--help';
    _this2._hasImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false

    _this2._helpCommandName = 'help';
    _this2._helpCommandnameAndArgs = 'help [command]';
    _this2._helpCommandDescription = 'display help for command';
    return _this2;
  }
  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * Examples:
   *
   *      // Command implemented using action handler (description is supplied separately to `.command`)
   *      program
   *        .command('clone <source> [destination]')
   *        .description('clone a repository into a newly created directory')
   *        .action((source, destination) => {
   *          console.log('clone command called');
   *        });
   *
   *      // Command implemented using separate executable file (description is second parameter to `.command`)
   *      program
   *        .command('start <service>', 'start named service')
   *        .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   * @api public
   */


  _createClass(Command, [{
    key: "command",
    value: function command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      var desc = actionOptsOrExecDesc;
      var opts = execOpts;

      if (_typeof(desc) === 'object' && desc !== null) {
        opts = desc;
        desc = null;
      }

      opts = opts || {};
      var args = nameAndArgs.split(/ +/);
      var cmd = this.createCommand(args.shift());

      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }

      if (opts.isDefault) this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._helpFlags = this._helpFlags;
      cmd._helpDescription = this._helpDescription;
      cmd._helpShortFlag = this._helpShortFlag;
      cmd._helpLongFlag = this._helpLongFlag;
      cmd._helpCommandName = this._helpCommandName;
      cmd._helpCommandnameAndArgs = this._helpCommandnameAndArgs;
      cmd._helpCommandDescription = this._helpCommandDescription;
      cmd._exitCallback = this._exitCallback;
      cmd._storeOptionsAsProperties = this._storeOptionsAsProperties;
      cmd._passCommandToAction = this._passCommandToAction;
      cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor

      this.commands.push(cmd);

      cmd._parseExpectedArgs(args);

      cmd.parent = this;
      if (desc) return this;
      return cmd;
    }
  }, {
    key: "createCommand",

    /**
     * Factory routine to create a new unattached command.
     *
     * See .command() for creating an attached subcommand, which uses this routine to
     * create the command. You can override createCommand to customise subcommands.
     *
     * @param {string} [name]
     * @return {Command} new command
     * @api public
     */
    value: function createCommand(name) {
      return new Command(name);
    }
  }, {
    key: "addCommand",

    /**
     * Add a prepared subcommand.
     *
     * See .command() for creating an attached subcommand which inherits settings from its parent.
     *
     * @param {Command} cmd - new subcommand
     * @param {Object} [opts] - configuration options
     * @return {Command} `this` command for chaining
     * @api public
     */
    value: function addCommand(cmd, opts) {
      if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name'); // To keep things simple, block automatic name generation for deeply nested executables.
      // Fail fast and detect when adding rather than later when parsing.

      function checkExplicitNames(commandArray) {
        commandArray.forEach(function (cmd) {
          if (cmd._executableHandler && !cmd._executableFile) {
            throw new Error("Must specify executableFile for deeply nested executable: ".concat(cmd.name()));
          }

          checkExplicitNames(cmd.commands);
        });
      }

      checkExplicitNames(cmd.commands);
      opts = opts || {};
      if (opts.isDefault) this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

      this.commands.push(cmd);
      cmd.parent = this;
      return this;
    }
  }, {
    key: "arguments",

    /**
     * Define argument syntax for the command.
     *
     * @api public
     */
    value: function _arguments(desc) {
      return this._parseExpectedArgs(desc.split(/ +/));
    }
  }, {
    key: "addHelpCommand",

    /**
     * Override default decision whether to add implicit help command.
     *
     *    addHelpCommand() // force on
     *    addHelpCommand(false); // force off
     *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom detais
     *
     * @return {Command} `this` command for chaining
     * @api public
     */
    value: function addHelpCommand(enableOrNameAndArgs, description) {
      if (enableOrNameAndArgs === false) {
        this._hasImplicitHelpCommand = false;
      } else {
        this._hasImplicitHelpCommand = true;

        if (typeof enableOrNameAndArgs === 'string') {
          this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
          this._helpCommandnameAndArgs = enableOrNameAndArgs;
        }

        this._helpCommandDescription = description || this._helpCommandDescription;
      }

      return this;
    }
  }, {
    key: "_lazyHasImplicitHelpCommand",

    /**
     * @return {boolean}
     * @api private
     */
    value: function _lazyHasImplicitHelpCommand() {
      if (this._hasImplicitHelpCommand === undefined) {
        this._hasImplicitHelpCommand = this.commands.length && !this._actionHandler && !this._findCommand('help');
      }

      return this._hasImplicitHelpCommand;
    }
  }, {
    key: "_parseExpectedArgs",

    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} `this` command for chaining
     * @api private
     */
    value: function _parseExpectedArgs(args) {
      var _this3 = this;

      if (!args.length) return;
      args.forEach(function (arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };

        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;

          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }

        if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }

        if (argDetails.name) {
          _this3._args.push(argDetails);
        }
      });

      this._args.forEach(function (arg, i) {
        if (arg.variadic && i < _this3._args.length - 1) {
          throw new Error("only the last argument can be variadic '".concat(arg.name, "'"));
        }
      });

      return this;
    }
  }, {
    key: "exitOverride",

    /**
     * Register callback to use as replacement for calling process.exit.
     *
     * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
     * @return {Command} `this` command for chaining
     * @api public
     */
    value: function exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = function (err) {
          if (err.code !== 'commander.executeSubCommandAsync') {
            throw err;
          } else {// Async callback from spawn events, not useful to throw.
          }
        };
      }

      return this;
    }
  }, {
    key: "_exit",

    /**
     * Call process.exit, and _exitCallback if defined.
     *
     * @param {number} exitCode exit code for using with process.exit
     * @param {string} code an id string representing the error
     * @param {string} message human-readable description of the error
     * @return never
     * @api private
     */
    value: function _exit(exitCode, code, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode, code, message)); // Expecting this line is not reached.

      }

      process.exit(exitCode);
    }
  }, {
    key: "action",

    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} `this` command for chaining
     * @api public
     */
    value: function action(fn) {
      var _this4 = this;

      var listener = function listener(args) {
        // The .action callback takes an extra parameter which is the command or options.
        var expectedArgsCount = _this4._args.length;
        var actionArgs = args.slice(0, expectedArgsCount);

        if (_this4._passCommandToAction) {
          actionArgs[expectedArgsCount] = _this4;
        } else {
          actionArgs[expectedArgsCount] = _this4.opts();
        } // Add the extra arguments so available too.


        if (args.length > expectedArgsCount) {
          actionArgs.push(args.slice(expectedArgsCount));
        }

        var actionResult = fn.apply(_this4, actionArgs); // Remember result in case it is async. Assume parseAsync getting called on root.

        var rootCommand = _this4;

        while (rootCommand.parent) {
          rootCommand = rootCommand.parent;
        }

        rootCommand._actionResults.push(actionResult);
      };

      this._actionHandler = listener;
      return this;
    }
  }, {
    key: "_optionEx",

    /**
     * Internal implementation shared by .option() and .requiredOption()
     *
     * @param {Object} config
     * @param {string} flags
     * @param {string} description
     * @param {Function|*} [fn] - custom option processing function or default vaue
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     * @api private
     */
    value: function _optionEx(config, flags, description, fn, defaultValue) {
      var _this5 = this;

      var option = new Option(flags, description);
      var oname = option.name();
      var name = option.attributeName();
      option.mandatory = !!config.mandatory; // default as 3rd arg

      if (typeof fn !== 'function') {
        if (fn instanceof RegExp) {
          // This is a bit simplistic (especially no error messages), and probably better handled by caller using custom option processing.
          // No longer documented in README, but still present for backwards compatibility.
          var regex = fn;

          fn = function fn(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          };
        } else {
          defaultValue = fn;
          fn = null;
        }
      } // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value


      if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {
        // when --no-foo we make sure default is true, unless a --foo option is already defined
        if (option.negate) {
          var positiveLongFlag = option["long"].replace(/^--no-/, '--');
          defaultValue = this._findOption(positiveLongFlag) ? this._getOptionValue(name) : true;
        } // preassign only if we have a default


        if (defaultValue !== undefined) {
          this._setOptionValue(name, defaultValue);

          option.defaultValue = defaultValue;
        }
      } // register the option


      this.options.push(option); // when it's passed assign the value
      // and conditionally invoke the callback

      this.on('option:' + oname, function (val) {
        // coercion
        if (val !== null && fn) {
          val = fn(val, _this5._getOptionValue(name) === undefined ? defaultValue : _this5._getOptionValue(name));
        } // unassigned or boolean value


        if (typeof _this5._getOptionValue(name) === 'boolean' || typeof _this5._getOptionValue(name) === 'undefined') {
          // if no value, negate false, and we have a default, then use it!
          if (val == null) {
            _this5._setOptionValue(name, option.negate ? false : defaultValue || true);
          } else {
            _this5._setOptionValue(name, val);
          }
        } else if (val !== null) {
          // reassign
          _this5._setOptionValue(name, option.negate ? false : val);
        }
      });
      return this;
    }
  }, {
    key: "option",

    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to undefined
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     program.pepper
     *     // => undefined
     *
     *     --pepper
     *     program.pepper
     *     // => true
     *
     *     // simple boolean defaulting to true (unless non-negated option is also defined)
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {string} flags
     * @param {string} description
     * @param {Function|*} [fn] - custom option processing function or default vaue
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     * @api public
     */
    value: function option(flags, description, fn, defaultValue) {
      return this._optionEx({}, flags, description, fn, defaultValue);
    }
  }, {
    key: "requiredOption",

    /*
    * Add a required option which must have a value after parsing. This usually means
    * the option must be specified on the command line. (Otherwise the same as .option().)
    *
    * The `flags` string should contain both the short and long flags, separated by comma, a pipe or space.
    *
    * @param {string} flags
    * @param {string} description
    * @param {Function|*} [fn] - custom option processing function or default vaue
    * @param {*} [defaultValue]
    * @return {Command} `this` command for chaining
    * @api public
    */
    value: function requiredOption(flags, description, fn, defaultValue) {
      return this._optionEx({
        mandatory: true
      }, flags, description, fn, defaultValue);
    }
  }, {
    key: "allowUnknownOption",

    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} [arg] - if `true` or omitted, no error will be thrown
     * for unknown options.
     * @api public
     */
    value: function allowUnknownOption(arg) {
      this._allowUnknownOption = arg === undefined || arg;
      return this;
    }
  }, {
    key: "storeOptionsAsProperties",

    /**
      * Whether to store option values as properties on command object,
      * or store separately (specify false). In both cases the option values can be accessed using .opts().
      *
      * @param {boolean} value
      * @return {Command} `this` command for chaining
      * @api public
      */
    value: function storeOptionsAsProperties(value) {
      this._storeOptionsAsProperties = value === undefined || value;

      if (this.options.length) {
        throw new Error('call .storeOptionsAsProperties() before adding options');
      }

      return this;
    }
  }, {
    key: "passCommandToAction",

    /**
      * Whether to pass command to action handler,
      * or just the options (specify false).
      *
      * @param {boolean} value
      * @return {Command} `this` command for chaining
      * @api public
      */
    value: function passCommandToAction(value) {
      this._passCommandToAction = value === undefined || value;
      return this;
    }
  }, {
    key: "_setOptionValue",

    /**
     * Store option value
     *
     * @param {string} key
     * @param {Object} value
     * @api private
     */
    value: function _setOptionValue(key, value) {
      if (this._storeOptionsAsProperties) {
        this[key] = value;
      } else {
        this._optionValues[key] = value;
      }
    }
  }, {
    key: "_getOptionValue",

    /**
     * Retrieve option value
     *
     * @param {string} key
     * @return {Object} value
     * @api private
     */
    value: function _getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }

      return this._optionValues[key];
    }
  }, {
    key: "parse",

    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * The default expectation is that the arguments are from node and have the application as argv[0]
     * and the script being run in argv[1], with user parameters after that.
     *
     * Examples:
     *
     *      program.parse(process.argv);
     *      program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
     *      program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv] - optional, defaults to process.argv
     * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
     * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
     * @return {Command} `this` command for chaining
     * @api public
     */
    value: function parse(argv, parseOptions) {
      if (argv !== undefined && !Array.isArray(argv)) {
        throw new Error('first parameter to parse must be array or undefined');
      }

      parseOptions = parseOptions || {}; // Default to using process.argv

      if (argv === undefined) {
        argv = process.argv; // @ts-ignore

        if (process.versions && process.versions.electron) {
          parseOptions.from = 'electron';
        }
      }

      this.rawArgs = argv.slice(); // make it a little easier for callers by supporting various argv conventions

      var userArgs;

      switch (parseOptions.from) {
        case undefined:
        case 'node':
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
          break;

        case 'electron':
          // @ts-ignore
          if (process.defaultApp) {
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
          } else {
            userArgs = argv.slice(1);
          }

          break;

        case 'user':
          userArgs = argv.slice(0);
          break;

        default:
          throw new Error("unexpected parse option { from: '".concat(parseOptions.from, "' }"));
      }

      if (!this._scriptPath && process.mainModule) {
        this._scriptPath = process.mainModule.filename;
      } // Guess name, used in usage in help.


      this._name = this._name || this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)); // Let's go!

      this._parseCommand([], userArgs);

      return this;
    }
  }, {
    key: "parseAsync",

    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
     *
     * The default expectation is that the arguments are from node and have the application as argv[0]
     * and the script being run in argv[1], with user parameters after that.
     *
     * Examples:
     *
     *      program.parseAsync(process.argv);
     *      program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
     *      program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv]
     * @param {Object} [parseOptions]
     * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
     * @return {Promise}
     * @api public
     */
    value: function parseAsync(argv, parseOptions) {
      var _this6 = this;

      this.parse(argv, parseOptions);
      return Promise.all(this._actionResults).then(function () {
        return _this6;
      });
    }
  }, {
    key: "_executeSubCommand",

    /**
     * Execute a sub-command executable.
     *
     * @api private
     */
    value: function _executeSubCommand(subcommand, args) {
      args = args.slice();
      var launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.

      var sourceExt = ['.js', '.ts', '.mjs']; // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.

      this._checkForMissingMandatoryOptions(); // Want the entry script as the reference for command name and directory for searching for other files.


      var scriptPath = this._scriptPath;
      var baseDir;

      try {
        var resolvedLink = fs.realpathSync(scriptPath);
        baseDir = path.dirname(resolvedLink);
      } catch (e) {
        baseDir = '.'; // dummy, probably not going to find executable!
      } // name of the subcommand, like `pm-install`


      var bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;

      if (subcommand._executableFile) {
        bin = subcommand._executableFile;
      }

      var localBin = path.join(baseDir, bin);

      if (fs.existsSync(localBin)) {
        // prefer local `./<bin>` to bin in the $PATH
        bin = localBin;
      } else {
        // Look for source files.
        sourceExt.forEach(function (ext) {
          if (fs.existsSync("".concat(localBin).concat(ext))) {
            bin = "".concat(localBin).concat(ext);
          }
        });
      }

      launchWithNode = sourceExt.includes(path.extname(bin));
      var proc;

      if (process.platform !== 'win32') {
        if (launchWithNode) {
          args.unshift(bin); // add executable arguments to spawn

          args = incrementNodeInspectorPort(process.execArgv).concat(args);
          proc = spawn(process.argv[0], args, {
            stdio: 'inherit'
          });
        } else {
          proc = spawn(bin, args, {
            stdio: 'inherit'
          });
        }
      } else {
        args.unshift(bin); // add executable arguments to spawn

        args = incrementNodeInspectorPort(process.execArgv).concat(args);
        proc = spawn(process.execPath, args, {
          stdio: 'inherit'
        });
      }

      var signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach(function (signal) {
        // @ts-ignore
        process.on(signal, function () {
          if (proc.killed === false && proc.exitCode === null) {
            proc.kill(signal);
          }
        });
      }); // By default terminate process when spawned process terminates.
      // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!

      var exitCallback = this._exitCallback;

      if (!exitCallback) {
        proc.on('close', process.exit.bind(process));
      } else {
        proc.on('close', function () {
          exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
        });
      }

      proc.on('error', function (err) {
        // @ts-ignore
        if (err.code === 'ENOENT') {
          var executableMissing = "'".concat(bin, "' does not exist\n - if '").concat(subcommand._name, "' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name");
          throw new Error(executableMissing); // @ts-ignore
        } else if (err.code === 'EACCES') {
          throw new Error("'".concat(bin, "' not executable"));
        }

        if (!exitCallback) {
          process.exit(1);
        } else {
          var wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      }); // Store the reference to the child process

      this.runningCommand = proc;
    }
  }, {
    key: "_dispatchSubcommand",

    /**
     * @api private
     */
    value: function _dispatchSubcommand(commandName, operands, unknown) {
      var subCommand = this._findCommand(commandName);

      if (!subCommand) this._helpAndError();

      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        subCommand._parseCommand(operands, unknown);
      }
    }
  }, {
    key: "_parseCommand",

    /**
     * Process arguments in context of this command.
     *
     * @api private
     */
    value: function _parseCommand(operands, unknown) {
      var _this7 = this;

      var parsed = this.parseOptions(unknown);
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);

      if (operands && this._findCommand(operands[0])) {
        this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      } else if (this._lazyHasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
        if (operands.length === 1) {
          this.help();
        } else {
          this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
        }
      } else if (this._defaultCommandName) {
        outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command

        this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      } else {
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          // probaby missing subcommand and no handler, user needs help
          this._helpAndError();
        }

        outputHelpIfRequested(this, parsed.unknown);

        this._checkForMissingMandatoryOptions();

        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }

        if (this._actionHandler) {
          var args = this.args.slice();

          this._args.forEach(function (arg, i) {
            if (arg.required && args[i] == null) {
              _this7.missingArgument(arg.name);
            } else if (arg.variadic) {
              args[i] = args.splice(i);
            }
          });

          this._actionHandler(args);

          this.emit('command:' + this.name(), operands, unknown);
        } else if (operands.length) {
          if (this._findCommand('*')) {
            this._dispatchSubcommand('*', operands, unknown);
          } else if (this.listenerCount('command:*')) {
            this.emit('command:*', operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          }
        } else if (this.commands.length) {
          // This command has subcommands and nothing hooked up at this level, so display help.
          this._helpAndError();
        } else {// fall through for caller to handle after calling .parse()
        }
      }
    }
  }, {
    key: "_findCommand",

    /**
     * Find matching command.
     *
     * @api private
     */
    value: function _findCommand(name) {
      if (!name) return undefined;
      return this.commands.find(function (cmd) {
        return cmd._name === name || cmd._aliases.includes(name);
      });
    }
  }, {
    key: "_findOption",

    /**
     * Return an option matching `arg` if any.
     *
     * @param {string} arg
     * @return {Option}
     * @api private
     */
    value: function _findOption(arg) {
      return this.options.find(function (option) {
        return option.is(arg);
      });
    }
  }, {
    key: "_checkForMissingMandatoryOptions",

    /**
     * Display an error message if a mandatory option does not have a value.
     * Lazy calling after checking for help flags from leaf subcommand.
     *
     * @api private
     */
    value: function _checkForMissingMandatoryOptions() {
      var _loop = function _loop(cmd) {
        cmd.options.forEach(function (anOption) {
          if (anOption.mandatory && cmd._getOptionValue(anOption.attributeName()) === undefined) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      };

      // Walk up hierarchy so can call in subcommand after checking for displaying help.
      for (var cmd = this; cmd; cmd = cmd.parent) {
        _loop(cmd);
      }
    }
  }, {
    key: "parseOptions",

    /**
     * Parse options from `argv` removing known options,
     * and return argv split into operands and unknown arguments.
     *
     * Examples:
     *
     *    argv => operands, unknown
     *    --known kkk op => [op], []
     *    op --known kkk => [op], []
     *    sub --unknown uuu op => [sub], [--unknown uuu op]
     *    sub -- --unknown uuu op => [sub --unknown uuu op], []
     *
     * @param {String[]} argv
     * @return {{operands: String[], unknown: String[]}}
     * @api public
     */
    value: function parseOptions(argv) {
      var operands = []; // operands, not options or values

      var unknown = []; // first unknown option and remaining unknown args

      var dest = operands;
      var args = argv.slice();

      function maybeOption(arg) {
        return arg.length > 1 && arg[0] === '-';
      } // parse options


      while (args.length) {
        var arg = args.shift(); // literal

        if (arg === '--') {
          var _dest;

          if (dest === unknown) dest.push(arg);

          (_dest = dest).push.apply(_dest, _toConsumableArray(args));

          break;
        }

        if (maybeOption(arg)) {
          var option = this._findOption(arg); // recognised option, call listener to assign value with possible custom processing


          if (option) {
            if (option.required) {
              var value = args.shift();
              if (value === undefined) this.optionMissingArgument(option);
              this.emit("option:".concat(option.name()), value);
            } else if (option.optional) {
              var _value = null; // historical behaviour is optional value is following arg unless an option

              if (args.length > 0 && !maybeOption(args[0])) {
                _value = args.shift();
              }

              this.emit("option:".concat(option.name()), _value);
            } else {
              // boolean flag
              this.emit("option:".concat(option.name()));
            }

            continue;
          }
        } // Look for combo options following single dash, eat first one if known.


        if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
          var _option = this._findOption("-".concat(arg[1]));

          if (_option) {
            if (_option.required || _option.optional) {
              // option with value following in same argument
              this.emit("option:".concat(_option.name()), arg.slice(2));
            } else {
              // boolean option, emit and put back remainder of arg for further processing
              this.emit("option:".concat(_option.name()));
              args.unshift("-".concat(arg.slice(2)));
            }

            continue;
          }
        } // Look for known long flag with value, like --foo=bar


        if (/^--[^=]+=/.test(arg)) {
          var index = arg.indexOf('=');

          var _option2 = this._findOption(arg.slice(0, index));

          if (_option2 && (_option2.required || _option2.optional)) {
            this.emit("option:".concat(_option2.name()), arg.slice(index + 1));
            continue;
          }
        } // looks like an option but unknown, unknowns from here


        if (arg.length > 1 && arg[0] === '-') {
          dest = unknown;
        } // add arg


        dest.push(arg);
      }

      return {
        operands: operands,
        unknown: unknown
      };
    }
  }, {
    key: "opts",

    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    value: function opts() {
      if (this._storeOptionsAsProperties) {
        // Preserve original behaviour so backwards compatible when still using properties
        var result = {};
        var len = this.options.length;

        for (var i = 0; i < len; i++) {
          var key = this.options[i].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }

        return result;
      }

      return this._optionValues;
    }
  }, {
    key: "missingArgument",

    /**
     * Argument `name` is missing.
     *
     * @param {string} name
     * @api private
     */
    value: function missingArgument(name) {
      var message = "error: missing required argument '".concat(name, "'");
      console.error(message);

      this._exit(1, 'commander.missingArgument', message);
    }
  }, {
    key: "optionMissingArgument",

    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {Option} option
     * @param {string} [flag]
     * @api private
     */
    value: function optionMissingArgument(option, flag) {
      var message;

      if (flag) {
        message = "error: option '".concat(option.flags, "' argument missing, got '").concat(flag, "'");
      } else {
        message = "error: option '".concat(option.flags, "' argument missing");
      }

      console.error(message);

      this._exit(1, 'commander.optionMissingArgument', message);
    }
  }, {
    key: "missingMandatoryOptionValue",

    /**
     * `Option` does not have a value, and is a mandatory option.
     *
     * @param {Option} option
     * @api private
     */
    value: function missingMandatoryOptionValue(option) {
      var message = "error: required option '".concat(option.flags, "' not specified");
      console.error(message);

      this._exit(1, 'commander.missingMandatoryOptionValue', message);
    }
  }, {
    key: "unknownOption",

    /**
     * Unknown option `flag`.
     *
     * @param {string} flag
     * @api private
     */
    value: function unknownOption(flag) {
      if (this._allowUnknownOption) return;
      var message = "error: unknown option '".concat(flag, "'");
      console.error(message);

      this._exit(1, 'commander.unknownOption', message);
    }
  }, {
    key: "unknownCommand",

    /**
     * Unknown command.
     *
     * @api private
     */
    value: function unknownCommand() {
      var partCommands = [this.name()];

      for (var parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {
        partCommands.unshift(parentCmd.name());
      }

      var fullCommand = partCommands.join(' ');
      var message = "error: unknown command '".concat(this.args[0], "'. See '").concat(fullCommand, " ").concat(this._helpLongFlag, "'.");
      console.error(message);

      this._exit(1, 'commander.unknownCommand', message);
    }
  }, {
    key: "version",

    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * You can optionally supply the  flags and description to override the defaults.
     *
     * @param {string} str
     * @param {string} [flags]
     * @param {string} [description]
     * @return {this | string} `this` command for chaining, or version string if no arguments
     * @api public
     */
    value: function version(str, flags, description) {
      var _this8 = this;

      if (str === undefined) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      description = description || 'output the version number';
      var versionOption = new Option(flags, description);
      this._versionOptionName = versionOption["long"].substr(2) || 'version';
      this.options.push(versionOption);
      this.on('option:' + this._versionOptionName, function () {
        process.stdout.write(str + '\n');

        _this8._exit(0, 'commander.version', str);
      });
      return this;
    }
  }, {
    key: "description",

    /**
     * Set the description to `str`.
     *
     * @param {string} str
     * @param {Object} [argsDescription]
     * @return {string|Command}
     * @api public
     */
    value: function description(str, argsDescription) {
      if (str === undefined && argsDescription === undefined) return this._description;
      this._description = str;
      this._argsDescription = argsDescription;
      return this;
    }
  }, {
    key: "alias",

    /**
     * Set an alias for the command.
     *
     * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
     *
     * @param {string} [alias]
     * @return {string|Command}
     * @api public
     */
    value: function alias(_alias) {
      if (_alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

      var command = this;

      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        // assume adding alias for last added executable subcommand, rather than this
        command = this.commands[this.commands.length - 1];
      }

      if (_alias === command._name) throw new Error('Command alias can\'t be the same as its name');

      command._aliases.push(_alias);

      return this;
    }
  }, {
    key: "aliases",

    /**
     * Set aliases for the command.
     *
     * Only the first alias is shown in the auto-generated help.
     *
     * @param {string[]} [aliases]
     * @return {string[]|Command}
     * @api public
     */
    value: function aliases(_aliases) {
      var _this9 = this;

      // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
      if (_aliases === undefined) return this._aliases;

      _aliases.forEach(function (alias) {
        return _this9.alias(alias);
      });

      return this;
    }
  }, {
    key: "usage",

    /**
     * Set / get the command usage `str`.
     *
     * @param {string} [str]
     * @return {String|Command}
     * @api public
     */
    value: function usage(str) {
      if (str === undefined) {
        if (this._usage) return this._usage;

        var args = this._args.map(function (arg) {
          return humanReadableArgName(arg);
        });

        return '[options]' + (this.commands.length ? ' [command]' : '') + (this._args.length ? ' ' + args.join(' ') : '');
      }

      this._usage = str;
      return this;
    }
  }, {
    key: "name",

    /**
     * Get or set the name of the command
     *
     * @param {string} [str]
     * @return {String|Command}
     * @api public
     */
    value: function name(str) {
      if (str === undefined) return this._name;
      this._name = str;
      return this;
    }
  }, {
    key: "prepareCommands",

    /**
     * Return prepared commands.
     *
     * @return {Array}
     * @api private
     */
    value: function prepareCommands() {
      var commandDetails = this.commands.filter(function (cmd) {
        return !cmd._hidden;
      }).map(function (cmd) {
        var args = cmd._args.map(function (arg) {
          return humanReadableArgName(arg);
        }).join(' ');

        return [cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + (args ? ' ' + args : ''), cmd._description];
      });

      if (this._lazyHasImplicitHelpCommand()) {
        commandDetails.push([this._helpCommandnameAndArgs, this._helpCommandDescription]);
      }

      return commandDetails;
    }
  }, {
    key: "largestCommandLength",

    /**
     * Return the largest command length.
     *
     * @return {number}
     * @api private
     */
    value: function largestCommandLength() {
      var commands = this.prepareCommands();
      return commands.reduce(function (max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    }
  }, {
    key: "largestOptionLength",

    /**
     * Return the largest option length.
     *
     * @return {number}
     * @api private
     */
    value: function largestOptionLength() {
      var options = [].slice.call(this.options);
      options.push({
        flags: this._helpFlags
      });
      return options.reduce(function (max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    }
  }, {
    key: "largestArgLength",

    /**
     * Return the largest arg length.
     *
     * @return {number}
     * @api private
     */
    value: function largestArgLength() {
      return this._args.reduce(function (max, arg) {
        return Math.max(max, arg.name.length);
      }, 0);
    }
  }, {
    key: "padWidth",

    /**
     * Return the pad width.
     *
     * @return {number}
     * @api private
     */
    value: function padWidth() {
      var width = this.largestOptionLength();

      if (this._argsDescription && this._args.length) {
        if (this.largestArgLength() > width) {
          width = this.largestArgLength();
        }
      }

      if (this.commands && this.commands.length) {
        if (this.largestCommandLength() > width) {
          width = this.largestCommandLength();
        }
      }

      return width;
    }
  }, {
    key: "optionHelp",

    /**
     * Return help for options.
     *
     * @return {string}
     * @api private
     */
    value: function optionHelp() {
      var width = this.padWidth();
      var columns = process.stdout.columns || 80;
      var descriptionWidth = columns - width - 4;

      function padOptionDetails(flags, description) {
        return pad(flags, width) + '  ' + optionalWrap(description, descriptionWidth, width + 2);
      }

      ; // Explicit options (including version)

      var help = this.options.map(function (option) {
        var fullDesc = option.description + (!option.negate && option.defaultValue !== undefined ? ' (default: ' + JSON.stringify(option.defaultValue) + ')' : '');
        return padOptionDetails(option.flags, fullDesc);
      }); // Implicit help

      var showShortHelpFlag = this._helpShortFlag && !this._findOption(this._helpShortFlag);
      var showLongHelpFlag = !this._findOption(this._helpLongFlag);

      if (showShortHelpFlag || showLongHelpFlag) {
        var helpFlags = this._helpFlags;

        if (!showShortHelpFlag) {
          helpFlags = this._helpLongFlag;
        } else if (!showLongHelpFlag) {
          helpFlags = this._helpShortFlag;
        }

        help.push(padOptionDetails(helpFlags, this._helpDescription));
      }

      return help.join('\n');
    }
  }, {
    key: "commandHelp",

    /**
     * Return command help documentation.
     *
     * @return {string}
     * @api private
     */
    value: function commandHelp() {
      if (!this.commands.length && !this._lazyHasImplicitHelpCommand()) return '';
      var commands = this.prepareCommands();
      var width = this.padWidth();
      var columns = process.stdout.columns || 80;
      var descriptionWidth = columns - width - 4;
      return ['Commands:', commands.map(function (cmd) {
        var desc = cmd[1] ? '  ' + cmd[1] : '';
        return (desc ? pad(cmd[0], width) : cmd[0]) + optionalWrap(desc, descriptionWidth, width + 2);
      }).join('\n').replace(/^/gm, '  '), ''].join('\n');
    }
  }, {
    key: "helpInformation",

    /**
     * Return program help documentation.
     *
     * @return {string}
     * @api public
     */
    value: function helpInformation() {
      var desc = [];

      if (this._description) {
        desc = [this._description, ''];
        var argsDescription = this._argsDescription;

        if (argsDescription && this._args.length) {
          var width = this.padWidth();
          var columns = process.stdout.columns || 80;
          var descriptionWidth = columns - width - 5;
          desc.push('Arguments:');
          desc.push('');

          this._args.forEach(function (arg) {
            desc.push('  ' + pad(arg.name, width) + '  ' + wrap(argsDescription[arg.name], descriptionWidth, width + 4));
          });

          desc.push('');
        }
      }

      var cmdName = this._name;

      if (this._aliases[0]) {
        cmdName = cmdName + '|' + this._aliases[0];
      }

      var parentCmdNames = '';

      for (var parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {
        parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;
      }

      var usage = ['Usage: ' + parentCmdNames + cmdName + ' ' + this.usage(), ''];
      var cmds = [];
      var commandHelp = this.commandHelp();
      if (commandHelp) cmds = [commandHelp];
      var options = ['Options:', '' + this.optionHelp().replace(/^/gm, '  '), ''];
      return usage.concat(desc).concat(options).concat(cmds).join('\n');
    }
  }, {
    key: "outputHelp",

    /**
     * Output help information for this command.
     *
     * When listener(s) are available for the helpLongFlag
     * those callbacks are invoked.
     *
     * @api public
     */
    value: function outputHelp(cb) {
      if (!cb) {
        cb = function cb(passthru) {
          return passthru;
        };
      }

      var cbOutput = cb(this.helpInformation());

      if (typeof cbOutput !== 'string' && !Buffer.isBuffer(cbOutput)) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }

      process.stdout.write(cbOutput);
      this.emit(this._helpLongFlag);
    }
  }, {
    key: "helpOption",

    /**
     * You can pass in flags and a description to override the help
     * flags and help description for your command.
     *
     * @param {string} [flags]
     * @param {string} [description]
     * @return {Command} `this` command for chaining
     * @api public
     */
    value: function helpOption(flags, description) {
      this._helpFlags = flags || this._helpFlags;
      this._helpDescription = description || this._helpDescription;

      var splitFlags = this._helpFlags.split(/[ ,|]+/);

      this._helpShortFlag = undefined;
      if (splitFlags.length > 1) this._helpShortFlag = splitFlags.shift();
      this._helpLongFlag = splitFlags.shift();
      return this;
    }
  }, {
    key: "help",

    /**
     * Output help information and exit.
     *
     * @param {Function} [cb]
     * @api public
     */
    value: function help(cb) {
      this.outputHelp(cb); // exitCode: preserving original behaviour which was calling process.exit()
      // message: do not have all displayed text available so only passing placeholder.

      this._exit(process.exitCode || 0, 'commander.help', '(outputHelp)');
    }
  }, {
    key: "_helpAndError",

    /**
     * Output help information and exit. Display for error situations.
     *
     * @api private
     */
    value: function _helpAndError() {
      this.outputHelp(); // message: do not have all displayed text available so only passing placeholder.

      this._exit(1, 'commander.help', '(outputHelp)');
    }
  }]);

  return Command;
}(EventEmitter);

;
/**
 * Expose the root command.
 */

exports = module.exports = new Command();
exports.program = exports; // More explicit access to global command.

/**
 * Expose classes
 */

exports.Command = Command;
exports.Option = Option;
exports.CommanderError = CommanderError;
/**
 * Camel-case the given `flag`
 *
 * @param {string} flag
 * @return {string}
 * @api private
 */

function camelcase(flag) {
  return flag.split('-').reduce(function (str, word) {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}
/**
 * Pad `str` to `width`.
 *
 * @param {string} str
 * @param {number} width
 * @return {string}
 * @api private
 */


function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(' ');
}
/**
 * Wraps the given string with line breaks at the specified width while breaking
 * words and indenting every but the first line on the left.
 *
 * @param {string} str
 * @param {number} width
 * @param {number} indent
 * @return {string}
 * @api private
 */


function wrap(str, width, indent) {
  var regex = new RegExp('.{1,' + (width - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", 'g');
  var lines = str.match(regex) || [];
  return lines.map(function (line, i) {
    if (line.slice(-1) === '\n') {
      line = line.slice(0, line.length - 1);
    }

    return (i > 0 && indent ? Array(indent + 1).join(' ') : '') + line.trimRight();
  }).join('\n');
}
/**
 * Optionally wrap the given str to a max width of width characters per line
 * while indenting with indent spaces. Do not wrap if insufficient width or
 * string is manually formatted.
 *
 * @param {string} str
 * @param {number} width
 * @param {number} indent
 * @return {string}
 * @api private
 */


function optionalWrap(str, width, indent) {
  // Detect manually wrapped and indented strings by searching for line breaks
  // followed by multiple spaces/tabs.
  if (str.match(/[\n]\s+/)) return str; // Do not wrap to narrow columns (or can end up with a word per line).

  var minWidth = 40;
  if (width < minWidth) return str;
  return wrap(str, width, indent);
}
/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - command to output help for
 * @param {Array} args - array of options to search for help flags
 * @api private
 */


function outputHelpIfRequested(cmd, args) {
  var helpOption = args.find(function (arg) {
    return arg === cmd._helpLongFlag || arg === cmd._helpShortFlag;
  });

  if (helpOption) {
    cmd.outputHelp(); // (Do not have all displayed text available so only passing placeholder.)

    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
  }
}
/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Object} arg
 * @return {string}
 * @api private
 */


function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
}
/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */


function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map(function (arg) {
    var result = arg;

    if (arg.indexOf('--inspect') === 0) {
      var debugOption;
      var debugHost = '127.0.0.1';
      var debugPort = '9229';
      var match;

      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        // e.g. --inspect
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];

        if (/^\d+$/.test(match[3])) {
          // e.g. --inspect=1234
          debugPort = match[3];
        } else {
          // e.g. --inspect=localhost
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        // e.g. --inspect=localhost:1234
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }

      if (debugOption && debugPort !== '0') {
        result = "".concat(debugOption, "=").concat(debugHost, ":").concat(parseInt(debugPort) + 1);
      }
    }

    return result;
  });
}