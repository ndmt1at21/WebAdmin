'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = require('url'),
    URL = _require.URL;

var _require2 = require('http'),
    HttpAgent = _require2.Agent;

var _require3 = require('https'),
    HttpsAgent = _require3.Agent;

var got = require('got');

var registryUrl = require('registry-url');

var registryAuthToken = require('registry-auth-token');

var semver = require('semver'); // These agent options are chosen to match the npm client defaults and help with performance
// See: `npm config get maxsockets` and #50


var agentOptions = {
  keepAlive: true,
  maxSockets: 50
};
var httpAgent = new HttpAgent(agentOptions);
var httpsAgent = new HttpsAgent(agentOptions);

var PackageNotFoundError =
/*#__PURE__*/
function (_Error) {
  _inherits(PackageNotFoundError, _Error);

  function PackageNotFoundError(packageName) {
    var _this;

    _classCallCheck(this, PackageNotFoundError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PackageNotFoundError).call(this, "Package `".concat(packageName, "` could not be found")));
    _this.name = 'PackageNotFoundError';
    return _this;
  }

  return PackageNotFoundError;
}(_wrapNativeSuper(Error));

var VersionNotFoundError =
/*#__PURE__*/
function (_Error2) {
  _inherits(VersionNotFoundError, _Error2);

  function VersionNotFoundError(packageName, version) {
    var _this2;

    _classCallCheck(this, VersionNotFoundError);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(VersionNotFoundError).call(this, "Version `".concat(version, "` for package `").concat(packageName, "` could not be found")));
    _this2.name = 'VersionNotFoundError';
    return _this2;
  }

  return VersionNotFoundError;
}(_wrapNativeSuper(Error));

var packageJson = function packageJson(packageName, options) {
  var scope, registryUrl_, packageUrl, authInfo, headers, gotOptions, response, data, _options, version, versionError, versions;

  return regeneratorRuntime.async(function packageJson$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _objectSpread({
            version: 'latest'
          }, options);
          scope = packageName.split('/')[0];
          registryUrl_ = options.registryUrl || registryUrl(scope);
          packageUrl = new URL(encodeURIComponent(packageName).replace(/^%40/, '@'), registryUrl_);
          authInfo = registryAuthToken(registryUrl_.toString(), {
            recursive: true
          });
          headers = {
            accept: 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'
          };

          if (options.fullMetadata) {
            delete headers.accept;
          }

          if (authInfo) {
            headers.authorization = "".concat(authInfo.type, " ").concat(authInfo.token);
          }

          gotOptions = {
            json: true,
            headers: headers,
            agent: {
              http: httpAgent,
              https: httpsAgent
            }
          };

          if (options.agent) {
            gotOptions.agent = options.agent;
          }

          _context.prev = 10;
          _context.next = 13;
          return regeneratorRuntime.awrap(got(packageUrl, gotOptions));

        case 13:
          response = _context.sent;
          _context.next = 21;
          break;

        case 16:
          _context.prev = 16;
          _context.t0 = _context["catch"](10);

          if (!(_context.t0.statusCode === 404)) {
            _context.next = 20;
            break;
          }

          throw new PackageNotFoundError(packageName);

        case 20:
          throw _context.t0;

        case 21:
          data = response.body;

          if (!options.allVersions) {
            _context.next = 24;
            break;
          }

          return _context.abrupt("return", data);

        case 24:
          _options = options, version = _options.version;
          versionError = new VersionNotFoundError(packageName, version);

          if (!data['dist-tags'][version]) {
            _context.next = 30;
            break;
          }

          data = data.versions[data['dist-tags'][version]];
          _context.next = 39;
          break;

        case 30:
          if (!version) {
            _context.next = 39;
            break;
          }

          if (data.versions[version]) {
            _context.next = 36;
            break;
          }

          versions = Object.keys(data.versions);
          version = semver.maxSatisfying(versions, version);

          if (version) {
            _context.next = 36;
            break;
          }

          throw versionError;

        case 36:
          data = data.versions[version];

          if (data) {
            _context.next = 39;
            break;
          }

          throw versionError;

        case 39:
          return _context.abrupt("return", data);

        case 40:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[10, 16]]);
};

module.exports = packageJson; // TODO: remove this in the next major version

module.exports["default"] = packageJson;
module.exports.PackageNotFoundError = PackageNotFoundError;
module.exports.VersionNotFoundError = VersionNotFoundError;