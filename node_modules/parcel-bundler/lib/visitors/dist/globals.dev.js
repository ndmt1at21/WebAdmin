"use strict";

var Path = require('path');

var types = require('@babel/types');

var VARS = {
  process: function process(asset) {
    asset.addDependency('process');
    return 'var process = require("process");';
  },
  global: function global(asset) {
    return "var global = arguments[".concat(asset.options.scopeHoist ? 0 : 3, "];");
  },
  __dirname: function __dirname(asset) {
    return "var __dirname = ".concat(JSON.stringify(Path.dirname(asset.name)), ";");
  },
  __filename: function __filename(asset) {
    return "var __filename = ".concat(JSON.stringify(asset.name), ";");
  },
  Buffer: function Buffer(asset) {
    asset.addDependency('buffer');
    return 'var Buffer = require("buffer").Buffer;';
  },
  // Prevent AMD defines from working when loading UMD bundles.
  // Ideally the CommonJS check would come before the AMD check, but many
  // existing modules do the checks the opposite way leading to modules
  // not exporting anything to Parcel.
  define: function define() {
    return 'var define;';
  }
};
module.exports = {
  Identifier: function Identifier(node, asset, ancestors) {
    var parent = ancestors[ancestors.length - 2];

    if (VARS.hasOwnProperty(node.name) && !asset.globals.has(node.name) && types.isReferenced(node, parent)) {
      asset.globals.set(node.name, VARS[node.name](asset));
    }
  },
  Declaration: function Declaration(node, asset, ancestors) {
    // If there is a global declaration of one of the variables, remove our declaration
    var identifiers = types.getBindingIdentifiers(node);

    for (var id in identifiers) {
      if (VARS.hasOwnProperty(id) && !inScope(ancestors)) {
        // Don't delete entirely, so we don't add it again when the declaration is referenced
        asset.globals.set(id, '');
      }
    }
  }
};

function inScope(ancestors) {
  for (var i = ancestors.length - 2; i >= 0; i--) {
    if (types.isScope(ancestors[i]) && !types.isProgram(ancestors[i])) {
      return true;
    }
  }

  return false;
}