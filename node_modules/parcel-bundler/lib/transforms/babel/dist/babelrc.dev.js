"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var semver = require('semver');

var logger = require('@parcel/logger');

var path = require('path');

var localRequire = require('../../utils/localRequire');

var installPackage = require('../../utils/installPackage');

var fs = require('@parcel/fs');

var micromatch = require('micromatch');

function getBabelConfig(_x, _x2) {
  return _getBabelConfig.apply(this, arguments);
}

function _getBabelConfig() {
  _getBabelConfig = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(asset, isSource) {
    var config, plugins, babelVersion;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getBabelRc(asset, isSource);

          case 2:
            config = _context.sent;

            if (config) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", null);

          case 5:
            if (!((!config.plugins || config.plugins.length === 0) && (!config.presets || config.presets.length === 0))) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", null);

          case 7:
            _context.next = 9;
            return installPlugins(asset, config);

          case 9:
            plugins = _context.sent;
            _context.next = 12;
            return getBabelVersion(asset, plugins);

          case 12:
            babelVersion = _context.sent;
            return _context.abrupt("return", {
              babelVersion: babelVersion,
              config: config
            });

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getBabelConfig.apply(this, arguments);
}

module.exports = getBabelConfig;
/**
 * Finds a .babelrc for an asset. By default, .babelrc files inside node_modules are not used.
 * However, there are some exceptions:
 *   - if `browserify.transforms` includes "babelify" in package.json (for legacy module compat)
 *   - the `source` field in package.json is used by the resolver
 */

function getBabelRc(_x3, _x4) {
  return _getBabelRc.apply(this, arguments);
}

function _getBabelRc() {
  _getBabelRc = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(asset, isSource) {
    var pkg, browserify, babelify;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return asset.getPackage();

          case 2:
            pkg = _context2.sent;
            browserify = pkg && pkg.browserify;

            if (!(browserify && Array.isArray(browserify.transform))) {
              _context2.next = 9;
              break;
            }

            // Look for babelify in the browserify transform list
            babelify = browserify.transform.find(function (t) {
              return (Array.isArray(t) ? t[0] : t) === 'babelify';
            }); // If specified as an array, override the config with the one specified

            if (!(Array.isArray(babelify) && babelify[1])) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return", babelify[1]);

          case 8:
            return _context2.abrupt("return", babelify ? findBabelRc(asset) : null);

          case 9:
            if (!isSource) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt("return", findBabelRc(asset));

          case 11:
            return _context2.abrupt("return", null);

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getBabelRc.apply(this, arguments);
}

function findBabelRc(_x5) {
  return _findBabelRc.apply(this, arguments);
}

function _findBabelRc() {
  _findBabelRc = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3(asset) {
    var config, _i, _arr, key, ignoreConfig;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return asset.getConfig(['.babelrc', '.babelrc.js'], {
              packageKey: 'babel'
            });

          case 2:
            config = _context3.sent;

            if (config) {
              _context3.next = 5;
              break;
            }

            return _context3.abrupt("return", null);

          case 5:
            if (!(typeof config === 'function')) {
              _context3.next = 7;
              break;
            }

            throw new Error('Parcel does not support function configs in .babelrc.js yet.');

          case 7:
            _i = 0, _arr = ['extends', 'overrides', 'test', 'include', 'exclude'];

          case 8:
            if (!(_i < _arr.length)) {
              _context3.next = 15;
              break;
            }

            key = _arr[_i];

            if (!config[key]) {
              _context3.next = 12;
              break;
            }

            throw new Error("Parcel does not support babel 7 advanced configuration option \"".concat(key, "\" yet."));

          case 12:
            _i++;
            _context3.next = 8;
            break;

          case 15:
            if (!shouldIgnore(asset, config)) {
              _context3.next = 17;
              break;
            }

            return _context3.abrupt("return", null);

          case 17:
            _context3.next = 19;
            return getIgnoreConfig(asset);

          case 19:
            ignoreConfig = _context3.sent;

            if (!(ignoreConfig && shouldIgnore(asset, ignoreConfig))) {
              _context3.next = 22;
              break;
            }

            return _context3.abrupt("return", null);

          case 22:
            return _context3.abrupt("return", config);

          case 23:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _findBabelRc.apply(this, arguments);
}

function getIgnoreConfig(_x6) {
  return _getIgnoreConfig.apply(this, arguments);
}

function _getIgnoreConfig() {
  _getIgnoreConfig = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(asset) {
    var ignoreFile, data, patterns;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return asset.getConfig(['.babelignore'], {
              load: false
            });

          case 2:
            ignoreFile = _context4.sent;

            if (ignoreFile) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt("return", null);

          case 5:
            _context4.next = 7;
            return fs.readFile(ignoreFile, 'utf8');

          case 7:
            data = _context4.sent;
            patterns = data.split('\n').map(function (line) {
              return line.replace(/#.*$/, '').trim();
            }).filter(Boolean);
            return _context4.abrupt("return", {
              ignore: patterns
            });

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getIgnoreConfig.apply(this, arguments);
}

function shouldIgnore(asset, config) {
  if (config.ignore && matchesPatterns(config.ignore, asset.name)) {
    return true;
  }

  if (config.only && !matchesPatterns(config.only, asset.name)) {
    return true;
  }

  return false;
}

function matchesPatterns(patterns, path) {
  return patterns.some(function (pattern) {
    if (typeof pattern === 'function') {
      return !!pattern(path);
    }

    if (typeof pattern === 'string') {
      return micromatch.isMatch(path, '**/' + pattern + '/**');
    }

    return pattern.test(path);
  });
}

function getBabelVersion(_x7, _x8) {
  return _getBabelVersion.apply(this, arguments);
}

function _getBabelVersion() {
  _getBabelVersion = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee5(asset, plugins) {
    var pkg, babelLegacy, babelModern, inferred, name;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return asset.getPackage();

          case 2:
            pkg = _context5.sent;
            babelLegacy = getDependency(pkg, 'babel-core');
            babelModern = getDependency(pkg, '@babel/core');

            if (!babelModern) {
              _context5.next = 7;
              break;
            }

            return _context5.abrupt("return", getMaxMajor(babelModern));

          case 7:
            if (!babelLegacy) {
              _context5.next = 9;
              break;
            }

            return _context5.abrupt("return", 6);

          case 9:
            _context5.next = 11;
            return inferBabelVersion(asset, plugins);

          case 11:
            inferred = _context5.sent;
            name = inferred === 6 ? 'babel-core' : "@babel/core";
            _context5.next = 15;
            return installPackage(name, asset.name);

          case 15:
            return _context5.abrupt("return", inferred);

          case 16:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _getBabelVersion.apply(this, arguments);
}

function getDependency(pkg, dep) {
  return pkg.dependencies && pkg.dependencies[dep] || pkg.peerDependencies && pkg.peerDependencies[dep] || pkg.devDependencies && pkg.devDependencies[dep];
} // Core babel packages we use to infer the major version of babel to use.


var CORE_DEPS = new Set(['@babel/core', '@babel/runtime', '@babel/template', '@babel/traverse', '@babel/types', '@babel/parser', '@babel/cli', '@babel/register', '@babel/generator', 'babel-core', 'babel-runtime', 'babel-template', 'babel-traverse', 'babel-types', 'babylon', 'babel-cli', 'babel-register', 'babel-generator']);

function inferBabelVersion(_x9, _x10) {
  return _inferBabelVersion.apply(this, arguments);
}

function _inferBabelVersion() {
  _inferBabelVersion = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee6(asset, plugins) {
    var version, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pkg, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, name, dep, range;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            // Attempt to determine version based on dependencies of plugins
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context6.prev = 3;
            _iterator = plugins[Symbol.iterator]();

          case 5:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context6.next = 43;
              break;
            }

            pkg = _step.value;

            if (pkg) {
              _context6.next = 9;
              break;
            }

            return _context6.abrupt("continue", 40);

          case 9:
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            _context6.prev = 12;
            _iterator2 = CORE_DEPS[Symbol.iterator]();

          case 14:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              _context6.next = 26;
              break;
            }

            name = _step2.value;
            dep = getDependency(pkg, name);

            if (!dep) {
              _context6.next = 23;
              break;
            }

            // Parse version range (ignore prerelease), and ensure it overlaps with the existing version (if any)
            range = new semver.Range(dep.replace(/-.*(\s|\|\||$)?/, ''));

            if (!(version && !version.intersects(range))) {
              _context6.next = 21;
              break;
            }

            throw new Error('Conflicting babel versions found in .babelrc. Make sure all of your plugins and presets depend on the same major version of babel.');

          case 21:
            version = range;
            return _context6.abrupt("break", 26);

          case 23:
            _iteratorNormalCompletion2 = true;
            _context6.next = 14;
            break;

          case 26:
            _context6.next = 32;
            break;

          case 28:
            _context6.prev = 28;
            _context6.t0 = _context6["catch"](12);
            _didIteratorError2 = true;
            _iteratorError2 = _context6.t0;

          case 32:
            _context6.prev = 32;
            _context6.prev = 33;

            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }

          case 35:
            _context6.prev = 35;

            if (!_didIteratorError2) {
              _context6.next = 38;
              break;
            }

            throw _iteratorError2;

          case 38:
            return _context6.finish(35);

          case 39:
            return _context6.finish(32);

          case 40:
            _iteratorNormalCompletion = true;
            _context6.next = 5;
            break;

          case 43:
            _context6.next = 49;
            break;

          case 45:
            _context6.prev = 45;
            _context6.t1 = _context6["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context6.t1;

          case 49:
            _context6.prev = 49;
            _context6.prev = 50;

            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }

          case 52:
            _context6.prev = 52;

            if (!_didIteratorError) {
              _context6.next = 55;
              break;
            }

            throw _iteratorError;

          case 55:
            return _context6.finish(52);

          case 56:
            return _context6.finish(49);

          case 57:
            version = getMaxMajor(version);

            if (!version) {
              logger.warn("Could not infer babel version. Defaulting to babel 7. Please add either babel-core or @babel/core as a dependency.");
              version = 7;
            }

            return _context6.abrupt("return", version);

          case 60:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[3, 45, 49, 57], [12, 28, 32, 40], [33,, 35, 39], [50,, 52, 56]]);
  }));
  return _inferBabelVersion.apply(this, arguments);
}

function getPluginName(p) {
  return Array.isArray(p) ? p[0] : p;
}

function getMaxMajor(version) {
  try {
    var range = new semver.Range(version);
    var sorted = range.set.sort(function (a, b) {
      return a[0].semver.compare(b[0].semver);
    });
    return semver.major(sorted.pop()[0].semver.version);
  } catch (err) {
    return null;
  }
}

function installPlugins(_x11, _x12) {
  return _installPlugins.apply(this, arguments);
}

function _installPlugins() {
  _installPlugins = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee7(asset, babelrc) {
    var presets, plugins;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            presets = (babelrc.presets || []).map(function (p) {
              return resolveModule('preset', getPluginName(p), asset.name);
            });
            plugins = (babelrc.plugins || []).map(function (p) {
              return resolveModule('plugin', getPluginName(p), asset.name);
            });
            return _context7.abrupt("return", Promise.all([].concat(_toConsumableArray(presets), _toConsumableArray(plugins))));

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _installPlugins.apply(this, arguments);
}

function resolveModule(_x13, _x14, _x15) {
  return _resolveModule.apply(this, arguments);
} // Copied from https://github.com/babel/babel/blob/3a399d1eb907df520f2b85bf9ddbc6533e256f6d/packages/babel-core/src/config/files/plugins.js#L61


function _resolveModule() {
  _resolveModule = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee8(type, name, path) {
    var _ref, _ref2, pkg;

    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            name = standardizeName(type, name);
            _context8.next = 4;
            return localRequire.resolve(name, path);

          case 4:
            _ref = _context8.sent;
            _ref2 = (0, _slicedToArray2["default"])(_ref, 2);
            pkg = _ref2[1];
            return _context8.abrupt("return", pkg);

          case 10:
            _context8.prev = 10;
            _context8.t0 = _context8["catch"](0);
            return _context8.abrupt("return", null);

          case 13:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[0, 10]]);
  }));
  return _resolveModule.apply(this, arguments);
}

var EXACT_RE = /^module:/;
var BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
var BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
var BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
var BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
var OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
var OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
var OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;

function standardizeName(type, name) {
  // Let absolute and relative paths through.
  if (path.isAbsolute(name)) return name;
  var isPreset = type === 'preset';
  return name // foo -> babel-preset-foo
  .replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, "babel-".concat(type, "-")) // @babel/es2015 -> @babel/preset-es2015
  .replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, "$1".concat(type, "-")) // @foo/mypreset -> @foo/babel-preset-mypreset
  .replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, "$1babel-".concat(type, "-")) // @foo -> @foo/babel-preset
  .replace(OTHER_ORG_DEFAULT_RE, "$1/babel-".concat(type)) // module:mypreset -> mypreset
  .replace(EXACT_RE, '');
}