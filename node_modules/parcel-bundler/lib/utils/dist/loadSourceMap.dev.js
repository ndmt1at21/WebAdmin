"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var logger = require('@parcel/logger');

var path = require('path');

var fs = require('@parcel/fs');

var SOURCEMAP_RE = /(?:\/\*|\/\/)\s*[@#]\s*sourceMappingURL\s*=\s*([^\s*]+)(?:\s*\*\/)?/;
var DATA_URL_RE = /^data:[^;]+(?:;charset=[^;]+)?;base64,(.*)/;

function loadSourceMap(_x) {
  return _loadSourceMap.apply(this, arguments);
}

function _loadSourceMap() {
  _loadSourceMap = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(asset) {
    var match, sourceMap, url, dataURLMatch, json, filename, missingSources, contents;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // Get original sourcemap if there is any
            match = asset.contents.match(SOURCEMAP_RE);

            if (!match) {
              _context2.next = 30;
              break;
            }

            asset.contents = asset.contents.replace(SOURCEMAP_RE, '');
            url = match[1];
            dataURLMatch = url.match(DATA_URL_RE);
            _context2.prev = 5;

            if (!dataURLMatch) {
              _context2.next = 11;
              break;
            }

            filename = asset.name;
            json = Buffer.from(dataURLMatch[1], 'base64').toString();
            _context2.next = 16;
            break;

          case 11:
            filename = path.join(path.dirname(asset.name), url);
            _context2.next = 14;
            return fs.readFile(filename, 'utf8');

          case 14:
            json = _context2.sent;
            // Add as a dep so we watch the source map for changes.
            asset.addDependency(filename, {
              includedInParent: true
            });

          case 16:
            sourceMap = JSON.parse(json); // Attempt to read missing source contents

            if (!sourceMap.sourcesContent) {
              sourceMap.sourcesContent = [];
            }

            missingSources = sourceMap.sources.slice(sourceMap.sourcesContent.length);

            if (!missingSources.length) {
              _context2.next = 24;
              break;
            }

            _context2.next = 22;
            return Promise.all(missingSources.map(
            /*#__PURE__*/
            function () {
              var _ref = (0, _asyncToGenerator2["default"])(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee(source) {
                var sourceFile, result;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        sourceFile = path.join(path.dirname(filename), sourceMap.sourceRoot || '', source);
                        _context.next = 4;
                        return fs.readFile(sourceFile, 'utf8');

                      case 4:
                        result = _context.sent;
                        asset.addDependency(sourceFile, {
                          includedInParent: true
                        });
                        return _context.abrupt("return", result);

                      case 9:
                        _context.prev = 9;
                        _context.t0 = _context["catch"](0);
                        logger.warn("Could not load source file \"".concat(source, "\" in source map of \"").concat(asset.relativeName, "\"."));

                      case 12:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, null, [[0, 9]]);
              }));

              return function (_x2) {
                return _ref.apply(this, arguments);
              };
            }()));

          case 22:
            contents = _context2.sent;
            sourceMap.sourcesContent = sourceMap.sourcesContent.concat(contents);

          case 24:
            _context2.next = 30;
            break;

          case 26:
            _context2.prev = 26;
            _context2.t0 = _context2["catch"](5);
            logger.warn("Could not load existing sourcemap of \"".concat(asset.relativeName, "\"."));
            sourceMap = undefined;

          case 30:
            return _context2.abrupt("return", sourceMap);

          case 31:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[5, 26]]);
  }));
  return _loadSourceMap.apply(this, arguments);
}

module.exports = loadSourceMap;