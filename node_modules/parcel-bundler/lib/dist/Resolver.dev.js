"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var builtins = require('./builtins');

var nodeBuiltins = require('node-libs-browser');

var path = require('path');

var _require = require('./utils/glob'),
    isGlob = _require.isGlob;

var fs = require('@parcel/fs');

var micromatch = require('micromatch');

var getModuleParts = require('./utils/getModuleParts');

var EMPTY_SHIM = require.resolve('./builtins/_empty');
/**
 * This resolver implements a modified version of the node_modules resolution algorithm:
 * https://nodejs.org/api/modules.html#modules_all_together
 *
 * In addition to the standard algorithm, Parcel supports:
 *   - All file extensions supported by Parcel.
 *   - Glob file paths
 *   - Absolute paths (e.g. /foo) resolved relative to the project root.
 *   - Tilde paths (e.g. ~/foo) resolved relative to the nearest module root in node_modules.
 *   - The package.json module, jsnext:main, and browser field as replacements for package.main.
 *   - The package.json browser and alias fields as an alias map within a local module.
 *   - The package.json alias field in the root package for global aliases across all modules.
 */


var Resolver =
/*#__PURE__*/
function () {
  function Resolver() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Resolver);

    this.options = options;
    this.cache = new Map();
    this.packageCache = new Map();
    this.rootPackage = null;
  }

  _createClass(Resolver, [{
    key: "resolve",
    value: function resolve(input, parent) {
      var _this = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var filename, key, extensions, parentExt, module, resolved, dir, err;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                filename = input; // Check the cache first

                key = _this.getCacheKey(filename, parent);

                if (!_this.cache.has(key)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", _this.cache.get(key));

              case 4:
                if (!isGlob(filename)) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", {
                  path: path.resolve(path.dirname(parent), filename)
                });

              case 6:
                // Get file extensions to search
                extensions = Array.isArray(_this.options.extensions) ? _this.options.extensions.slice() : Object.keys(_this.options.extensions);

                if (parent) {
                  // parent's extension given high priority
                  parentExt = path.extname(parent);
                  extensions = [parentExt].concat(_toConsumableArray(extensions.filter(function (ext) {
                    return ext !== parentExt;
                  })));
                }

                extensions.unshift(''); // Resolve the module directory or local file path

                _context.next = 11;
                return _this.resolveModule(filename, parent);

              case 11:
                module = _context.sent;

                if (!module.moduleDir) {
                  _context.next = 18;
                  break;
                }

                _context.next = 15;
                return _this.loadNodeModules(module, extensions);

              case 15:
                resolved = _context.sent;
                _context.next = 22;
                break;

              case 18:
                if (!module.filePath) {
                  _context.next = 22;
                  break;
                }

                _context.next = 21;
                return _this.loadRelative(module.filePath, extensions);

              case 21:
                resolved = _context.sent;

              case 22:
                if (resolved) {
                  _context.next = 27;
                  break;
                }

                dir = parent ? path.dirname(parent) : process.cwd();
                err = new Error("Cannot find module '".concat(input, "' from '").concat(dir, "'"));
                err.code = 'MODULE_NOT_FOUND';
                throw err;

              case 27:
                _this.cache.set(key, resolved);

                return _context.abrupt("return", resolved);

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }, {
    key: "resolveModule",
    value: function resolveModule(filename, parent) {
      var _this2 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var dir, resolved, parts;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                dir = parent ? path.dirname(parent) : process.cwd(); // If this isn't the entrypoint, resolve the input file to an absolute path

                if (parent) {
                  filename = _this2.resolveFilename(filename, dir);
                } // Resolve aliases in the parent module for this file.


                _context2.next = 4;
                return _this2.loadAlias(filename, dir);

              case 4:
                filename = _context2.sent;

                if (!path.isAbsolute(filename)) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", {
                  filePath: filename
                });

              case 7:
                _context2.prev = 7;
                _context2.next = 10;
                return _this2.findNodeModulePath(filename, dir);

              case 10:
                resolved = _context2.sent;
                _context2.next = 15;
                break;

              case 13:
                _context2.prev = 13;
                _context2.t0 = _context2["catch"](7);

              case 15:
                // ignore
                // If we couldn't resolve the node_modules path, just return the module name info
                if (!resolved) {
                  parts = getModuleParts(filename);
                  resolved = {
                    moduleName: parts[0],
                    subPath: parts[1]
                  };
                }

                return _context2.abrupt("return", resolved);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[7, 13]]);
      }))();
    }
  }, {
    key: "getCacheKey",
    value: function getCacheKey(filename, parent) {
      return (parent ? path.dirname(parent) : '') + ':' + filename;
    }
  }, {
    key: "resolveFilename",
    value: function resolveFilename(filename, dir) {
      switch (filename[0]) {
        case '/':
          // Absolute path. Resolve relative to project root.
          return path.resolve(this.options.rootDir, filename.slice(1));

        case '~':
          // Tilde path. Resolve relative to nearest node_modules directory,
          // or the project root - whichever comes first.
          while (dir !== this.options.rootDir && path.basename(path.dirname(dir)) !== 'node_modules') {
            dir = path.dirname(dir);

            if (dir === path.dirname(dir)) {
              dir = this.options.rootDir;
              break;
            }
          }

          return path.join(dir, filename.slice(1));

        case '.':
          // Relative path.
          return path.resolve(dir, filename);

        default:
          // Module
          return filename;
      }
    }
  }, {
    key: "loadRelative",
    value: function loadRelative(filename, extensions) {
      var _this3 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var pkg;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this3.findPackage(path.dirname(filename));

              case 2:
                pkg = _context3.sent;
                _context3.next = 5;
                return _this3.loadAsFile(filename, extensions, pkg);

              case 5:
                _context3.t0 = _context3.sent;

                if (_context3.t0) {
                  _context3.next = 10;
                  break;
                }

                _context3.next = 9;
                return _this3.loadDirectory(filename, extensions, pkg);

              case 9:
                _context3.t0 = _context3.sent;

              case 10:
                return _context3.abrupt("return", _context3.t0);

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    }
  }, {
    key: "findNodeModulePath",
    value: function findNodeModulePath(filename, dir) {
      var _this4 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var parts, root, moduleDir, stats;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!builtins[filename]) {
                  _context4.next = 4;
                  break;
                }

                if (!(_this4.options.target === 'node' && filename in nodeBuiltins)) {
                  _context4.next = 3;
                  break;
                }

                throw new Error('Cannot resolve builtin module for node target');

              case 3:
                return _context4.abrupt("return", {
                  filePath: builtins[filename]
                });

              case 4:
                parts = getModuleParts(filename);
                root = path.parse(dir).root;

              case 6:
                if (!(dir !== root)) {
                  _context4.next = 22;
                  break;
                }

                // Skip node_modules directories
                if (path.basename(dir) === 'node_modules') {
                  dir = path.dirname(dir);
                }

                _context4.prev = 8;
                // First, check if the module directory exists. This prevents a lot of unnecessary checks later.
                moduleDir = path.join(dir, 'node_modules', parts[0]);
                _context4.next = 12;
                return fs.stat(moduleDir);

              case 12:
                stats = _context4.sent;

                if (!stats.isDirectory()) {
                  _context4.next = 15;
                  break;
                }

                return _context4.abrupt("return", {
                  moduleName: parts[0],
                  subPath: parts[1],
                  moduleDir: moduleDir,
                  filePath: path.join(dir, 'node_modules', filename)
                });

              case 15:
                _context4.next = 19;
                break;

              case 17:
                _context4.prev = 17;
                _context4.t0 = _context4["catch"](8);

              case 19:
                // ignore
                // Move up a directory
                dir = path.dirname(dir);
                _context4.next = 6;
                break;

              case 22:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[8, 17]]);
      }))();
    }
  }, {
    key: "loadNodeModules",
    value: function loadNodeModules(module, extensions) {
      var _this5 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var pkg, res;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;

                if (!module.subPath) {
                  _context5.next = 10;
                  break;
                }

                _context5.next = 4;
                return _this5.readPackage(module.moduleDir);

              case 4:
                pkg = _context5.sent;
                _context5.next = 7;
                return _this5.loadAsFile(module.filePath, extensions, pkg);

              case 7:
                res = _context5.sent;

                if (!res) {
                  _context5.next = 10;
                  break;
                }

                return _context5.abrupt("return", res);

              case 10:
                _context5.next = 12;
                return _this5.loadDirectory(module.filePath, extensions);

              case 12:
                return _context5.abrupt("return", _context5.sent);

              case 15:
                _context5.prev = 15;
                _context5.t0 = _context5["catch"](0);

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[0, 15]]);
      }))();
    }
  }, {
    key: "isFile",
    value: function isFile(file) {
      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var stat;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return fs.stat(file);

              case 3:
                stat = _context6.sent;
                return _context6.abrupt("return", stat.isFile() || stat.isFIFO());

              case 7:
                _context6.prev = 7;
                _context6.t0 = _context6["catch"](0);
                return _context6.abrupt("return", false);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[0, 7]]);
      }))();
    }
  }, {
    key: "loadDirectory",
    value: function loadDirectory(dir, extensions, pkg) {
      var _this6 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        var entries, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, file, res;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                _context7.next = 3;
                return _this6.readPackage(dir);

              case 3:
                pkg = _context7.sent;
                // Get a list of possible package entry points.
                entries = _this6.getPackageEntries(pkg);
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context7.prev = 8;
                _iterator = entries[Symbol.iterator]();

              case 10:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context7.next = 25;
                  break;
                }

                file = _step.value; // First try loading package.main as a file, then try as a directory.

                _context7.next = 14;
                return _this6.loadAsFile(file, extensions, pkg);

              case 14:
                _context7.t0 = _context7.sent;

                if (_context7.t0) {
                  _context7.next = 19;
                  break;
                }

                _context7.next = 18;
                return _this6.loadDirectory(file, extensions, pkg);

              case 18:
                _context7.t0 = _context7.sent;

              case 19:
                res = _context7.t0;

                if (!res) {
                  _context7.next = 22;
                  break;
                }

                return _context7.abrupt("return", res);

              case 22:
                _iteratorNormalCompletion = true;
                _context7.next = 10;
                break;

              case 25:
                _context7.next = 31;
                break;

              case 27:
                _context7.prev = 27;
                _context7.t1 = _context7["catch"](8);
                _didIteratorError = true;
                _iteratorError = _context7.t1;

              case 31:
                _context7.prev = 31;
                _context7.prev = 32;

                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }

              case 34:
                _context7.prev = 34;

                if (!_didIteratorError) {
                  _context7.next = 37;
                  break;
                }

                throw _iteratorError;

              case 37:
                return _context7.finish(34);

              case 38:
                return _context7.finish(31);

              case 39:
                _context7.next = 43;
                break;

              case 41:
                _context7.prev = 41;
                _context7.t2 = _context7["catch"](0);

              case 43:
                return _context7.abrupt("return", _this6.loadAsFile(path.join(dir, 'index'), extensions, pkg));

              case 44:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[0, 41], [8, 27, 31, 39], [32,, 34, 38]]);
      }))();
    }
  }, {
    key: "readPackage",
    value: function readPackage(dir) {
      var _this7 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8() {
        var file, json, pkg, realpath;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                file = path.join(dir, 'package.json');

                if (!_this7.packageCache.has(file)) {
                  _context8.next = 3;
                  break;
                }

                return _context8.abrupt("return", _this7.packageCache.get(file));

              case 3:
                _context8.next = 5;
                return fs.readFile(file, 'utf8');

              case 5:
                json = _context8.sent;
                pkg = JSON.parse(json);
                pkg.pkgfile = file;
                pkg.pkgdir = dir; // If the package has a `source` field, check if it is behind a symlink.
                // If so, we treat the module as source code rather than a pre-compiled module.

                if (!pkg.source) {
                  _context8.next = 14;
                  break;
                }

                _context8.next = 12;
                return fs.realpath(file);

              case 12:
                realpath = _context8.sent;

                if (realpath === file) {
                  delete pkg.source;
                }

              case 14:
                _this7.packageCache.set(file, pkg);

                return _context8.abrupt("return", pkg);

              case 16:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }))();
    }
  }, {
    key: "getBrowserField",
    value: function getBrowserField(pkg) {
      var target = this.options.target || 'browser';
      return target === 'browser' ? pkg.browser : null;
    }
  }, {
    key: "getPackageEntries",
    value: function getPackageEntries(pkg) {
      var browser = this.getBrowserField(pkg);

      if (browser && _typeof(browser) === 'object' && browser[pkg.name]) {
        browser = browser[pkg.name];
      } // libraries like d3.js specifies node.js specific files in the "main" which breaks the build
      // we use the "browser" or "module" field to get the full dependency tree if available.
      // If this is a linked module with a `source` field, use that as the entry point.


      return [pkg.source, browser, pkg.module, pkg.main].filter(function (entry) {
        return typeof entry === 'string';
      }).map(function (main) {
        // Default to index file if no main field find
        if (!main || main === '.' || main === './') {
          main = 'index';
        }

        return path.resolve(pkg.pkgdir, main);
      });
    }
  }, {
    key: "loadAsFile",
    value: function loadAsFile(file, extensions, pkg) {
      var _this8 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9() {
        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, f;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                // Try all supported extensions
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context9.prev = 3;
                _iterator2 = _this8.expandFile(file, extensions, pkg)[Symbol.iterator]();

              case 5:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context9.next = 14;
                  break;
                }

                f = _step2.value;
                _context9.next = 9;
                return _this8.isFile(f);

              case 9:
                if (!_context9.sent) {
                  _context9.next = 11;
                  break;
                }

                return _context9.abrupt("return", {
                  path: f,
                  pkg: pkg
                });

              case 11:
                _iteratorNormalCompletion2 = true;
                _context9.next = 5;
                break;

              case 14:
                _context9.next = 20;
                break;

              case 16:
                _context9.prev = 16;
                _context9.t0 = _context9["catch"](3);
                _didIteratorError2 = true;
                _iteratorError2 = _context9.t0;

              case 20:
                _context9.prev = 20;
                _context9.prev = 21;

                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }

              case 23:
                _context9.prev = 23;

                if (!_didIteratorError2) {
                  _context9.next = 26;
                  break;
                }

                throw _iteratorError2;

              case 26:
                return _context9.finish(23);

              case 27:
                return _context9.finish(20);

              case 28:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, null, [[3, 16, 20, 28], [21,, 23, 27]]);
      }))();
    }
  }, {
    key: "expandFile",
    value: function expandFile(file, extensions, pkg) {
      var expandAliases = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      // Expand extensions and aliases
      var res = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = extensions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var ext = _step3.value;
          var f = file + ext;

          if (expandAliases) {
            var alias = this.resolveAliases(file + ext, pkg);

            if (alias !== f) {
              res = res.concat(this.expandFile(alias, extensions, pkg, false));
            }
          }

          res.push(f);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return res;
    }
  }, {
    key: "resolveAliases",
    value: function resolveAliases(filename, pkg) {
      // First resolve local package aliases, then project global ones.
      return this.resolvePackageAliases(this.resolvePackageAliases(filename, pkg), this.rootPackage);
    }
  }, {
    key: "resolvePackageAliases",
    value: function resolvePackageAliases(filename, pkg) {
      if (!pkg) {
        return filename;
      } // Resolve aliases in the package.source, package.alias, and package.browser fields.


      return this.getAlias(filename, pkg.pkgdir, pkg.source) || this.getAlias(filename, pkg.pkgdir, pkg.alias) || this.getAlias(filename, pkg.pkgdir, this.getBrowserField(pkg)) || filename;
    }
  }, {
    key: "getAlias",
    value: function getAlias(filename, dir, aliases) {
      if (!filename || !aliases || _typeof(aliases) !== 'object') {
        return null;
      }

      var alias; // If filename is an absolute path, get one relative to the package.json directory.

      if (path.isAbsolute(filename)) {
        filename = path.relative(dir, filename);

        if (filename[0] !== '.') {
          filename = './' + filename;
        }

        alias = this.lookupAlias(aliases, filename, dir);
      } else {
        // It is a node_module. First try the entire filename as a key.
        alias = this.lookupAlias(aliases, filename, dir);

        if (alias == null) {
          // If it didn't match, try only the module name.
          var parts = getModuleParts(filename);
          alias = this.lookupAlias(aliases, parts[0], dir);

          if (typeof alias === 'string') {
            // Append the filename back onto the aliased module.
            alias = path.join.apply(path, [alias].concat(_toConsumableArray(parts.slice(1))));
          }
        }
      } // If the alias is set to `false`, return an empty file.


      if (alias === false) {
        return EMPTY_SHIM;
      }

      return alias;
    }
  }, {
    key: "lookupAlias",
    value: function lookupAlias(aliases, filename, dir) {
      // First, try looking up the exact filename
      var alias = aliases[filename];

      if (alias == null) {
        // Otherwise, try replacing glob keys
        for (var key in aliases) {
          if (isGlob(key)) {
            var re = micromatch.makeRe(key, {
              capture: true
            });

            if (re.test(filename)) {
              alias = filename.replace(re, aliases[key]);
              break;
            }
          }
        } // Or try a lookup replacing backslash characters with forward slash


        if (alias == null && ~filename.indexOf('\\')) {
          alias = aliases[filename.replace(/\\/g, '/')];
        }
      }

      if (typeof alias === 'string') {
        return this.resolveFilename(alias, dir);
      }

      return alias;
    }
  }, {
    key: "findPackage",
    value: function findPackage(dir) {
      var _this9 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10() {
        var root;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                // Find the nearest package.json file within the current node_modules folder
                root = path.parse(dir).root;

              case 1:
                if (!(dir !== root && path.basename(dir) !== 'node_modules')) {
                  _context10.next = 13;
                  break;
                }

                _context10.prev = 2;
                _context10.next = 5;
                return _this9.readPackage(dir);

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 8:
                _context10.prev = 8;
                _context10.t0 = _context10["catch"](2);

              case 10:
                dir = path.dirname(dir);
                _context10.next = 1;
                break;

              case 13:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, null, [[2, 8]]);
      }))();
    }
  }, {
    key: "loadAlias",
    value: function loadAlias(filename, dir) {
      var _this10 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11() {
        var pkg;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (_this10.rootPackage) {
                  _context11.next = 4;
                  break;
                }

                _context11.next = 3;
                return _this10.findPackage(_this10.options.rootDir);

              case 3:
                _this10.rootPackage = _context11.sent;

              case 4:
                _context11.next = 6;
                return _this10.findPackage(dir);

              case 6:
                pkg = _context11.sent;
                return _context11.abrupt("return", _this10.resolveAliases(filename, pkg));

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }))();
    }
  }]);

  return Resolver;
}();

module.exports = Resolver;