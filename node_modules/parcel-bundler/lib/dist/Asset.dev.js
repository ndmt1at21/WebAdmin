"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var URL = require('url');

var path = require('path');

var clone = require('clone');

var fs = require('@parcel/fs');

var md5 = require('./utils/md5');

var isURL = require('./utils/is-url');

var config = require('./utils/config');

var syncPromise = require('./utils/syncPromise');

var logger = require('@parcel/logger');

var Resolver = require('./Resolver');

var objectHash = require('./utils/objectHash');

var t = require('babel-types');
/**
 * An Asset represents a file in the dependency tree. Assets can have multiple
 * parents that depend on it, and can be added to multiple output bundles.
 * The base Asset class doesn't do much by itself, but sets up an interface
 * for subclasses to implement.
 */


var Asset =
/*#__PURE__*/
function () {
  function Asset(name, options) {
    _classCallCheck(this, Asset);

    this.id = null;
    this.name = name;
    this.basename = path.basename(this.name);
    this.relativeName = path.relative(options.rootDir, this.name).replace(/\\/g, '/');
    this.options = options;
    this.encoding = 'utf8';
    this.type = path.extname(this.name).slice(1);
    this.hmrPageReload = false;
    this.processed = false;
    this.contents = options.rendition ? options.rendition.value : null;
    this.ast = null;
    this.generated = null;
    this.hash = null;
    this.sourceMaps = null;
    this.parentDeps = new Set();
    this.dependencies = new Map();
    this.depAssets = new Map();
    this.parentBundle = null;
    this.bundles = new Set();
    this.cacheData = {};
    this.startTime = 0;
    this.endTime = 0;
    this.buildTime = 0;
    this.bundledSize = 0;
    this.resolver = new Resolver(options);
  }

  _createClass(Asset, [{
    key: "shouldInvalidate",
    value: function shouldInvalidate() {
      return false;
    }
  }, {
    key: "loadIfNeeded",
    value: function loadIfNeeded() {
      var _this = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(_this.contents == null)) {
                  _context.next = 4;
                  break;
                }

                _context.next = 3;
                return _this.load();

              case 3:
                _this.contents = _context.sent;

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }, {
    key: "parseIfNeeded",
    value: function parseIfNeeded() {
      var _this2 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this2.loadIfNeeded();

              case 2:
                if (_this2.ast) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 5;
                return _this2.parse(_this2.contents);

              case 5:
                _this2.ast = _context2.sent;

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    }
  }, {
    key: "getDependencies",
    value: function getDependencies() {
      var _this3 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(_this3.options.rendition && _this3.options.rendition.hasDependencies === false)) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                _context3.next = 4;
                return _this3.loadIfNeeded();

              case 4:
                if (!(_this3.contents && _this3.mightHaveDependencies())) {
                  _context3.next = 9;
                  break;
                }

                _context3.next = 7;
                return _this3.parseIfNeeded();

              case 7:
                _context3.next = 9;
                return _this3.collectDependencies();

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    }
  }, {
    key: "addDependency",
    value: function addDependency(name, opts) {
      this.dependencies.set(name, Object.assign({
        name: name
      }, opts));
    }
  }, {
    key: "resolveDependency",
    value: function resolveDependency(url) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.name;
      var parsed = URL.parse(url);
      var depName;
      var resolved;
      var dir = path.dirname(from);
      var filename = decodeURIComponent(parsed.pathname);

      if (filename[0] === '~' || filename[0] === '/') {
        if (dir === '.') {
          dir = this.options.rootDir;
        }

        depName = resolved = this.resolver.resolveFilename(filename, dir);
      } else {
        resolved = path.resolve(dir, filename);
        depName = './' + path.relative(path.dirname(this.name), resolved);
      }

      return {
        depName: depName,
        resolved: resolved
      };
    }
  }, {
    key: "addURLDependency",
    value: function addURLDependency(url) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.name;
      var opts = arguments.length > 2 ? arguments[2] : undefined;

      if (!url || isURL(url)) {
        return url;
      }

      if (_typeof(from) === 'object') {
        opts = from;
        from = this.name;
      }

      var _this$resolveDependen = this.resolveDependency(url, from),
          depName = _this$resolveDependen.depName,
          resolved = _this$resolveDependen.resolved;

      this.addDependency(depName, Object.assign({
        dynamic: true,
        resolved: resolved
      }, opts));
      var parsed = URL.parse(url);
      parsed.pathname = this.options.parser.getAsset(resolved, this.options).generateBundleName();
      return URL.format(parsed);
    }
  }, {
    key: "getPackage",
    value: function getPackage() {
      var _this4 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (_this4._package) {
                  _context4.next = 4;
                  break;
                }

                _context4.next = 3;
                return _this4.resolver.findPackage(path.dirname(_this4.name));

              case 3:
                _this4._package = _context4.sent;

              case 4:
                return _context4.abrupt("return", _this4._package);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    }
  }, {
    key: "getConfig",
    value: function getConfig(filenames) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _this5 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var pkg, conf;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!opts.packageKey) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 3;
                return _this5.getPackage();

              case 3:
                pkg = _context5.sent;

                if (!(pkg && pkg[opts.packageKey])) {
                  _context5.next = 6;
                  break;
                }

                return _context5.abrupt("return", clone(pkg[opts.packageKey]));

              case 6:
                _context5.next = 8;
                return config.resolve(opts.path || _this5.name, filenames);

              case 8:
                conf = _context5.sent;

                if (!conf) {
                  _context5.next = 14;
                  break;
                }

                // Add as a dependency so it is added to the watcher and invalidates
                // this asset when the config changes.
                _this5.addDependency(conf, {
                  includedInParent: true
                });

                if (!(opts.load === false)) {
                  _context5.next = 13;
                  break;
                }

                return _context5.abrupt("return", conf);

              case 13:
                return _context5.abrupt("return", config.load(opts.path || _this5.name, filenames));

              case 14:
                return _context5.abrupt("return", null);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    }
  }, {
    key: "mightHaveDependencies",
    value: function mightHaveDependencies() {
      return true;
    }
  }, {
    key: "load",
    value: function load() {
      var _this6 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", fs.readFile(_this6.name, _this6.encoding));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }))();
    }
  }, {
    key: "parse",
    value: function parse() {// do nothing by default
    }
  }, {
    key: "collectDependencies",
    value: function collectDependencies() {// do nothing by default
    }
  }, {
    key: "pretransform",
    value: function pretransform() {
      // do nothing by default
      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }))();
    }
  }, {
    key: "transform",
    value: function transform() {
      // do nothing by default
      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }))();
    }
  }, {
    key: "generate",
    value: function generate() {
      var _this7 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", _defineProperty({}, _this7.type, _this7.contents));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }))();
    }
  }, {
    key: "process",
    value: function process() {
      var _this8 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10() {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                // Generate the id for this asset, unless it has already been set.
                // We do this here rather than in the constructor to avoid unnecessary work in the main process.
                // In development, the id is just the relative path to the file, for easy debugging and performance.
                // In production, we use a short hash of the relative path.
                if (!_this8.id) {
                  _this8.id = _this8.options.production || _this8.options.scopeHoist ? t.toIdentifier(md5(_this8.relativeName, 'base64')).slice(0, 4) : _this8.relativeName;
                }

                if (_this8.generated) {
                  _context10.next = 13;
                  break;
                }

                _context10.next = 4;
                return _this8.loadIfNeeded();

              case 4:
                _context10.next = 6;
                return _this8.pretransform();

              case 6:
                _context10.next = 8;
                return _this8.getDependencies();

              case 8:
                _context10.next = 10;
                return _this8.transform();

              case 10:
                _context10.next = 12;
                return _this8.generate();

              case 12:
                _this8.generated = _context10.sent;

              case 13:
                return _context10.abrupt("return", _this8.generated);

              case 14:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }))();
    }
  }, {
    key: "postProcess",
    value: function postProcess(generated) {
      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11() {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", generated);

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }))();
    }
  }, {
    key: "generateHash",
    value: function generateHash() {
      return objectHash(this.generated);
    }
  }, {
    key: "invalidate",
    value: function invalidate() {
      this.processed = false;
      this.contents = null;
      this.ast = null;
      this.generated = null;
      this.hash = null;
      this.dependencies.clear();
      this.depAssets.clear();
    }
  }, {
    key: "invalidateBundle",
    value: function invalidateBundle() {
      this.parentBundle = null;
      this.bundles.clear();
      this.parentDeps.clear();
    }
  }, {
    key: "generateBundleName",
    value: function generateBundleName() {
      // Generate a unique name. This will be replaced with a nicer
      // name later as part of content hashing.
      return md5(this.relativeName) + '.' + this.type;
    }
  }, {
    key: "replaceBundleNames",
    value: function replaceBundleNames(bundleNameMap) {
      var copied = false;

      for (var key in this.generated) {
        var value = this.generated[key];

        if (typeof value === 'string') {
          // Replace temporary bundle names in the output with the final content-hashed names.
          var newValue = value;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = bundleNameMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
                  name = _step$value[0],
                  map = _step$value[1];

              newValue = newValue.split(name).join(map);
            } // Copy `this.generated` on write so we don't end up writing the final names to the cache.

          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (newValue !== value && !copied) {
            this.generated = Object.assign({}, this.generated);
            copied = true;
          }

          this.generated[key] = newValue;
        }
      }
    }
  }, {
    key: "generateErrorMessage",
    value: function generateErrorMessage(err) {
      return err;
    }
  }, {
    key: "package",
    get: function get() {
      logger.warn('`asset.package` is deprecated. Please use `await asset.getPackage()` instead.');
      return syncPromise(this.getPackage());
    }
  }]);

  return Asset;
}();

module.exports = Asset;