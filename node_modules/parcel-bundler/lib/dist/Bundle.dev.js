"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var Path = require('path');

var crypto = require('crypto');
/**
 * A Bundle represents an output file, containing multiple assets. Bundles can have
 * child bundles, which are bundles that are loaded dynamically from this bundle.
 * Child bundles are also produced when importing an asset of a different type from
 * the bundle, e.g. importing a CSS file from JS.
 */


var Bundle =
/*#__PURE__*/
function () {
  function Bundle(type, name, parent) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Bundle);

    this.type = type;
    this.name = name;
    this.parentBundle = parent;
    this.entryAsset = null;
    this.assets = new Set();
    this.childBundles = new Set();
    this.siblingBundles = new Set();
    this.siblingBundlesMap = new Map();
    this.offsets = new Map();
    this.totalSize = 0;
    this.bundleTime = 0;
    this.isolated = options.isolated;
  }

  _createClass(Bundle, [{
    key: "addAsset",
    value: function addAsset(asset) {
      asset.bundles.add(this);
      this.assets.add(asset);

      if (this.type != 'map' && this.type == asset.type && asset.options.sourceMaps && asset.sourceMaps) {
        this.getSiblingBundle('map').addAsset(asset);
      }
    }
  }, {
    key: "removeAsset",
    value: function removeAsset(asset) {
      asset.bundles["delete"](this);
      this.assets["delete"](asset);
    }
  }, {
    key: "addOffset",
    value: function addOffset(asset, line) {
      var column = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.offsets.set(asset, [line, column]);
    }
  }, {
    key: "getOffset",
    value: function getOffset(asset) {
      return this.offsets.get(asset) || [0, 0];
    }
  }, {
    key: "getSiblingBundle",
    value: function getSiblingBundle(type) {
      if (!type || type === this.type) {
        return this;
      }

      if (!this.siblingBundlesMap.has(type)) {
        var bundle = new Bundle(type, Path.join(Path.dirname(this.name), // keep the original extension for source map files, so we have
        // .js.map instead of just .map
        type === 'map' ? Path.basename(this.name) + '.' + type : Path.basename(this.name, Path.extname(this.name)) + '.' + type), this);
        this.childBundles.add(bundle);
        this.siblingBundles.add(bundle);
        this.siblingBundlesMap.set(type, bundle);
      }

      return this.siblingBundlesMap.get(type);
    }
  }, {
    key: "createChildBundle",
    value: function createChildBundle(entryAsset) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var bundle = Bundle.createWithAsset(entryAsset, this, options);
      this.childBundles.add(bundle);
      return bundle;
    }
  }, {
    key: "createSiblingBundle",
    value: function createSiblingBundle(entryAsset) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var bundle = this.createChildBundle(entryAsset, options);
      this.siblingBundles.add(bundle);
      return bundle;
    }
  }, {
    key: "getBundleNameMap",
    value: function getBundleNameMap(contentHash) {
      var hashes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();

      if (this.name) {
        var hashedName = this.getHashedBundleName(contentHash);
        hashes.set(Path.basename(this.name), hashedName);
        this.name = Path.join(Path.dirname(this.name), hashedName);
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.childBundles.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          child.getBundleNameMap(contentHash, hashes);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return hashes;
    }
  }, {
    key: "getHashedBundleName",
    value: function getHashedBundleName(contentHash) {
      // If content hashing is enabled, generate a hash from all assets in the bundle.
      // Otherwise, use a hash of the filename so it remains consistent across builds.
      if (this.type == 'map') {
        return this.parentBundle.getHashedBundleName(contentHash) + '.map';
      }

      var basename = Path.basename(this.name);
      var ext = Path.extname(basename);
      var hash = (contentHash ? this.getHash() : Path.basename(this.name, ext)).slice(-8);
      var entryAsset = this;

      while (!entryAsset.entryAsset && entryAsset.parentBundle) {
        entryAsset = entryAsset.parentBundle;
      }

      entryAsset = entryAsset.entryAsset;
      var name = Path.basename(entryAsset.name, Path.extname(entryAsset.name));
      var isMainEntry = entryAsset.options.entryFiles[0] === entryAsset.name;
      var isEntry = entryAsset.options.entryFiles.includes(entryAsset.name) || Array.from(entryAsset.parentDeps).some(function (dep) {
        return dep.entry;
      }); // If this is the main entry file, use the output file option as the name if provided.

      if (isMainEntry && entryAsset.options.outFile) {
        var extname = Path.extname(entryAsset.options.outFile);

        if (extname) {
          ext = this.entryAsset ? extname : ext;
          name = Path.basename(entryAsset.options.outFile, extname);
        } else {
          name = entryAsset.options.outFile;
        }
      } // If this is an entry asset, don't hash. Return a relative path
      // from the main file so we keep the original file paths.


      if (isEntry) {
        return Path.join(Path.relative(entryAsset.options.rootDir, Path.dirname(entryAsset.name)), name + ext).replace(/\.\.(\/|\\)/g, '__$1');
      } // If this is an index file, use the parent directory name instead
      // which is probably more descriptive.


      if (name === 'index') {
        name = Path.basename(Path.dirname(entryAsset.name));
      } // Add the content hash and extension.


      return name + '.' + hash + ext;
    }
  }, {
    key: "package",
    value: function _package(bundler, oldHashes) {
      var newHashes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();

      var _this = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var promises, mappings, hash, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, bundle, _i, _mappings, _bundle;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                promises = [];
                mappings = [];

                if (!_this.isEmpty) {
                  hash = _this.getHash();
                  newHashes.set(_this.name, hash);

                  if (!oldHashes || oldHashes.get(_this.name) !== hash) {
                    promises.push(_this._package(bundler));
                  }
                }

                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context.prev = 6;

                for (_iterator2 = _this.childBundles.values()[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  bundle = _step2.value;

                  if (bundle.type === 'map') {
                    mappings.push(bundle);
                  } else {
                    promises.push(bundle["package"](bundler, oldHashes, newHashes));
                  }
                }

                _context.next = 14;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](6);
                _didIteratorError2 = true;
                _iteratorError2 = _context.t0;

              case 14:
                _context.prev = 14;
                _context.prev = 15;

                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }

              case 17:
                _context.prev = 17;

                if (!_didIteratorError2) {
                  _context.next = 20;
                  break;
                }

                throw _iteratorError2;

              case 20:
                return _context.finish(17);

              case 21:
                return _context.finish(14);

              case 22:
                _context.next = 24;
                return Promise.all(promises);

              case 24:
                _i = 0, _mappings = mappings;

              case 25:
                if (!(_i < _mappings.length)) {
                  _context.next = 32;
                  break;
                }

                _bundle = _mappings[_i];
                _context.next = 29;
                return _bundle["package"](bundler, oldHashes, newHashes);

              case 29:
                _i++;
                _context.next = 25;
                break;

              case 32:
                return _context.abrupt("return", newHashes);

              case 33:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[6, 10, 14, 22], [15,, 17, 21]]);
      }))();
    }
  }, {
    key: "_package",
    value: function _package(bundler) {
      var _this2 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var Packager, packager, startTime, included, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, asset, assetArray, assetStartTime, assetEndTime, packagingTime;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                Packager = bundler.packagers.get(_this2.type);
                packager = new Packager(_this2, bundler);
                startTime = Date.now();
                _context2.next = 5;
                return packager.setup();

              case 5:
                _context2.next = 7;
                return packager.start();

              case 7:
                included = new Set();
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context2.prev = 11;
                _iterator3 = _this2.assets[Symbol.iterator]();

              case 13:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                  _context2.next = 20;
                  break;
                }

                asset = _step3.value;
                _context2.next = 17;
                return _this2._addDeps(asset, packager, included);

              case 17:
                _iteratorNormalCompletion3 = true;
                _context2.next = 13;
                break;

              case 20:
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](11);
                _didIteratorError3 = true;
                _iteratorError3 = _context2.t0;

              case 26:
                _context2.prev = 26;
                _context2.prev = 27;

                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }

              case 29:
                _context2.prev = 29;

                if (!_didIteratorError3) {
                  _context2.next = 32;
                  break;
                }

                throw _iteratorError3;

              case 32:
                return _context2.finish(29);

              case 33:
                return _context2.finish(26);

              case 34:
                _context2.next = 36;
                return packager.end();

              case 36:
                _this2.totalSize = packager.getSize();
                assetArray = Array.from(_this2.assets);
                assetStartTime = _this2.type === 'map' ? 0 : assetArray.sort(function (a, b) {
                  return a.startTime - b.startTime;
                })[0].startTime;
                assetEndTime = _this2.type === 'map' ? 0 : assetArray.sort(function (a, b) {
                  return b.endTime - a.endTime;
                })[0].endTime;
                packagingTime = Date.now() - startTime;
                _this2.bundleTime = assetEndTime - assetStartTime + packagingTime;

              case 42:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[11, 22, 26, 34], [27,, 29, 33]]);
      }))();
    }
  }, {
    key: "_addDeps",
    value: function _addDeps(asset, packager, included) {
      var _this3 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, depAsset, assetSize;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(!_this3.assets.has(asset) || included.has(asset))) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                included.add(asset);
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                _context3.prev = 6;
                _iterator4 = asset.depAssets.values()[Symbol.iterator]();

              case 8:
                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                  _context3.next = 15;
                  break;
                }

                depAsset = _step4.value;
                _context3.next = 12;
                return _this3._addDeps(depAsset, packager, included);

              case 12:
                _iteratorNormalCompletion4 = true;
                _context3.next = 8;
                break;

              case 15:
                _context3.next = 21;
                break;

              case 17:
                _context3.prev = 17;
                _context3.t0 = _context3["catch"](6);
                _didIteratorError4 = true;
                _iteratorError4 = _context3.t0;

              case 21:
                _context3.prev = 21;
                _context3.prev = 22;

                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }

              case 24:
                _context3.prev = 24;

                if (!_didIteratorError4) {
                  _context3.next = 27;
                  break;
                }

                throw _iteratorError4;

              case 27:
                return _context3.finish(24);

              case 28:
                return _context3.finish(21);

              case 29:
                _context3.next = 31;
                return packager.addAsset(asset);

              case 31:
                assetSize = packager.getSize() - _this3.totalSize;

                if (assetSize > 0) {
                  _this3.addAssetSize(asset, assetSize);
                }

              case 33:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[6, 17, 21, 29], [22,, 24, 28]]);
      }))();
    }
  }, {
    key: "addAssetSize",
    value: function addAssetSize(asset, size) {
      asset.bundledSize = size;
      this.totalSize += size;
    }
  }, {
    key: "getParents",
    value: function getParents() {
      var parents = [];
      var bundle = this;

      while (bundle) {
        parents.push(bundle);
        bundle = bundle.parentBundle;
      }

      return parents;
    }
  }, {
    key: "findCommonAncestor",
    value: function findCommonAncestor(bundle) {
      // Get a list of parent bundles going up to the root
      var ourParents = this.getParents();
      var theirParents = bundle.getParents(); // Start from the root bundle, and find the first bundle that's different

      var a = ourParents.pop();
      var b = theirParents.pop();
      var last;

      while (a === b && ourParents.length > 0 && theirParents.length > 0) {
        last = a;
        a = ourParents.pop();
        b = theirParents.pop();
      }

      if (a === b) {
        // One bundle descended from the other
        return a;
      }

      return last;
    }
  }, {
    key: "getHash",
    value: function getHash() {
      var hash = crypto.createHash('md5');
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.assets[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var asset = _step5.value;
          hash.update(asset.hash);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return hash.digest('hex');
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this.assets.size === 0;
    }
  }], [{
    key: "createWithAsset",
    value: function createWithAsset(asset, parentBundle, options) {
      var bundle = new Bundle(asset.type, Path.join(asset.options.outDir, asset.generateBundleName()), parentBundle, options);
      bundle.entryAsset = asset;
      bundle.addAsset(asset);
      return bundle;
    }
  }]);

  return Bundle;
}();

module.exports = Bundle;