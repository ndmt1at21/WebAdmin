"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('source-map'),
    SourceMapConsumer = _require.SourceMapConsumer,
    SourceMapGenerator = _require.SourceMapGenerator;

var lineCounter = require('./utils/lineCounter');

var SourceMap =
/*#__PURE__*/
function () {
  function SourceMap(mappings, sources) {
    _classCallCheck(this, SourceMap);

    this.mappings = this.purifyMappings(mappings);
    this.sources = sources || {};
    this.lineCount = null;
  }

  _createClass(SourceMap, [{
    key: "purifyMappings",
    value: function purifyMappings(mappings) {
      if (Array.isArray(mappings)) {
        return mappings.filter(function (mapping) {
          return mapping && _typeof(mapping.original) === 'object' && (mapping.original === null || typeof mapping.original.line === 'number' && mapping.original.line > 0 && typeof mapping.original.column === 'number' && mapping.source) && mapping.generated && typeof mapping.generated.line === 'number' && mapping.generated.line > 0 && typeof mapping.generated.column === 'number';
        });
      }

      return [];
    }
  }, {
    key: "getConsumer",
    value: function getConsumer(map) {
      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(map instanceof SourceMapConsumer)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", map);

              case 2:
                map = typeof map === 'string' ? JSON.parse(map) : map;
                if (map.sourceRoot) delete map.sourceRoot;
                return _context.abrupt("return", new SourceMapConsumer(map));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }, {
    key: "addMap",
    value: function addMap(map) {
      var lineOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var columnOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var _this = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var consumer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(typeof map === 'string' || _typeof(map) === 'object' && map.version)) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 3;
                return _this.getConsumer(map);

              case 3:
                consumer = _context2.sent;

                if (consumer) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", _this);

              case 6:
                consumer.eachMapping(function (mapping) {
                  _this.addConsumerMapping(mapping, lineOffset, columnOffset);

                  if (!_this.sources[mapping.source]) {
                    _this.sources[mapping.source] = consumer.sourceContentFor(mapping.source, true);
                  }
                });

                if (consumer.destroy) {
                  // Only needs to happen in source-map 0.7
                  consumer.destroy();
                }

                _context2.next = 11;
                break;

              case 10:
                if (map.mappings && map.sources) {
                  if (!map.eachMapping) {
                    map = new SourceMap(map.mappings, map.sources);
                  }

                  if (lineOffset === 0 && columnOffset === 0) {
                    _this.mappings = _this.mappings.concat(map.mappings);
                  } else {
                    map.eachMapping(function (mapping) {
                      _this.addMapping(mapping, lineOffset, columnOffset);
                    });
                  }

                  Object.keys(map.sources).forEach(function (sourceName) {
                    if (!_this.sources[sourceName]) {
                      _this.sources[sourceName] = map.sources[sourceName];
                    }
                  });
                }

              case 11:
                return _context2.abrupt("return", _this);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    }
  }, {
    key: "addMapping",
    value: function addMapping(mapping) {
      var lineOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var columnOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.mappings.push({
        source: mapping.source,
        name: mapping.name,
        original: mapping.original,
        generated: {
          line: mapping.generated.line + lineOffset,
          column: mapping.generated.column + columnOffset
        }
      });
    }
  }, {
    key: "addConsumerMapping",
    value: function addConsumerMapping(mapping) {
      var lineOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var columnOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var original = null;

      if (typeof mapping.originalLine === 'number' && mapping.originalLine > 0 && typeof mapping.originalColumn === 'number') {
        original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
      }

      this.mappings.push({
        source: original ? mapping.source : null,
        name: mapping.name,
        original: original,
        generated: {
          line: mapping.generatedLine + lineOffset,
          column: mapping.generatedColumn + columnOffset
        }
      });
    }
  }, {
    key: "eachMapping",
    value: function eachMapping(callback) {
      this.mappings.forEach(callback);
    }
  }, {
    key: "generateEmptyMap",
    value: function generateEmptyMap(sourceName, sourceContent) {
      this.sources[sourceName] = sourceContent;
      this.lineCount = lineCounter(sourceContent);

      for (var line = 1; line < this.lineCount + 1; line++) {
        this.addMapping({
          source: sourceName,
          original: {
            line: line,
            column: 0
          },
          generated: {
            line: line,
            column: 0
          }
        });
      }

      return this;
    }
  }, {
    key: "extendSourceMap",
    value: function extendSourceMap(original, extension) {
      var _this2 = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (extension instanceof SourceMap) {
                  _context3.next = 4;
                  break;
                }

                _context3.next = 3;
                return new SourceMap().addMap(extension);

              case 3:
                extension = _context3.sent;

              case 4:
                if (original instanceof SourceMap) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 7;
                return _this2.getConsumer(original);

              case 7:
                original = _context3.sent;

              case 8:
                extension.eachMapping(function (mapping) {
                  var originalMapping = original.originalPositionFor({
                    line: mapping.original.line,
                    column: mapping.original.column
                  });

                  if (!originalMapping || !originalMapping.line) {
                    return;
                  }

                  _this2.addMapping({
                    source: originalMapping.source,
                    name: originalMapping.name,
                    original: {
                      line: originalMapping.line,
                      column: originalMapping.column
                    },
                    generated: {
                      line: mapping.generated.line,
                      column: mapping.generated.column
                    }
                  });

                  if (!_this2.sources[originalMapping.source]) {
                    _this2.sources[originalMapping.source] = original.sourceContentFor(originalMapping.source, true);
                  }
                });

                if (original.destroy) {
                  // Only needs to happen in source-map 0.7
                  original.destroy();
                }

                return _context3.abrupt("return", _this2);

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    }
  }, {
    key: "findClosestGenerated",
    value: function findClosestGenerated(line, column) {
      if (line < 1) {
        throw new Error('Line numbers must be >= 1');
      }

      if (column < 0) {
        throw new Error('Column numbers must be >= 0');
      }

      if (this.mappings.length < 1) {
        return undefined;
      }

      var startIndex = 0;
      var stopIndex = this.mappings.length - 1;
      var middleIndex = stopIndex + startIndex >>> 1;

      while (startIndex < stopIndex && this.mappings[middleIndex].generated.line !== line) {
        var mid = this.mappings[middleIndex].generated.line;

        if (line < mid) {
          stopIndex = middleIndex - 1;
        } else if (line > mid) {
          startIndex = middleIndex + 1;
        }

        middleIndex = stopIndex + startIndex >>> 1;
      }

      var mapping = this.mappings[middleIndex];

      if (!mapping || mapping.generated.line !== line) {
        return this.mappings.length - 1;
      }

      while (middleIndex >= 1 && this.mappings[middleIndex - 1].generated.line === line) {
        middleIndex--;
      }

      while (middleIndex < this.mappings.length - 1 && this.mappings[middleIndex + 1].generated.line === line && column > this.mappings[middleIndex].generated.column) {
        middleIndex++;
      }

      return middleIndex;
    }
  }, {
    key: "findClosest",
    value: function findClosest(line, column, key) {
      if (line < 1) {
        throw new Error('Line numbers must be >= 1');
      }

      if (column < 0) {
        throw new Error('Column numbers must be >= 0');
      }

      if (this.mappings.length < 1) {
        return undefined;
      }

      var startIndex = 0;
      var stopIndex = this.mappings.length - 1;
      var middleIndex = Math.floor((stopIndex + startIndex) / 2);

      while (startIndex < stopIndex && this.mappings[middleIndex][key].line !== line) {
        if (line < this.mappings[middleIndex][key].line) {
          stopIndex = middleIndex - 1;
        } else if (line > this.mappings[middleIndex][key].line) {
          startIndex = middleIndex + 1;
        }

        middleIndex = Math.floor((stopIndex + startIndex) / 2);
      }

      var mapping = this.mappings[middleIndex];

      if (!mapping || mapping[key].line !== line) {
        return this.mappings.length - 1;
      }

      while (middleIndex >= 1 && this.mappings[middleIndex - 1][key].line === line) {
        middleIndex--;
      }

      while (middleIndex < this.mappings.length - 1 && this.mappings[middleIndex + 1][key].line === line && column > this.mappings[middleIndex][key].column) {
        middleIndex++;
      }

      return middleIndex;
    }
  }, {
    key: "originalPositionFor",
    value: function originalPositionFor(generatedPosition) {
      var index = this.findClosestGenerated(generatedPosition.line, generatedPosition.column);
      var mapping = this.mappings[index];

      if (!mapping || !mapping.original) {
        return null;
      }

      return {
        source: mapping.source,
        name: mapping.name,
        line: mapping.original.line,
        column: mapping.original.column
      };
    }
  }, {
    key: "generatedPositionFor",
    value: function generatedPositionFor(originalPosition) {
      var index = this.findClosest(originalPosition.line, originalPosition.column, 'original');
      var mapping = this.mappings[index];
      return {
        source: mapping.source,
        name: mapping.name,
        line: mapping.generated.line,
        column: mapping.generated.column
      };
    }
  }, {
    key: "sourceContentFor",
    value: function sourceContentFor(fileName) {
      return this.sources[fileName];
    }
  }, {
    key: "offset",
    value: function offset() {
      var lineOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var columnOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.mappings.map(function (mapping) {
        mapping.generated.line = mapping.generated.line + lineOffset;
        mapping.generated.column = mapping.generated.column + columnOffset;
        return mapping;
      });

      if (this.lineCount != null) {
        this.lineCount += lineOffset;
      }
    }
  }, {
    key: "stringify",
    value: function stringify(file, sourceRoot) {
      var _this3 = this;

      var generator = new SourceMapGenerator({
        file: file,
        sourceRoot: sourceRoot
      });
      this.eachMapping(function (mapping) {
        return generator.addMapping(mapping);
      });
      Object.keys(this.sources).forEach(function (sourceName) {
        return generator.setSourceContent(sourceName, _this3.sources[sourceName]);
      });
      return generator.toString();
    }
  }]);

  return SourceMap;
}();

module.exports = SourceMap;