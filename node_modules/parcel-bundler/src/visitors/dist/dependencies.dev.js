"use strict";

var types = require('@babel/types');

var template = require('@babel/template')["default"];

var traverse = require('@babel/traverse')["default"];

var urlJoin = require('../utils/urlJoin');

var isURL = require('../utils/is-url');

var nodeBuiltins = require('node-libs-browser');

var requireTemplate = template('require("_bundle_loader")');
var argTemplate = template('require.resolve(MODULE)');
var serviceWorkerPattern = ['navigator', 'serviceWorker', 'register'];
module.exports = {
  ImportDeclaration: function ImportDeclaration(node, asset) {
    asset.isES6Module = true;
    addDependency(asset, node.source);
  },
  ExportNamedDeclaration: function ExportNamedDeclaration(node, asset) {
    asset.isES6Module = true;

    if (node.source) {
      addDependency(asset, node.source);
    }
  },
  ExportAllDeclaration: function ExportAllDeclaration(node, asset) {
    asset.isES6Module = true;
    addDependency(asset, node.source);
  },
  ExportDefaultDeclaration: function ExportDefaultDeclaration(node, asset) {
    asset.isES6Module = true;
  },
  CallExpression: function CallExpression(node, asset, ancestors) {
    var callee = node.callee,
        args = node.arguments;
    var isRequire = types.isIdentifier(callee) && callee.name === 'require' && args.length === 1 && types.isStringLiteral(args[0]) && !hasBinding(ancestors, 'require') && !isInFalsyBranch(ancestors);

    if (isRequire) {
      var optional = ancestors.some(function (a) {
        return types.isTryStatement(a);
      }) || undefined;
      addDependency(asset, args[0], {
        optional: optional
      });
      return;
    }

    var isDynamicImport = callee.type === 'Import' && args.length === 1 && types.isStringLiteral(args[0]);

    if (isDynamicImport) {
      if (isURL(args[0].value)) return;
      asset.addDependency('_bundle_loader');
      addDependency(asset, args[0], {
        dynamic: true
      });
      node.callee = requireTemplate().expression;
      node.arguments[0] = argTemplate({
        MODULE: args[0]
      }).expression;
      asset.isAstDirty = true;
      return;
    }

    var isRegisterServiceWorker = types.isStringLiteral(args[0]) && types.matchesPattern(callee, serviceWorkerPattern);

    if (isRegisterServiceWorker) {
      // Treat service workers as an entry point so filenames remain consistent across builds.
      // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#avoid_changing_the_url_of_your_service_worker_script
      addURLDependency(asset, args[0], {
        entry: true,
        isolated: true
      });
      return;
    }
  },
  NewExpression: function NewExpression(node, asset) {
    var callee = node.callee,
        args = node.arguments;
    var isWebWorker = callee.type === 'Identifier' && (callee.name === 'Worker' || callee.name === 'SharedWorker') && args.length === 1 && types.isStringLiteral(args[0]);

    if (isWebWorker) {
      addURLDependency(asset, args[0], {
        isolated: true
      });
      return;
    }
  }
};

function hasBinding(node, name) {
  if (Array.isArray(node)) {
    return node.some(function (ancestor) {
      return hasBinding(ancestor, name);
    });
  } else if (types.isProgram(node) || types.isBlockStatement(node) || types.isBlock(node)) {
    return node.body.some(function (statement) {
      return hasBinding(statement, name);
    });
  } else if (types.isFunctionDeclaration(node) || types.isFunctionExpression(node) || types.isArrowFunctionExpression(node)) {
    return node.id && node.id.name === name || node.params.some(function (param) {
      return types.isIdentifier(param) && param.name === name;
    });
  } else if (types.isVariableDeclaration(node)) {
    return node.declarations.some(function (declaration) {
      return declaration.id.name === name;
    });
  }

  return false;
}

function isInFalsyBranch(ancestors) {
  // Check if any ancestors are if statements
  return ancestors.some(function (node, index) {
    if (types.isIfStatement(node)) {
      var res = evaluateExpression(node.test);

      if (res && res.confident) {
        // If the test is truthy, exclude the dep if it is in the alternate branch.
        // If the test if falsy, exclude the dep if it is in the consequent branch.
        var child = ancestors[index + 1];
        return res.value ? child === node.alternate : child === node.consequent;
      }
    }
  });
}

function evaluateExpression(node) {
  // Wrap the node in a standalone program so we can traverse it
  node = types.file(types.program([types.expressionStatement(node)])); // Find the first expression and evaluate it.

  var res = null;
  traverse(node, {
    Expression: function Expression(path) {
      res = path.evaluate();
      path.stop();
    }
  });
  return res;
}

function addDependency(asset, node) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // Don't bundle node builtins
  if (asset.options.target === 'node' && node.value in nodeBuiltins) {
    return;
  } // If this came from an inline <script> tag, throw an error.
  // TODO: run JSPackager on inline script tags.


  var inlineHTML = asset.options.rendition && asset.options.rendition.inlineHTML;

  if (inlineHTML) {
    var err = new Error('Imports and requires are not supported inside inline <script> tags yet.');
    err.loc = node.loc && node.loc.start;
    throw err;
  }

  if (!asset.options.bundleNodeModules) {
    var isRelativeImport = /^[/~.]/.test(node.value);
    if (!isRelativeImport) return;
  }

  opts.loc = node.loc && node.loc.start;
  asset.addDependency(node.value, opts);
}

function addURLDependency(asset, node) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  opts.loc = node.loc && node.loc.start;
  var assetPath = asset.addURLDependency(node.value, opts);

  if (!isURL(assetPath)) {
    assetPath = urlJoin(asset.options.publicURL, assetPath);
  }

  node.value = assetPath;
  asset.isAstDirty = true;
}