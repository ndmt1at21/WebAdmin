"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var config = require('./config');

var _require = require('@parcel/utils'),
    promisify = _require.promisify;

var resolve = promisify(require('resolve'));

var commandExists = require('command-exists');

var logger = require('@parcel/logger');

var pipeSpawn = require('./pipeSpawn');

var PromiseQueue = require('./PromiseQueue');

var path = require('path');

var fs = require('@parcel/fs');

var WorkerFarm = require('@parcel/workers');

var YARN_LOCK = 'yarn.lock';

function install(modules, filepath) {
  var options,
      _options$installPeers,
      installPeers,
      _options$saveDev,
      saveDev,
      packageManager,
      packageLocation,
      cwd,
      commandToUse,
      args,
      _args = arguments;

  return regeneratorRuntime.async(function install$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
          _options$installPeers = options.installPeers, installPeers = _options$installPeers === void 0 ? true : _options$installPeers, _options$saveDev = options.saveDev, saveDev = _options$saveDev === void 0 ? true : _options$saveDev, packageManager = options.packageManager;

          if (typeof modules === 'string') {
            modules = [modules];
          }

          logger.progress("Installing ".concat(modules.join(', '), "..."));
          _context.next = 6;
          return regeneratorRuntime.awrap(config.resolve(filepath, ['package.json']));

        case 6:
          packageLocation = _context.sent;
          cwd = packageLocation ? path.dirname(packageLocation) : process.cwd();

          if (packageManager) {
            _context.next = 12;
            break;
          }

          _context.next = 11;
          return regeneratorRuntime.awrap(determinePackageManager(filepath));

        case 11:
          packageManager = _context.sent;

        case 12:
          commandToUse = packageManager === 'npm' ? 'install' : 'add';
          args = [commandToUse].concat(_toConsumableArray(modules));

          if (saveDev) {
            args.push('-D');
          } else if (packageManager === 'npm') {
            args.push('--save');
          } // npm doesn't auto-create a package.json when installing,
          // so create an empty one if needed.


          if (!(packageManager === 'npm' && !packageLocation)) {
            _context.next = 18;
            break;
          }

          _context.next = 18;
          return regeneratorRuntime.awrap(fs.writeFile(path.join(cwd, 'package.json'), '{}'));

        case 18:
          _context.prev = 18;
          _context.next = 21;
          return regeneratorRuntime.awrap(pipeSpawn(packageManager, args, {
            cwd: cwd
          }));

        case 21:
          _context.next = 26;
          break;

        case 23:
          _context.prev = 23;
          _context.t0 = _context["catch"](18);
          throw new Error("Failed to install ".concat(modules.join(', '), "."));

        case 26:
          if (!installPeers) {
            _context.next = 29;
            break;
          }

          _context.next = 29;
          return regeneratorRuntime.awrap(Promise.all(modules.map(function (m) {
            return installPeerDependencies(filepath, m, options);
          })));

        case 29:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[18, 23]]);
}

function installPeerDependencies(filepath, name, options) {
  var basedir, _ref, _ref2, resolved, pkg, peers, modules, peer;

  return regeneratorRuntime.async(function installPeerDependencies$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          basedir = path.dirname(filepath);
          _context2.next = 3;
          return regeneratorRuntime.awrap(resolve(name, {
            basedir: basedir
          }));

        case 3:
          _ref = _context2.sent;
          _ref2 = _slicedToArray(_ref, 1);
          resolved = _ref2[0];
          _context2.next = 8;
          return regeneratorRuntime.awrap(config.load(resolved, ['package.json']));

        case 8:
          pkg = _context2.sent;
          peers = pkg.peerDependencies || {};
          modules = [];

          for (peer in peers) {
            modules.push("".concat(peer, "@").concat(peers[peer]));
          }

          if (!modules.length) {
            _context2.next = 15;
            break;
          }

          _context2.next = 15;
          return regeneratorRuntime.awrap(install(modules, filepath, Object.assign({}, options, {
            installPeers: false
          })));

        case 15:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function determinePackageManager(filepath) {
  var yarnLockFile, hasYarn;
  return regeneratorRuntime.async(function determinePackageManager$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(config.resolve(filepath, [YARN_LOCK]));

        case 2:
          yarnLockFile = _context3.sent;

          if (yarnLockFile) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt("return", 'npm');

        case 5:
          _context3.next = 7;
          return regeneratorRuntime.awrap(checkForYarnCommand());

        case 7:
          hasYarn = _context3.sent;

          if (!hasYarn) {
            _context3.next = 10;
            break;
          }

          return _context3.abrupt("return", 'yarn');

        case 10:
          return _context3.abrupt("return", 'npm');

        case 11:
        case "end":
          return _context3.stop();
      }
    }
  });
}

var hasYarn = null;

function checkForYarnCommand() {
  return regeneratorRuntime.async(function checkForYarnCommand$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!(hasYarn != null)) {
            _context4.next = 2;
            break;
          }

          return _context4.abrupt("return", hasYarn);

        case 2:
          _context4.prev = 2;
          _context4.next = 5;
          return regeneratorRuntime.awrap(commandExists('yarn'));

        case 5:
          hasYarn = _context4.sent;
          _context4.next = 11;
          break;

        case 8:
          _context4.prev = 8;
          _context4.t0 = _context4["catch"](2);
          hasYarn = false;

        case 11:
          return _context4.abrupt("return", hasYarn);

        case 12:
        case "end":
          return _context4.stop();
      }
    }
  }, null, null, [[2, 8]]);
}

var queue = new PromiseQueue(install, {
  maxConcurrent: 1,
  retry: false
});

module.exports = function _callee() {
  var _len,
      args,
      _key,
      _args5 = arguments;

  return regeneratorRuntime.async(function _callee$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          for (_len = _args5.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = _args5[_key];
          }

          if (!WorkerFarm.isWorker()) {
            _context5.next = 5;
            break;
          }

          _context5.next = 4;
          return regeneratorRuntime.awrap(WorkerFarm.callMaster({
            location: __filename,
            args: args
          }));

        case 4:
          return _context5.abrupt("return");

        case 5:
          queue.add.apply(queue, args);
          return _context5.abrupt("return", queue.run());

        case 7:
        case "end":
          return _context5.stop();
      }
    }
  });
};