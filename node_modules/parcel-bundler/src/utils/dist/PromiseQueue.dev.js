"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PromiseQueue =
/*#__PURE__*/
function () {
  function PromiseQueue(callback) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PromiseQueue);

    this.process = callback;
    this.maxConcurrent = options.maxConcurrent || Infinity;
    this.retry = options.retry !== false;
    this.queue = [];
    this.processing = new Set();
    this.processed = new Set();
    this.numRunning = 0;
    this.runPromise = null;
    this.resolve = null;
    this.reject = null;
  }

  _createClass(PromiseQueue, [{
    key: "add",
    value: function add(job) {
      if (this.processing.has(job)) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.runPromise && this.numRunning < this.maxConcurrent) {
        this._runJob(job, args);
      } else {
        this.queue.push([job, args]);
      }

      this.processing.add(job);
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      if (this.runPromise) {
        return this.runPromise;
      }

      var runPromise = new Promise(function (resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      this.runPromise = runPromise;

      this._next();

      return runPromise;
    }
  }, {
    key: "_runJob",
    value: function _runJob(job, args) {
      return regeneratorRuntime.async(function _runJob$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              this.numRunning++;
              _context.next = 4;
              return regeneratorRuntime.awrap(this.process.apply(this, [job].concat(_toConsumableArray(args))));

            case 4:
              this.processing["delete"](job);
              this.processed.add(job);
              this.numRunning--;

              this._next();

              _context.next = 16;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](0);
              this.numRunning--;

              if (this.retry) {
                this.queue.push([job, args]);
              } else {
                this.processing["delete"](job);
              }

              if (this.reject) {
                this.reject(_context.t0);
              }

              this._reset();

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[0, 10]]);
    }
  }, {
    key: "_next",
    value: function _next() {
      if (!this.runPromise) {
        return;
      }

      if (this.queue.length > 0) {
        while (this.queue.length > 0 && this.numRunning < this.maxConcurrent) {
          this._runJob.apply(this, _toConsumableArray(this.queue.shift()));
        }
      } else if (this.processing.size === 0) {
        this.resolve(this.processed);

        this._reset();
      }
    }
  }, {
    key: "_reset",
    value: function _reset() {
      this.processed = new Set();
      this.runPromise = null;
      this.resolve = null;
      this.reject = null;
    }
  }]);

  return PromiseQueue;
}();

module.exports = PromiseQueue;