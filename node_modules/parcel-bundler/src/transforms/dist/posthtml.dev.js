"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var loadPlugins = require('../utils/loadPlugins');

var posthtml = require('posthtml');

var posthtmlParse = require('posthtml-parser');

function parse(code, asset) {
  var config;
  return regeneratorRuntime.async(function parse$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(getConfig(asset));

        case 2:
          config = _context.sent;

          if (!config) {
            config = {};
          }

          return _context.abrupt("return", posthtmlParse(code, config));

        case 5:
        case "end":
          return _context.stop();
      }
    }
  });
}

function transform(asset) {
  var config, res;
  return regeneratorRuntime.async(function transform$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return regeneratorRuntime.awrap(getConfig(asset));

        case 2:
          config = _context2.sent;

          if (config) {
            _context2.next = 5;
            break;
          }

          return _context2.abrupt("return");

        case 5:
          _context2.next = 7;
          return regeneratorRuntime.awrap(asset.parseIfNeeded());

        case 7:
          _context2.next = 9;
          return regeneratorRuntime.awrap(posthtml(config.plugins).process(asset.ast, config));

        case 9:
          res = _context2.sent;
          asset.ast = res.tree;
          asset.isAstDirty = true;

        case 12:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function getConfig(asset) {
  var config, plugins, depConfig;
  return regeneratorRuntime.async(function getConfig$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(asset.getConfig(['.posthtmlrc', '.posthtmlrc.js', 'posthtml.config.js'], {
            packageKey: 'posthtml'
          }));

        case 2:
          config = _context3.sent;

          if (!(!config && !asset.options.minify)) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt("return");

        case 5:
          config = config || {};
          plugins = config.plugins;

          if (_typeof(plugins) === 'object') {
            // This is deprecated in favor of result messages but kept for compatibility
            // See https://github.com/posthtml/posthtml-include/blob/e4f2a57c2e52ff721eed747b65eddf7d7a1451e3/index.js#L18-L26
            depConfig = {
              addDependencyTo: {
                addDependency: function addDependency(name) {
                  return asset.addDependency(name, {
                    includedInParent: true
                  });
                }
              }
            };
            Object.keys(plugins).forEach(function (p) {
              return Object.assign(plugins[p], depConfig);
            });
          }

          _context3.next = 10;
          return regeneratorRuntime.awrap(loadPlugins(plugins, asset.name));

        case 10:
          config.plugins = _context3.sent;
          config.skipParse = true;
          return _context3.abrupt("return", config);

        case 13:
        case "end":
          return _context3.stop();
      }
    }
  });
}

module.exports = {
  parse: parse,
  transform: transform
};