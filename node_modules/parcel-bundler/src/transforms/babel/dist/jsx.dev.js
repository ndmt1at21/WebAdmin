"use strict";

var path = require('path');

var JSX_EXTENSIONS = {
  '.jsx': true,
  '.tsx': true
};
var JSX_PRAGMA = {
  react: 'React.createElement',
  preact: 'h',
  nervjs: 'Nerv.createElement',
  hyperapp: 'h'
};

function createJSXRegexFor(dependency) {
  // result looks like /from\s+[`"']react[`"']|require\([`"']react[`"']\)/
  return new RegExp("from\\s+[`\"']".concat(dependency, "[`\"']|require\\([`\"']").concat(dependency, "[`\"']\\)"));
}
/**
 * Solves a use case when JSX is used in .js files, but
 * package.json is empty or missing yet and therefore pragma cannot
 * be determined based on pkg.dependencies / pkg.devDependencies
 */


var cacheJsxRegexFor = {};

function maybeCreateFallbackPragma(asset) {
  for (var dep in JSX_PRAGMA) {
    var regex = cacheJsxRegexFor[dep];

    if (!regex) {
      regex = createJSXRegexFor(dep);
      cacheJsxRegexFor[dep] = regex;
    }

    if (asset.contents.match(regex)) {
      return JSX_PRAGMA[dep];
    }
  }
}
/**
 * Generates a babel config for JSX. Attempts to detect react or react-like libraries
 * and changes the pragma accordingly.
 */


function getJSXConfig(asset, isSourceModule) {
  var pkg, pragma, dep;
  return regeneratorRuntime.async(function getJSXConfig$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (isSourceModule) {
            _context.next = 2;
            break;
          }

          return _context.abrupt("return", null);

        case 2:
          _context.next = 4;
          return regeneratorRuntime.awrap(asset.getPackage());

        case 4:
          pkg = _context.sent;
          // Find a dependency that we can map to a JSX pragma
          pragma = null;
          _context.t0 = regeneratorRuntime.keys(JSX_PRAGMA);

        case 7:
          if ((_context.t1 = _context.t0()).done) {
            _context.next = 14;
            break;
          }

          dep = _context.t1.value;

          if (!(pkg && (pkg.dependencies && pkg.dependencies[dep] || pkg.devDependencies && pkg.devDependencies[dep]))) {
            _context.next = 12;
            break;
          }

          pragma = JSX_PRAGMA[dep];
          return _context.abrupt("break", 14);

        case 12:
          _context.next = 7;
          break;

        case 14:
          if (!pragma) {
            pragma = maybeCreateFallbackPragma(asset);
          }

          if (!(pragma || JSX_EXTENSIONS[path.extname(asset.name)])) {
            _context.next = 17;
            break;
          }

          return _context.abrupt("return", {
            internal: true,
            babelVersion: 7,
            config: {
              plugins: [[require('@babel/plugin-transform-react-jsx'), {
                pragma: pragma,
                pragmaFrag: 'React.Fragment'
              }]]
            }
          });

        case 17:
        case "end":
          return _context.stop();
      }
    }
  });
}

module.exports = getJSXConfig;