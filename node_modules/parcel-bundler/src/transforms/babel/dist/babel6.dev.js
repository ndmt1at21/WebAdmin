"use strict";

var localRequire = require('../../utils/localRequire');

var _require = require('./astConverter'),
    babel6toBabel7 = _require.babel6toBabel7;

function babel6(asset, options) {
  var babel, config, res;
  return regeneratorRuntime.async(function babel6$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(localRequire('babel-core', asset.name));

        case 2:
          babel = _context.sent;
          config = options.config;
          config.code = false;
          config.ast = true;
          config.filename = asset.name;
          config.babelrc = false;
          config.parserOpts = Object.assign({}, config.parserOpts, {
            allowReturnOutsideFunction: true,
            allowHashBang: true,
            ecmaVersion: Infinity,
            strictMode: false,
            sourceType: 'module',
            locations: true
          }); // Passing a list of plugins as part of parserOpts seems to override any custom
          // syntax plugins a user might have added (e.g. decorators). We add dynamicImport
          // using a plugin instead.

          config.plugins = (config.plugins || []).concat(dynamicImport);
          res = babel.transform(asset.contents, config);

          if (res.ast) {
            asset.ast = babel6toBabel7(res.ast);
            asset.isAstDirty = true;
          }

        case 12:
        case "end":
          return _context.stop();
      }
    }
  });
}

function dynamicImport() {
  return {
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push('dynamicImport');
    }
  };
}

module.exports = babel6;