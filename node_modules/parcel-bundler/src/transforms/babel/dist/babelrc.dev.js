"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var semver = require('semver');

var logger = require('@parcel/logger');

var path = require('path');

var localRequire = require('../../utils/localRequire');

var installPackage = require('../../utils/installPackage');

var fs = require('@parcel/fs');

var micromatch = require('micromatch');

function getBabelConfig(asset, isSource) {
  var config, plugins, babelVersion;
  return regeneratorRuntime.async(function getBabelConfig$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(getBabelRc(asset, isSource));

        case 2:
          config = _context.sent;

          if (config) {
            _context.next = 5;
            break;
          }

          return _context.abrupt("return", null);

        case 5:
          if (!((!config.plugins || config.plugins.length === 0) && (!config.presets || config.presets.length === 0))) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return", null);

        case 7:
          _context.next = 9;
          return regeneratorRuntime.awrap(installPlugins(asset, config));

        case 9:
          plugins = _context.sent;
          _context.next = 12;
          return regeneratorRuntime.awrap(getBabelVersion(asset, plugins));

        case 12:
          babelVersion = _context.sent;
          return _context.abrupt("return", {
            babelVersion: babelVersion,
            config: config
          });

        case 14:
        case "end":
          return _context.stop();
      }
    }
  });
}

module.exports = getBabelConfig;
/**
 * Finds a .babelrc for an asset. By default, .babelrc files inside node_modules are not used.
 * However, there are some exceptions:
 *   - if `browserify.transforms` includes "babelify" in package.json (for legacy module compat)
 *   - the `source` field in package.json is used by the resolver
 */

function getBabelRc(asset, isSource) {
  var pkg, browserify, babelify;
  return regeneratorRuntime.async(function getBabelRc$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return regeneratorRuntime.awrap(asset.getPackage());

        case 2:
          pkg = _context2.sent;
          browserify = pkg && pkg.browserify;

          if (!(browserify && Array.isArray(browserify.transform))) {
            _context2.next = 9;
            break;
          }

          // Look for babelify in the browserify transform list
          babelify = browserify.transform.find(function (t) {
            return (Array.isArray(t) ? t[0] : t) === 'babelify';
          }); // If specified as an array, override the config with the one specified

          if (!(Array.isArray(babelify) && babelify[1])) {
            _context2.next = 8;
            break;
          }

          return _context2.abrupt("return", babelify[1]);

        case 8:
          return _context2.abrupt("return", babelify ? findBabelRc(asset) : null);

        case 9:
          if (!isSource) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt("return", findBabelRc(asset));

        case 11:
          return _context2.abrupt("return", null);

        case 12:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function findBabelRc(asset) {
  var config, _i, _arr, key, ignoreConfig;

  return regeneratorRuntime.async(function findBabelRc$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(asset.getConfig(['.babelrc', '.babelrc.js'], {
            packageKey: 'babel'
          }));

        case 2:
          config = _context3.sent;

          if (config) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt("return", null);

        case 5:
          if (!(typeof config === 'function')) {
            _context3.next = 7;
            break;
          }

          throw new Error('Parcel does not support function configs in .babelrc.js yet.');

        case 7:
          _i = 0, _arr = ['extends', 'overrides', 'test', 'include', 'exclude'];

        case 8:
          if (!(_i < _arr.length)) {
            _context3.next = 15;
            break;
          }

          key = _arr[_i];

          if (!config[key]) {
            _context3.next = 12;
            break;
          }

          throw new Error("Parcel does not support babel 7 advanced configuration option \"".concat(key, "\" yet."));

        case 12:
          _i++;
          _context3.next = 8;
          break;

        case 15:
          if (!shouldIgnore(asset, config)) {
            _context3.next = 17;
            break;
          }

          return _context3.abrupt("return", null);

        case 17:
          _context3.next = 19;
          return regeneratorRuntime.awrap(getIgnoreConfig(asset));

        case 19:
          ignoreConfig = _context3.sent;

          if (!(ignoreConfig && shouldIgnore(asset, ignoreConfig))) {
            _context3.next = 22;
            break;
          }

          return _context3.abrupt("return", null);

        case 22:
          return _context3.abrupt("return", config);

        case 23:
        case "end":
          return _context3.stop();
      }
    }
  });
}

function getIgnoreConfig(asset) {
  var ignoreFile, data, patterns;
  return regeneratorRuntime.async(function getIgnoreConfig$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return regeneratorRuntime.awrap(asset.getConfig(['.babelignore'], {
            load: false
          }));

        case 2:
          ignoreFile = _context4.sent;

          if (ignoreFile) {
            _context4.next = 5;
            break;
          }

          return _context4.abrupt("return", null);

        case 5:
          _context4.next = 7;
          return regeneratorRuntime.awrap(fs.readFile(ignoreFile, 'utf8'));

        case 7:
          data = _context4.sent;
          patterns = data.split('\n').map(function (line) {
            return line.replace(/#.*$/, '').trim();
          }).filter(Boolean);
          return _context4.abrupt("return", {
            ignore: patterns
          });

        case 10:
        case "end":
          return _context4.stop();
      }
    }
  });
}

function shouldIgnore(asset, config) {
  if (config.ignore && matchesPatterns(config.ignore, asset.name)) {
    return true;
  }

  if (config.only && !matchesPatterns(config.only, asset.name)) {
    return true;
  }

  return false;
}

function matchesPatterns(patterns, path) {
  return patterns.some(function (pattern) {
    if (typeof pattern === 'function') {
      return !!pattern(path);
    }

    if (typeof pattern === 'string') {
      return micromatch.isMatch(path, '**/' + pattern + '/**');
    }

    return pattern.test(path);
  });
}

function getBabelVersion(asset, plugins) {
  var pkg, babelLegacy, babelModern, inferred, name;
  return regeneratorRuntime.async(function getBabelVersion$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return regeneratorRuntime.awrap(asset.getPackage());

        case 2:
          pkg = _context5.sent;
          babelLegacy = getDependency(pkg, 'babel-core');
          babelModern = getDependency(pkg, '@babel/core');

          if (!babelModern) {
            _context5.next = 7;
            break;
          }

          return _context5.abrupt("return", getMaxMajor(babelModern));

        case 7:
          if (!babelLegacy) {
            _context5.next = 9;
            break;
          }

          return _context5.abrupt("return", 6);

        case 9:
          _context5.next = 11;
          return regeneratorRuntime.awrap(inferBabelVersion(asset, plugins));

        case 11:
          inferred = _context5.sent;
          name = inferred === 6 ? 'babel-core' : "@babel/core";
          _context5.next = 15;
          return regeneratorRuntime.awrap(installPackage(name, asset.name));

        case 15:
          return _context5.abrupt("return", inferred);

        case 16:
        case "end":
          return _context5.stop();
      }
    }
  });
}

function getDependency(pkg, dep) {
  return pkg.dependencies && pkg.dependencies[dep] || pkg.peerDependencies && pkg.peerDependencies[dep] || pkg.devDependencies && pkg.devDependencies[dep];
} // Core babel packages we use to infer the major version of babel to use.


var CORE_DEPS = new Set(['@babel/core', '@babel/runtime', '@babel/template', '@babel/traverse', '@babel/types', '@babel/parser', '@babel/cli', '@babel/register', '@babel/generator', 'babel-core', 'babel-runtime', 'babel-template', 'babel-traverse', 'babel-types', 'babylon', 'babel-cli', 'babel-register', 'babel-generator']);

function inferBabelVersion(asset, plugins) {
  var version, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pkg, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, name, dep, range;

  return regeneratorRuntime.async(function inferBabelVersion$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          // Attempt to determine version based on dependencies of plugins
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context6.prev = 3;
          _iterator = plugins[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context6.next = 43;
            break;
          }

          pkg = _step.value;

          if (pkg) {
            _context6.next = 9;
            break;
          }

          return _context6.abrupt("continue", 40);

        case 9:
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context6.prev = 12;
          _iterator2 = CORE_DEPS[Symbol.iterator]();

        case 14:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context6.next = 26;
            break;
          }

          name = _step2.value;
          dep = getDependency(pkg, name);

          if (!dep) {
            _context6.next = 23;
            break;
          }

          // Parse version range (ignore prerelease), and ensure it overlaps with the existing version (if any)
          range = new semver.Range(dep.replace(/-.*(\s|\|\||$)?/, ''));

          if (!(version && !version.intersects(range))) {
            _context6.next = 21;
            break;
          }

          throw new Error('Conflicting babel versions found in .babelrc. Make sure all of your plugins and presets depend on the same major version of babel.');

        case 21:
          version = range;
          return _context6.abrupt("break", 26);

        case 23:
          _iteratorNormalCompletion2 = true;
          _context6.next = 14;
          break;

        case 26:
          _context6.next = 32;
          break;

        case 28:
          _context6.prev = 28;
          _context6.t0 = _context6["catch"](12);
          _didIteratorError2 = true;
          _iteratorError2 = _context6.t0;

        case 32:
          _context6.prev = 32;
          _context6.prev = 33;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 35:
          _context6.prev = 35;

          if (!_didIteratorError2) {
            _context6.next = 38;
            break;
          }

          throw _iteratorError2;

        case 38:
          return _context6.finish(35);

        case 39:
          return _context6.finish(32);

        case 40:
          _iteratorNormalCompletion = true;
          _context6.next = 5;
          break;

        case 43:
          _context6.next = 49;
          break;

        case 45:
          _context6.prev = 45;
          _context6.t1 = _context6["catch"](3);
          _didIteratorError = true;
          _iteratorError = _context6.t1;

        case 49:
          _context6.prev = 49;
          _context6.prev = 50;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 52:
          _context6.prev = 52;

          if (!_didIteratorError) {
            _context6.next = 55;
            break;
          }

          throw _iteratorError;

        case 55:
          return _context6.finish(52);

        case 56:
          return _context6.finish(49);

        case 57:
          // Find the maximum major version allowed in the range and use that.
          // e.g. if ^6 || ^7 were specified, use 7.
          version = getMaxMajor(version);

          if (!version) {
            logger.warn("Could not infer babel version. Defaulting to babel 7. Please add either babel-core or @babel/core as a dependency.");
            version = 7;
          }

          return _context6.abrupt("return", version);

        case 60:
        case "end":
          return _context6.stop();
      }
    }
  }, null, null, [[3, 45, 49, 57], [12, 28, 32, 40], [33,, 35, 39], [50,, 52, 56]]);
}

function getPluginName(p) {
  return Array.isArray(p) ? p[0] : p;
}

function getMaxMajor(version) {
  try {
    var range = new semver.Range(version);
    var sorted = range.set.sort(function (a, b) {
      return a[0].semver.compare(b[0].semver);
    });
    return semver.major(sorted.pop()[0].semver.version);
  } catch (err) {
    return null;
  }
}

function installPlugins(asset, babelrc) {
  var presets, plugins;
  return regeneratorRuntime.async(function installPlugins$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          presets = (babelrc.presets || []).map(function (p) {
            return resolveModule('preset', getPluginName(p), asset.name);
          });
          plugins = (babelrc.plugins || []).map(function (p) {
            return resolveModule('plugin', getPluginName(p), asset.name);
          });
          return _context7.abrupt("return", Promise.all([].concat(_toConsumableArray(presets), _toConsumableArray(plugins))));

        case 3:
        case "end":
          return _context7.stop();
      }
    }
  });
}

function resolveModule(type, name, path) {
  var _ref, _ref2, pkg;

  return regeneratorRuntime.async(function resolveModule$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.prev = 0;
          name = standardizeName(type, name);
          _context8.next = 4;
          return regeneratorRuntime.awrap(localRequire.resolve(name, path));

        case 4:
          _ref = _context8.sent;
          _ref2 = _slicedToArray(_ref, 2);
          pkg = _ref2[1];
          return _context8.abrupt("return", pkg);

        case 10:
          _context8.prev = 10;
          _context8.t0 = _context8["catch"](0);
          return _context8.abrupt("return", null);

        case 13:
        case "end":
          return _context8.stop();
      }
    }
  }, null, null, [[0, 10]]);
} // Copied from https://github.com/babel/babel/blob/3a399d1eb907df520f2b85bf9ddbc6533e256f6d/packages/babel-core/src/config/files/plugins.js#L61


var EXACT_RE = /^module:/;
var BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
var BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
var BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
var BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
var OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
var OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
var OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;

function standardizeName(type, name) {
  // Let absolute and relative paths through.
  if (path.isAbsolute(name)) return name;
  var isPreset = type === 'preset';
  return name // foo -> babel-preset-foo
  .replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, "babel-".concat(type, "-")) // @babel/es2015 -> @babel/preset-es2015
  .replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, "$1".concat(type, "-")) // @foo/mypreset -> @foo/babel-preset-mypreset
  .replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, "$1babel-".concat(type, "-")) // @foo -> @foo/babel-preset
  .replace(OTHER_ORG_DEFAULT_RE, "$1/babel-".concat(type)) // module:mypreset -> mypreset
  .replace(EXACT_RE, '');
}