"use strict";

var getBabelRc = require('./babelrc');

var getEnvConfig = require('./env');

var getJSXConfig = require('./jsx');

var getFlowConfig = require('./flow');

var path = require('path');

var fs = require('@parcel/fs');

var NODE_MODULES = "".concat(path.sep, "node_modules").concat(path.sep);

var ENV_PLUGINS = require('@babel/preset-env/data/plugins');

var ENV_PRESETS = {
  es2015: true,
  es2016: true,
  es2017: true,
  latest: true,
  env: true,
  '@babel/preset-env': true,
  '@babel/env': true
};

function getBabelConfig(asset) {
  var pkg, isSource, babelrc, envConfig, jsxConfig, flowConfig, result, hasReact, hasFlow;
  return regeneratorRuntime.async(function getBabelConfig$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(asset.getPackage());

        case 2:
          pkg = _context.sent;
          _context.t1 = pkg && pkg.source;

          if (!_context.t1) {
            _context.next = 10;
            break;
          }

          _context.next = 7;
          return regeneratorRuntime.awrap(fs.realpath(asset.name));

        case 7:
          _context.t2 = _context.sent;
          _context.t3 = asset.name;
          _context.t1 = _context.t2 !== _context.t3;

        case 10:
          _context.t0 = !!_context.t1;

          if (_context.t0) {
            _context.next = 13;
            break;
          }

          _context.t0 = !asset.name.includes(NODE_MODULES);

        case 13:
          isSource = _context.t0;
          _context.next = 16;
          return regeneratorRuntime.awrap(getBabelRc(asset, isSource));

        case 16:
          babelrc = _context.sent;
          isSource = isSource || !!babelrc;
          _context.next = 20;
          return regeneratorRuntime.awrap(getEnvConfig(asset, isSource));

        case 20:
          envConfig = _context.sent;
          _context.next = 23;
          return regeneratorRuntime.awrap(getJSXConfig(asset, isSource));

        case 23:
          jsxConfig = _context.sent;
          flowConfig = getFlowConfig(asset, isSource);

          if (babelrc && envConfig) {
            // Filter out presets that are already applied by @babel/preset-env
            if (Array.isArray(babelrc.config.presets)) {
              babelrc.config.presets = babelrc.config.presets.filter(function (preset) {
                return !ENV_PRESETS[getPluginName(preset)];
              });
            } // Filter out plugins that are already applied by @babel/preset-env


            if (Array.isArray(babelrc.config.plugins)) {
              babelrc.config.plugins = babelrc.config.plugins.filter(function (plugin) {
                return !ENV_PLUGINS[getPluginName(plugin)];
              });
            }
          }

          result = {};
          mergeConfigs(result, babelrc);
          mergeConfigs(result, envConfig); // Add JSX config if it isn't already specified in the babelrc

          hasReact = babelrc && (hasPlugin(babelrc.config.presets, ['react', '@babel/react', '@babel/preset-react']) || hasPlugin(babelrc.config.plugins, ['transform-react-jsx', '@babel/transform-react-jsx', '@babel/plugin-transform-react-jsx']));

          if (!hasReact) {
            mergeConfigs(result, jsxConfig);
          } // Add Flow stripping config if it isn't already specified in the babelrc


          hasFlow = babelrc && hasPlugin(babelrc.config.plugins, ['transform-flow-strip-types', '@babel/transform-flow-strip-types', '@babel/plugin-transform-flow-strip-types']);

          if (!hasFlow) {
            mergeConfigs(result, flowConfig);
          }

          return _context.abrupt("return", result);

        case 34:
        case "end":
          return _context.stop();
      }
    }
  });
}

module.exports = getBabelConfig;

function mergeConfigs(result, config) {
  if (!config || (!config.config.presets || config.config.presets.length === 0) && (!config.config.plugins || config.config.plugins.length === 0)) {
    return;
  }

  var merged = result[config.babelVersion];

  if (merged) {
    merged.config.presets = (merged.config.presets || []).concat(config.config.presets || []);
    merged.config.plugins = (merged.config.plugins || []).concat(config.config.plugins || []);
  } else {
    result[config.babelVersion] = config;
  }
}

function hasPlugin(arr, plugins) {
  return Array.isArray(arr) && arr.some(function (p) {
    return plugins.includes(getPluginName(p));
  });
}

function getPluginName(p) {
  return Array.isArray(p) ? p[0] : p;
}