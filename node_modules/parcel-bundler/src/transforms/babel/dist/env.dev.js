"use strict";

var presetEnv = require('@babel/preset-env');

var getTargetEngines = require('../../utils/getTargetEngines');
/**
 * Generates a @babel/preset-env config for an asset.
 * This is done by finding the source module's target engines, and the app's
 * target engines, and doing a diff to include only the necessary plugins.
 */


function getEnvConfig(asset, isSourceModule) {
  var targetEngines, targetEnv, sourceEngines, sourceEnv, sourcePlugins;
  return regeneratorRuntime.async(function getEnvConfig$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(getTargetEngines(asset, true));

        case 2:
          targetEngines = _context.sent;
          _context.next = 5;
          return regeneratorRuntime.awrap(getEnvPlugins(targetEngines, true));

        case 5:
          targetEnv = _context.sent;

          if (targetEnv) {
            _context.next = 8;
            break;
          }

          return _context.abrupt("return", null);

        case 8:
          if (isSourceModule) {
            _context.next = 20;
            break;
          }

          _context.next = 11;
          return regeneratorRuntime.awrap(getTargetEngines(asset, false));

        case 11:
          sourceEngines = _context.sent;
          _context.next = 14;
          return regeneratorRuntime.awrap(getEnvPlugins(sourceEngines, false));

        case 14:
          _context.t0 = _context.sent;

          if (_context.t0) {
            _context.next = 17;
            break;
          }

          _context.t0 = targetEnv;

        case 17:
          sourceEnv = _context.t0;
          // Do a diff of the returned plugins. We only need to process the remaining plugins to get to the app target.
          sourcePlugins = new Set(sourceEnv.map(function (p) {
            return p[0];
          }));
          targetEnv = targetEnv.filter(function (plugin) {
            return !sourcePlugins.has(plugin[0]);
          });

        case 20:
          return _context.abrupt("return", {
            internal: true,
            babelVersion: 7,
            config: {
              plugins: targetEnv
            }
          });

        case 21:
        case "end":
          return _context.stop();
      }
    }
  });
}

var envCache = new Map();

function getEnvPlugins(targets) {
  var useBuiltIns,
      key,
      options,
      plugins,
      _args2 = arguments;
  return regeneratorRuntime.async(function getEnvPlugins$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          useBuiltIns = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;

          if (targets) {
            _context2.next = 3;
            break;
          }

          return _context2.abrupt("return", null);

        case 3:
          key = JSON.stringify(targets);

          if (!envCache.has(key)) {
            _context2.next = 6;
            break;
          }

          return _context2.abrupt("return", envCache.get(key));

        case 6:
          options = {
            targets: targets,
            modules: false,
            useBuiltIns: useBuiltIns ? 'entry' : false,
            shippedProposals: true
          };

          if (useBuiltIns) {
            options.corejs = 2;
          }

          plugins = presetEnv["default"]({
            assertVersion: function assertVersion() {
              return true;
            }
          }, options).plugins;
          envCache.set(key, plugins);
          return _context2.abrupt("return", plugins);

        case 11:
        case "end":
          return _context2.stop();
      }
    }
  });
}

module.exports = getEnvConfig;