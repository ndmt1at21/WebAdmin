"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var URL = require('url');

var path = require('path');

var clone = require('clone');

var fs = require('@parcel/fs');

var md5 = require('./utils/md5');

var isURL = require('./utils/is-url');

var config = require('./utils/config');

var syncPromise = require('./utils/syncPromise');

var logger = require('@parcel/logger');

var Resolver = require('./Resolver');

var objectHash = require('./utils/objectHash');

var t = require('babel-types');
/**
 * An Asset represents a file in the dependency tree. Assets can have multiple
 * parents that depend on it, and can be added to multiple output bundles.
 * The base Asset class doesn't do much by itself, but sets up an interface
 * for subclasses to implement.
 */


var Asset =
/*#__PURE__*/
function () {
  function Asset(name, options) {
    _classCallCheck(this, Asset);

    this.id = null;
    this.name = name;
    this.basename = path.basename(this.name);
    this.relativeName = path.relative(options.rootDir, this.name).replace(/\\/g, '/');
    this.options = options;
    this.encoding = 'utf8';
    this.type = path.extname(this.name).slice(1);
    this.hmrPageReload = false;
    this.processed = false;
    this.contents = options.rendition ? options.rendition.value : null;
    this.ast = null;
    this.generated = null;
    this.hash = null;
    this.sourceMaps = null;
    this.parentDeps = new Set();
    this.dependencies = new Map();
    this.depAssets = new Map();
    this.parentBundle = null;
    this.bundles = new Set();
    this.cacheData = {};
    this.startTime = 0;
    this.endTime = 0;
    this.buildTime = 0;
    this.bundledSize = 0;
    this.resolver = new Resolver(options);
  }

  _createClass(Asset, [{
    key: "shouldInvalidate",
    value: function shouldInvalidate() {
      return false;
    }
  }, {
    key: "loadIfNeeded",
    value: function loadIfNeeded() {
      return regeneratorRuntime.async(function loadIfNeeded$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(this.contents == null)) {
                _context.next = 4;
                break;
              }

              _context.next = 3;
              return regeneratorRuntime.awrap(this.load());

            case 3:
              this.contents = _context.sent;

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "parseIfNeeded",
    value: function parseIfNeeded() {
      return regeneratorRuntime.async(function parseIfNeeded$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return regeneratorRuntime.awrap(this.loadIfNeeded());

            case 2:
              if (this.ast) {
                _context2.next = 6;
                break;
              }

              _context2.next = 5;
              return regeneratorRuntime.awrap(this.parse(this.contents));

            case 5:
              this.ast = _context2.sent;

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getDependencies",
    value: function getDependencies() {
      return regeneratorRuntime.async(function getDependencies$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this.options.rendition && this.options.rendition.hasDependencies === false)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              _context3.next = 4;
              return regeneratorRuntime.awrap(this.loadIfNeeded());

            case 4:
              if (!(this.contents && this.mightHaveDependencies())) {
                _context3.next = 9;
                break;
              }

              _context3.next = 7;
              return regeneratorRuntime.awrap(this.parseIfNeeded());

            case 7:
              _context3.next = 9;
              return regeneratorRuntime.awrap(this.collectDependencies());

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "addDependency",
    value: function addDependency(name, opts) {
      this.dependencies.set(name, Object.assign({
        name: name
      }, opts));
    }
  }, {
    key: "resolveDependency",
    value: function resolveDependency(url) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.name;
      var parsed = URL.parse(url);
      var depName;
      var resolved;
      var dir = path.dirname(from);
      var filename = decodeURIComponent(parsed.pathname);

      if (filename[0] === '~' || filename[0] === '/') {
        if (dir === '.') {
          dir = this.options.rootDir;
        }

        depName = resolved = this.resolver.resolveFilename(filename, dir);
      } else {
        resolved = path.resolve(dir, filename);
        depName = './' + path.relative(path.dirname(this.name), resolved);
      }

      return {
        depName: depName,
        resolved: resolved
      };
    }
  }, {
    key: "addURLDependency",
    value: function addURLDependency(url) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.name;
      var opts = arguments.length > 2 ? arguments[2] : undefined;

      if (!url || isURL(url)) {
        return url;
      }

      if (_typeof(from) === 'object') {
        opts = from;
        from = this.name;
      }

      var _this$resolveDependen = this.resolveDependency(url, from),
          depName = _this$resolveDependen.depName,
          resolved = _this$resolveDependen.resolved;

      this.addDependency(depName, Object.assign({
        dynamic: true,
        resolved: resolved
      }, opts));
      var parsed = URL.parse(url);
      parsed.pathname = this.options.parser.getAsset(resolved, this.options).generateBundleName();
      return URL.format(parsed);
    }
  }, {
    key: "getPackage",
    value: function getPackage() {
      return regeneratorRuntime.async(function getPackage$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (this._package) {
                _context4.next = 4;
                break;
              }

              _context4.next = 3;
              return regeneratorRuntime.awrap(this.resolver.findPackage(path.dirname(this.name)));

            case 3:
              this._package = _context4.sent;

            case 4:
              return _context4.abrupt("return", this._package);

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getConfig",
    value: function getConfig(filenames) {
      var opts,
          pkg,
          conf,
          _args5 = arguments;
      return regeneratorRuntime.async(function getConfig$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};

              if (!opts.packageKey) {
                _context5.next = 7;
                break;
              }

              _context5.next = 4;
              return regeneratorRuntime.awrap(this.getPackage());

            case 4:
              pkg = _context5.sent;

              if (!(pkg && pkg[opts.packageKey])) {
                _context5.next = 7;
                break;
              }

              return _context5.abrupt("return", clone(pkg[opts.packageKey]));

            case 7:
              _context5.next = 9;
              return regeneratorRuntime.awrap(config.resolve(opts.path || this.name, filenames));

            case 9:
              conf = _context5.sent;

              if (!conf) {
                _context5.next = 15;
                break;
              }

              // Add as a dependency so it is added to the watcher and invalidates
              // this asset when the config changes.
              this.addDependency(conf, {
                includedInParent: true
              });

              if (!(opts.load === false)) {
                _context5.next = 14;
                break;
              }

              return _context5.abrupt("return", conf);

            case 14:
              return _context5.abrupt("return", config.load(opts.path || this.name, filenames));

            case 15:
              return _context5.abrupt("return", null);

            case 16:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "mightHaveDependencies",
    value: function mightHaveDependencies() {
      return true;
    }
  }, {
    key: "load",
    value: function load() {
      return regeneratorRuntime.async(function load$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", fs.readFile(this.name, this.encoding));

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "parse",
    value: function parse() {// do nothing by default
    }
  }, {
    key: "collectDependencies",
    value: function collectDependencies() {// do nothing by default
    }
  }, {
    key: "pretransform",
    value: function pretransform() {
      return regeneratorRuntime.async(function pretransform$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
            case "end":
              return _context7.stop();
          }
        }
      });
    }
  }, {
    key: "transform",
    value: function transform() {
      return regeneratorRuntime.async(function transform$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
            case "end":
              return _context8.stop();
          }
        }
      });
    }
  }, {
    key: "generate",
    value: function generate() {
      return regeneratorRuntime.async(function generate$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", _defineProperty({}, this.type, this.contents));

            case 1:
            case "end":
              return _context9.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "process",
    value: function process() {
      return regeneratorRuntime.async(function process$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              // Generate the id for this asset, unless it has already been set.
              // We do this here rather than in the constructor to avoid unnecessary work in the main process.
              // In development, the id is just the relative path to the file, for easy debugging and performance.
              // In production, we use a short hash of the relative path.
              if (!this.id) {
                this.id = this.options.production || this.options.scopeHoist ? t.toIdentifier(md5(this.relativeName, 'base64')).slice(0, 4) : this.relativeName;
              }

              if (this.generated) {
                _context10.next = 13;
                break;
              }

              _context10.next = 4;
              return regeneratorRuntime.awrap(this.loadIfNeeded());

            case 4:
              _context10.next = 6;
              return regeneratorRuntime.awrap(this.pretransform());

            case 6:
              _context10.next = 8;
              return regeneratorRuntime.awrap(this.getDependencies());

            case 8:
              _context10.next = 10;
              return regeneratorRuntime.awrap(this.transform());

            case 10:
              _context10.next = 12;
              return regeneratorRuntime.awrap(this.generate());

            case 12:
              this.generated = _context10.sent;

            case 13:
              return _context10.abrupt("return", this.generated);

            case 14:
            case "end":
              return _context10.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "postProcess",
    value: function postProcess(generated) {
      return regeneratorRuntime.async(function postProcess$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", generated);

            case 1:
            case "end":
              return _context11.stop();
          }
        }
      });
    }
  }, {
    key: "generateHash",
    value: function generateHash() {
      return objectHash(this.generated);
    }
  }, {
    key: "invalidate",
    value: function invalidate() {
      this.processed = false;
      this.contents = null;
      this.ast = null;
      this.generated = null;
      this.hash = null;
      this.dependencies.clear();
      this.depAssets.clear();
    }
  }, {
    key: "invalidateBundle",
    value: function invalidateBundle() {
      this.parentBundle = null;
      this.bundles.clear();
      this.parentDeps.clear();
    }
  }, {
    key: "generateBundleName",
    value: function generateBundleName() {
      // Generate a unique name. This will be replaced with a nicer
      // name later as part of content hashing.
      return md5(this.relativeName) + '.' + this.type;
    }
  }, {
    key: "replaceBundleNames",
    value: function replaceBundleNames(bundleNameMap) {
      var copied = false;

      for (var key in this.generated) {
        var value = this.generated[key];

        if (typeof value === 'string') {
          // Replace temporary bundle names in the output with the final content-hashed names.
          var newValue = value;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = bundleNameMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  name = _step$value[0],
                  map = _step$value[1];

              newValue = newValue.split(name).join(map);
            } // Copy `this.generated` on write so we don't end up writing the final names to the cache.

          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (newValue !== value && !copied) {
            this.generated = Object.assign({}, this.generated);
            copied = true;
          }

          this.generated[key] = newValue;
        }
      }
    }
  }, {
    key: "generateErrorMessage",
    value: function generateErrorMessage(err) {
      return err;
    }
  }, {
    key: "package",
    get: function get() {
      logger.warn('`asset.package` is deprecated. Please use `await asset.getPackage()` instead.');
      return syncPromise(this.getPackage());
    }
  }]);

  return Asset;
}();

module.exports = Asset;