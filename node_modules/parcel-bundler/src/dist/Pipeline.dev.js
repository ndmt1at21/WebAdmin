"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Parser = require('./Parser');

var path = require('path');

var _require = require('@parcel/utils'),
    errorUtils = _require.errorUtils;
/**
 * A Pipeline composes multiple Asset types together.
 */


var Pipeline =
/*#__PURE__*/
function () {
  function Pipeline(options) {
    _classCallCheck(this, Pipeline);

    this.options = options;
    this.parser = new Parser(options);
  }

  _createClass(Pipeline, [{
    key: "process",
    value: function process(path, isWarmUp) {
      var options, asset, error, generatedMap, generated, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, rendition;

      return regeneratorRuntime.async(function process$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = this.options;

              if (isWarmUp) {
                options = Object.assign({
                  isWarmUp: isWarmUp
                }, options);
              }

              asset = this.parser.getAsset(path, options);
              error = null;
              generatedMap = {};
              _context.prev = 5;
              _context.next = 8;
              return regeneratorRuntime.awrap(this.processAsset(asset));

            case 8:
              generated = _context.sent;
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 12;

              for (_iterator = generated[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                rendition = _step.value;
                generatedMap[rendition.type] = rendition.value;
              }

              _context.next = 20;
              break;

            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](12);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 20:
              _context.prev = 20;
              _context.prev = 21;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 23:
              _context.prev = 23;

              if (!_didIteratorError) {
                _context.next = 26;
                break;
              }

              throw _iteratorError;

            case 26:
              return _context.finish(23);

            case 27:
              return _context.finish(20);

            case 28:
              _context.next = 34;
              break;

            case 30:
              _context.prev = 30;
              _context.t1 = _context["catch"](5);
              error = errorUtils.errorToJson(_context.t1);
              error.fileName = path;

            case 34:
              return _context.abrupt("return", {
                id: asset.id,
                dependencies: Array.from(asset.dependencies.values()),
                generated: generatedMap,
                sourceMaps: asset.sourceMaps,
                error: error,
                hash: asset.hash,
                cacheData: asset.cacheData
              });

            case 35:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[5, 30], [12, 16, 20, 28], [21,, 23, 27]]);
    }
  }, {
    key: "processAsset",
    value: function processAsset(asset) {
      var inputType, generated, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, rendition, type, value, AssetType, opts, subAsset, processed, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, res, hasMap, sourceMaps, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _rendition;

      return regeneratorRuntime.async(function processAsset$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return regeneratorRuntime.awrap(asset.process());

            case 3:
              _context2.next = 8;
              break;

            case 5:
              _context2.prev = 5;
              _context2.t0 = _context2["catch"](0);
              throw asset.generateErrorMessage(_context2.t0);

            case 8:
              inputType = path.extname(asset.name).slice(1);
              generated = [];
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context2.prev = 13;
              _iterator2 = this.iterateRenditions(asset)[Symbol.iterator]();

            case 15:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context2.next = 59;
                break;
              }

              rendition = _step2.value;
              type = rendition.type, value = rendition.value;

              if (!(typeof value !== 'string' || rendition["final"])) {
                _context2.next = 21;
                break;
              }

              generated.push(rendition);
              return _context2.abrupt("continue", 56);

            case 21:
              // Find an asset type for the rendition type.
              // If the asset is not already an instance of this asset type, process it.
              AssetType = this.parser.findParser(asset.name.slice(0, -inputType.length) + type, true);

              if (asset instanceof AssetType) {
                _context2.next = 55;
                break;
              }

              opts = Object.assign({}, asset.options, {
                rendition: rendition
              });
              subAsset = new AssetType(asset.name, opts);
              subAsset.id = asset.id;
              subAsset.contents = value;
              subAsset.dependencies = asset.dependencies;
              subAsset.cacheData = Object.assign(asset.cacheData, subAsset.cacheData);
              _context2.next = 31;
              return regeneratorRuntime.awrap(this.processAsset(subAsset));

            case 31:
              processed = _context2.sent;

              if (!rendition.meta) {
                _context2.next = 52;
                break;
              }

              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context2.prev = 36;

              for (_iterator4 = processed[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                res = _step4.value;
                res.meta = rendition.meta;
                res.isMain = res.type === subAsset.type;
              }

              _context2.next = 44;
              break;

            case 40:
              _context2.prev = 40;
              _context2.t1 = _context2["catch"](36);
              _didIteratorError4 = true;
              _iteratorError4 = _context2.t1;

            case 44:
              _context2.prev = 44;
              _context2.prev = 45;

              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }

            case 47:
              _context2.prev = 47;

              if (!_didIteratorError4) {
                _context2.next = 50;
                break;
              }

              throw _iteratorError4;

            case 50:
              return _context2.finish(47);

            case 51:
              return _context2.finish(44);

            case 52:
              generated = generated.concat(processed);
              _context2.next = 56;
              break;

            case 55:
              generated.push(rendition);

            case 56:
              _iteratorNormalCompletion2 = true;
              _context2.next = 15;
              break;

            case 59:
              _context2.next = 65;
              break;

            case 61:
              _context2.prev = 61;
              _context2.t2 = _context2["catch"](13);
              _didIteratorError2 = true;
              _iteratorError2 = _context2.t2;

            case 65:
              _context2.prev = 65;
              _context2.prev = 66;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 68:
              _context2.prev = 68;

              if (!_didIteratorError2) {
                _context2.next = 71;
                break;
              }

              throw _iteratorError2;

            case 71:
              return _context2.finish(68);

            case 72:
              return _context2.finish(65);

            case 73:
              _context2.prev = 73;
              _context2.next = 76;
              return regeneratorRuntime.awrap(asset.postProcess(generated));

            case 76:
              generated = _context2.sent;
              _context2.next = 82;
              break;

            case 79:
              _context2.prev = 79;
              _context2.t3 = _context2["catch"](73);
              throw asset.generateErrorMessage(_context2.t3);

            case 82:
              hasMap = false;
              sourceMaps = {};
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context2.prev = 87;

              for (_iterator3 = generated[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                _rendition = _step3.value;

                if (_rendition.map && _rendition.type == asset.type) {
                  sourceMaps[_rendition.type] = _rendition.map;
                  hasMap = true;
                }
              }

              _context2.next = 95;
              break;

            case 91:
              _context2.prev = 91;
              _context2.t4 = _context2["catch"](87);
              _didIteratorError3 = true;
              _iteratorError3 = _context2.t4;

            case 95:
              _context2.prev = 95;
              _context2.prev = 96;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 98:
              _context2.prev = 98;

              if (!_didIteratorError3) {
                _context2.next = 101;
                break;
              }

              throw _iteratorError3;

            case 101:
              return _context2.finish(98);

            case 102:
              return _context2.finish(95);

            case 103:
              if (hasMap) {
                asset.sourceMaps = sourceMaps;
              }

              asset.generated = generated;
              _context2.next = 107;
              return regeneratorRuntime.awrap(asset.generateHash());

            case 107:
              asset.hash = _context2.sent;
              return _context2.abrupt("return", generated);

            case 109:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[0, 5], [13, 61, 65, 73], [36, 40, 44, 52], [45,, 47, 51], [66,, 68, 72], [73, 79], [87, 91, 95, 103], [96,, 98, 102]]);
    }
  }, {
    key: "iterateRenditions",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function iterateRenditions(asset) {
      var type;
      return regeneratorRuntime.wrap(function iterateRenditions$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!Array.isArray(asset.generated)) {
                _context3.next = 3;
                break;
              }

              return _context3.delegateYield(asset.generated, "t0", 2);

            case 2:
              return _context3.abrupt("return", _context3.t0);

            case 3:
              if (!(typeof asset.generated === 'string')) {
                _context3.next = 7;
                break;
              }

              _context3.next = 6;
              return {
                type: asset.type,
                value: asset.generated
              };

            case 6:
              return _context3.abrupt("return", _context3.sent);

            case 7:
              _context3.t1 = regeneratorRuntime.keys(asset.generated);

            case 8:
              if ((_context3.t2 = _context3.t1()).done) {
                _context3.next = 14;
                break;
              }

              type = _context3.t2.value;
              _context3.next = 12;
              return {
                type: type,
                value: asset.generated[type],
                // for scope hoisting, we need to post process all JS
                "final": !(type === 'js' && this.options.scopeHoist)
              };

            case 12:
              _context3.next = 8;
              break;

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, iterateRenditions, this);
    })
  }]);

  return Pipeline;
}();

module.exports = Pipeline;