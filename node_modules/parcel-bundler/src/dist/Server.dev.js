"use strict";

var http = require('http');

var https = require('https');

var serveStatic = require('serve-static');

var getPort = require('get-port');

var serverErrors = require('./utils/customErrors').serverErrors;

var generateCertificate = require('./utils/generateCertificate');

var getCertificate = require('./utils/getCertificate');

var AnsiToHtml = require('ansi-to-html');

var logger = require('@parcel/logger');

var path = require('path');

var url = require('url');

var ansiToHtml = new AnsiToHtml({
  newline: true
});
serveStatic.mime.define({
  'application/wasm': ['wasm']
});

function setHeaders(res) {
  enableCors(res);
}

function enableCors(res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, PUT, PATCH, POST, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Content-Type');
}

function middleware(bundler) {
  var serve = serveStatic(bundler.options.outDir, {
    index: false,
    redirect: false,
    setHeaders: setHeaders,
    dotfiles: 'allow'
  });
  return function (req, res, next) {
    logAccessIfVerbose(); // Wait for the bundler to finish bundling if needed

    if (bundler.pending) {
      bundler.once('bundled', respond);
    } else {
      respond();
    }

    function respond() {
      var _url$parse = url.parse(req.url),
          pathname = _url$parse.pathname;

      if (bundler.error) {
        return send500(bundler.error);
      } else if (!pathname.startsWith(bundler.options.publicURL) || path.extname(pathname) === '') {
        // If the URL doesn't start with the public path, or the URL doesn't
        // have a file extension, send the main HTML bundle.
        return sendIndex();
      } else {
        // Otherwise, serve the file from the dist folder
        req.url = pathname.slice(bundler.options.publicURL.length);
        return serve(req, res, sendIndex);
      }
    }

    function sendIndex() {
      // If the main asset is an HTML file, serve it
      if (bundler.mainBundle.type === 'html') {
        req.url = "/".concat(path.basename(bundler.mainBundle.name));
        serve(req, res, send404);
      } else {
        send404();
      }
    }

    function send500(error) {
      setHeaders(res);
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.writeHead(500);
      var errorMesssge = '<h1>ðŸš¨ Build Error</h1>';

      if (process.env.NODE_ENV === 'production') {
        errorMesssge += '<p><b>Check the console for details.</b></p>';
      } else {
        var _logger$formatError = logger.formatError(error, {
          color: true
        }),
            message = _logger$formatError.message,
            stack = _logger$formatError.stack;

        errorMesssge += "<p><b>".concat(message, "</b></p>");

        if (stack) {
          errorMesssge += "<div style=\"background: black; padding: 1rem;\">".concat(ansiToHtml.toHtml(stack), "</div>");
        }
      }

      res.end(["<!doctype html>", "<head><title>\uD83D\uDEA8 Build Error</title></head>", "<body style=\"font-family: monospace; white-space: pre;\">".concat(errorMesssge, "</body>")].join(''));
    }

    function send404() {
      if (next) {
        return next();
      }

      setHeaders(res);
      res.writeHead(404);
      res.end();
    }

    function logAccessIfVerbose() {
      var protocol = req.connection.encrypted ? 'https' : 'http';
      var fullUrl = "".concat(protocol, "://").concat(req.headers.host).concat(req.url);
      logger.verbose("Request: ".concat(fullUrl));
    }
  };
}

function serve(bundler, port, host) {
  var useHTTPS,
      handler,
      server,
      freePort,
      _args = arguments;
  return regeneratorRuntime.async(function serve$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          useHTTPS = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
          handler = middleware(bundler);

          if (useHTTPS) {
            _context.next = 6;
            break;
          }

          server = http.createServer(handler);
          _context.next = 16;
          break;

        case 6:
          if (!(typeof useHTTPS === 'boolean')) {
            _context.next = 10;
            break;
          }

          server = https.createServer(generateCertificate(bundler.options), handler);
          _context.next = 16;
          break;

        case 10:
          _context.t0 = https;
          _context.next = 13;
          return regeneratorRuntime.awrap(getCertificate(useHTTPS));

        case 13:
          _context.t1 = _context.sent;
          _context.t2 = handler;
          server = _context.t0.createServer.call(_context.t0, _context.t1, _context.t2);

        case 16:
          _context.next = 18;
          return regeneratorRuntime.awrap(getPort({
            port: port
          }));

        case 18:
          freePort = _context.sent;
          server.listen(freePort, host);
          return _context.abrupt("return", new Promise(function (resolve, reject) {
            server.on('error', function (err) {
              console.log(err);
              logger.error(new Error(serverErrors(err, server.address().port)));
              reject(err);
            });
            server.once('listening', function () {
              var addon = server.address().port !== port ? "- ".concat(logger.chalk.yellow("configured port ".concat(port, " could not be used."))) : '';
              logger.persistent("Server running at ".concat(logger.chalk.cyan("".concat(useHTTPS ? 'https' : 'http', "://").concat(host || 'localhost', ":").concat(server.address().port)), " ").concat(addon));
              resolve(server);
            });
          }));

        case 21:
        case "end":
          return _context.stop();
      }
    }
  });
}

exports.middleware = middleware;
exports.serve = serve;