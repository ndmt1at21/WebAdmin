"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Asset = require('../Asset');

var localRequire = require('../utils/localRequire');

var _require = require('@parcel/utils'),
    promisify = _require.promisify;

var path = require('path');

var os = require('os');

var Resolver = require('../Resolver');

var parseCSSImport = require('../utils/parseCSSImport');

var SASSAsset =
/*#__PURE__*/
function (_Asset) {
  _inherits(SASSAsset, _Asset);

  function SASSAsset(name, options) {
    var _this;

    _classCallCheck(this, SASSAsset);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SASSAsset).call(this, name, options));
    _this.type = 'css';
    return _this;
  }

  _createClass(SASSAsset, [{
    key: "parse",
    value: function parse(code) {
      var _this2 = this;

      var sass, render, resolver, opts, type;
      return regeneratorRuntime.async(function parse$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return regeneratorRuntime.awrap(getSassRuntime(this.name));

            case 2:
              sass = _context.sent;
              render = promisify(sass.render.bind(sass));
              resolver = new Resolver({
                extensions: ['.scss', '.sass'],
                rootDir: this.options.rootDir
              });
              _context.next = 7;
              return regeneratorRuntime.awrap(this.getConfig(['.sassrc', '.sassrc.js'], {
                packageKey: 'sass'
              }));

            case 7:
              _context.t0 = _context.sent;

              if (_context.t0) {
                _context.next = 10;
                break;
              }

              _context.t0 = {};

            case 10:
              opts = _context.t0;
              opts.includePaths = (opts.includePaths ? opts.includePaths.map(function (includePath) {
                return path.resolve(includePath);
              }) : []).concat(path.dirname(this.name));
              opts.data = opts.data ? opts.data + os.EOL + code : code;
              type = this.options.rendition ? this.options.rendition.type : path.extname(this.name).toLowerCase().replace('.', '');
              opts.indentedSyntax = typeof opts.indentedSyntax === 'boolean' ? opts.indentedSyntax : type === 'sass';
              opts.importer = opts.importer || [];
              opts.importer = Array.isArray(opts.importer) ? opts.importer : [opts.importer];
              opts.importer.push(function (url, prev, done) {
                url = url.replace(/^file:\/\//, '');
                url = parseCSSImport(url);
                resolver.resolve(url, prev === 'stdin' ? _this2.name : prev).then(function (resolved) {
                  return resolved.path;
                })["catch"](function () {
                  return url;
                }).then(function (file) {
                  return done({
                    file: file
                  });
                })["catch"](function (err) {
                  return done(normalizeError(err));
                });
              });

              if (this.options.sourceMaps) {
                opts.sourceMap = true;
                opts.file = this.name;
                opts.outFile = this.name;
                opts.omitSourceMapUrl = true;
                opts.sourceMapContents = true;
              }

              _context.prev = 19;
              _context.next = 22;
              return regeneratorRuntime.awrap(render(opts));

            case 22:
              return _context.abrupt("return", _context.sent);

            case 25:
              _context.prev = 25;
              _context.t1 = _context["catch"](19);

              if (!_context.t1.formatted) {
                _context.next = 29;
                break;
              }

              throw sassToCodeFrame(_context.t1);

            case 29:
              throw _context.t1;

            case 30:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[19, 25]]);
    }
  }, {
    key: "collectDependencies",
    value: function collectDependencies() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.ast.stats.includedFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dep = _step.value;
          this.addDependency(dep, {
            includedInParent: true
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "generate",
    value: function generate() {
      return [{
        type: 'css',
        value: this.ast ? this.ast.css.toString() : '',
        map: this.ast && this.ast.map ? JSON.parse(this.ast.map.toString()) : undefined
      }];
    }
  }]);

  return SASSAsset;
}(Asset);

module.exports = SASSAsset;

function getSassRuntime(searchPath) {
  return regeneratorRuntime.async(function getSassRuntime$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _context2.next = 3;
          return regeneratorRuntime.awrap(localRequire('node-sass', searchPath, true));

        case 3:
          return _context2.abrupt("return", _context2.sent);

        case 6:
          _context2.prev = 6;
          _context2.t0 = _context2["catch"](0);
          return _context2.abrupt("return", localRequire('sass', searchPath));

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[0, 6]]);
}

function sassToCodeFrame(err) {
  var error = new Error(err.message);
  error.codeFrame = err.formatted;
  error.stack = err.stack;
  error.fileName = err.file;
  error.loc = {
    line: err.line,
    column: err.column
  };
  return error;
} // Ensures an error inherits from Error


function normalizeError(err) {
  var message = 'Unknown error';

  if (err) {
    if (err instanceof Error) {
      return err;
    }

    message = err.stack || err.message || err;
  }

  return new Error(message);
}