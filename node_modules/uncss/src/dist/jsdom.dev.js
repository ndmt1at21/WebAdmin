'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var fs = require('fs'),
    isHTML = require('is-html'),
    isURL = require('is-absolute-url'),
    _require = require('jsdom'),
    JSDOM = _require.JSDOM,
    ResourceLoader = _require.ResourceLoader,
    VirtualConsole = _require.VirtualConsole,
    path = require('path'),
    _require2 = require('console'),
    Console = _require2.Console,
    _ = require('lodash');
/**
 * Jsdom expects promises returned by ResourceLoader.fetch to have an 'abort' method.
 * @param {Promise} promise The promise to augment.
 */


function makeResourcePromise(promise) {
  promise.abort = function () {
    /* noop */
  };

  return promise;
}

var CustomResourcesLoader =
/*#__PURE__*/
function (_ResourceLoader) {
  _inherits(CustomResourcesLoader, _ResourceLoader);

  function CustomResourcesLoader(htmlroot, strictSSL, userAgent) {
    var _this;

    _classCallCheck(this, CustomResourcesLoader);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CustomResourcesLoader).call(this, {
      strictSSL: strictSSL,
      userAgent: userAgent
    })); // The htmlroot option allows root-relative URLs (starting with a slash)
    // to be used for all resources. Without it, root-relative URLs are
    // looked up relative to file://, so will not be found.

    _this.htmlroot = htmlroot || '';
    return _this;
  }

  _createClass(CustomResourcesLoader, [{
    key: "fetch",
    value: function fetch(originalUrl, options) {
      var element = options && options.element;

      if (!element) {
        // HTTP request?
        return _get(_getPrototypeOf(CustomResourcesLoader.prototype), "fetch", this).call(this, originalUrl, options);
      }

      if (!element || element.nodeName !== 'SCRIPT') {
        // Only scripts need to be fetched. Stylesheets are read later by uncss.
        return makeResourcePromise(Promise.resolve(Buffer.from('')));
      } // See whether raw attribute value is root-relative.


      var src = element.getAttribute('src');

      if (src && path.isAbsolute(src)) {
        var url = path.join(this.htmlroot, src);
        return makeResourcePromise(new Promise(function (resolve, reject) {
          try {
            var buffer = fs.readFileSync(url);
            resolve(buffer);
          } catch (e) {
            reject(e);
          }
        }));
      }

      return _get(_getPrototypeOf(CustomResourcesLoader.prototype), "fetch", this).call(this, originalUrl, options);
    }
  }]);

  return CustomResourcesLoader;
}(ResourceLoader);

function defaultOptions() {
  return {
    features: {
      FetchExternalResources: ['script'],
      ProcessExternalResources: ['script']
    },
    runScripts: 'dangerously',
    userAgent: 'uncss',
    virtualConsole: new VirtualConsole().sendTo(new Console(process.stderr))
  };
}
/**
 * Load a page.
 * @param  {String}  src
 * @param  {Object}  options
 * @return {Promise<JSDOM>}
 */


function fromSource(src, options) {
  var config = _.cloneDeep(options.jsdom);

  config.resources = new CustomResourcesLoader(options.htmlroot, options.strictSSL, options.userAgent);
  return new Promise(function (resolve, reject) {
    var pagePromise;

    if (isURL(src)) {
      pagePromise = JSDOM.fromURL(src, config);
    } else if (isHTML(src)) {
      pagePromise = Promise.resolve(new JSDOM(src, config));
    } else {
      pagePromise = JSDOM.fromFile(src, config);
    }

    return pagePromise.then(function (page) {
      if (options.inject) {
        if (typeof options.inject === 'function') {
          options.inject(page.window);
        } else {
          require(path.join(__dirname, options.inject))(page.window);
        }
      }

      setTimeout(function () {
        return resolve(page);
      }, options.timeout);
    })["catch"](function (e) {
      reject(e);
    });
  });
}
/**
 * Extract stylesheets' hrefs from dom
 * @param  {Object}  window     A jsdom window
 * @param  {Object}  options    Options, as passed to UnCSS
 * @return {Array}
 */


function getStylesheets(window, options) {
  if (Array.isArray(options.media) === false) {
    options.media = [options.media];
  }

  var media = _.union(['', 'all', 'screen'], options.media);

  var elements = window.document.querySelectorAll('link[rel="stylesheet"]');
  return Array.prototype.map.call(elements, function (link) {
    return {
      href: link.getAttribute('href'),
      media: link.getAttribute('media') || ''
    };
  }).filter(function (sheet) {
    return media.indexOf(sheet.media) !== -1;
  }).map(function (sheet) {
    return sheet.href;
  });
}
/**
 * Filter unused selectors.
 * @param  {Object}  window A jsdom window
 * @param  {Array}   sels   List of selectors to be filtered
 * @return {Array}
 */


function findAll(window, sels) {
  var document = window.document; // Unwrap noscript elements.

  var elements = document.getElementsByTagName('noscript');
  Array.prototype.forEach.call(elements, function (ns) {
    var wrapper = document.createElement('div');
    wrapper.innerHTML = ns.textContent; // Insert each child of the <noscript> as its sibling

    Array.prototype.forEach.call(wrapper.children, function (child) {
      ns.parentNode.insertBefore(child, ns);
    });
  }); // Do the filtering.

  return sels.filter(function (selector) {
    try {
      return document.querySelector(selector);
    } catch (e) {
      return true;
    }
  });
}

module.exports = {
  defaultOptions: defaultOptions,
  fromSource: fromSource,
  findAll: findAll,
  getStylesheets: getStylesheets
};