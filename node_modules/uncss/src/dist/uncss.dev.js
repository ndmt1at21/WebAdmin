'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var glob = require('glob'),
    isHTML = require('is-html'),
    isURL = require('is-absolute-url'),
    jsdom = require('./jsdom.js'),
    postcss = require('postcss'),
    uncss = require('./lib.js'),
    utility = require('./utility.js'),
    _ = require('lodash');
/**
 * Get the contents of HTML pages through jsdom.
 * @param  {Array}   files   List of HTML files
 * @param  {Object}  options UnCSS options
 * @return {Array|Promise}
 */


function getHTML(files, options) {
  if (_.isString(files)) {
    files = [files];
  }

  files = _.flatten(files.map(function (file) {
    if (!isURL(file) && !isHTML(file)) {
      return glob.sync(file);
    }

    return file;
  }));

  if (!files.length) {
    return Promise.reject(new Error('UnCSS: no HTML files found'));
  } // Save files for later reference.


  options.files = files;
  return Promise.all(files.map(function (file) {
    return jsdom.fromSource(file, options);
  }));
}
/**
 * Get the contents of CSS files.
 * @param  {Array}   files   List of HTML files
 * @param  {Object}  options UnCSS options
 * @param  {Array}   pages   Pages opened by jsdom
 * @return {Promise}
 */


function getStylesheets(files, options, pages) {
  if (options.stylesheets && options.stylesheets.length) {
    /* Simulate the behavior below */
    return Promise.resolve([files, options, pages, [options.stylesheets]]);
  }
  /* Extract the stylesheets from the HTML */


  return Promise.all(pages.map(function (page) {
    return jsdom.getStylesheets(page.window, options);
  })).then(function (stylesheets) {
    return [files, options, pages, stylesheets];
  });
}
/**
 * Get the contents of CSS files.
 * @param  {Array}   files       List of HTML files
 * @param  {Object}  options     UnCSS options
 * @param  {Array}   pages       Pages opened by jsdom
 * @param  {Array}   stylesheets List of CSS files
 * @return {Array}
 */


function getCSS(_ref) {
  var _ref2 = _slicedToArray(_ref, 4),
      files = _ref2[0],
      options = _ref2[1],
      pages = _ref2[2],
      stylesheets = _ref2[3];

  /* Ignore specified stylesheets */
  if (options.ignoreSheets.length) {
    stylesheets = stylesheets.map(function (arr) {
      return arr.filter(function (sheet) {
        return _.every(options.ignoreSheets, function (ignore) {
          if (_.isRegExp(ignore)) {
            return !ignore.test(sheet);
          }

          return sheet !== ignore;
        });
      });
    });
  }

  if (_.flatten(stylesheets).length) {
    /* Only run this if we found links to stylesheets (there may be none...)
     *  files       = ['some_file.html', 'some_other_file.html']
     *  stylesheets = [['relative_css_path.css', ...],
     *                 ['maybe_a_duplicate.css', ...]]
     * We need to - make the stylesheets' paths relative to the HTML files,
     *            - flatten the array,
     *            - remove duplicates
     */
    stylesheets = _.chain(stylesheets).map(function (sheets, i) {
      return utility.parsePaths(files[i], sheets, options);
    }).flatten().uniq().value();
  } else {
    /* Reset the array if we didn't find any link tags */
    stylesheets = [];
  }

  return Promise.all([options, pages, utility.readStylesheets(stylesheets, options.banner)]);
}
/**
 * Do the actual work
 * @param  {Array}   files       List of HTML files
 * @param  {Object}  options     UnCSS options
 * @param  {Array}   pages       Pages opened by jsdom
 * @param  {Array}   stylesheets List of CSS files
 * @return {Promise}
 */


function processWithTextApi(_ref3) {
  var _ref4 = _slicedToArray(_ref3, 3),
      options = _ref4[0],
      pages = _ref4[1],
      stylesheets = _ref4[2];

  /* If we specified a raw string of CSS, add it to the stylesheets array */
  if (options.raw) {
    if (_.isString(options.raw)) {
      stylesheets.push(options.raw);
    } else {
      throw new Error('UnCSS: options.raw - expected a string');
    }
  }
  /* At this point, there isn't any point in running the rest of the task if:
   * - We didn't specify any stylesheet links in the options object
   * - We couldn't find any stylesheet links in the HTML itself
   * - We weren't passed a string of raw CSS in addition to, or to replace
   *     either of the above
   */


  if (!_.flatten(stylesheets).length) {
    throw new Error('UnCSS: no stylesheets found');
  }
  /* OK, so we have some CSS to work with!
   * Three steps:
   * - Parse the CSS
   * - Remove the unused rules
   * - Return the optimized CSS as a string
   */


  var cssStr = stylesheets.join(' \n');
  var pcss, report;

  try {
    pcss = postcss.parse(cssStr);
  } catch (err) {
    /* Try and construct a helpful error message */
    throw utility.parseErrorMessage(err, cssStr);
  }

  return uncss(pages, pcss, options.ignore).then(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        css = _ref6[0],
        rep = _ref6[1];

    var newCssStr = '';
    postcss.stringify(css, function (result) {
      newCssStr += result;
    });

    if (options.report) {
      report = {
        original: cssStr,
        selectors: rep
      };
    }

    return [newCssStr, report];
  });
}
/**
 * Main exposed function.
 * Here we check the options and callback, then run the files through jsdom.
 * @param  {Array}    files     Array of filenames
 * @param  {Object}   [options] options
 * @param  {Function} callback(Error, String, Object)
 */


function init(files, options, callback) {
  if (_.isFunction(options)) {
    /* There were no options, this argument is actually the callback */
    callback = options;
    options = {};
  } else if (!_.isFunction(callback)) {
    throw new TypeError('UnCSS: expected a callback');
  }
  /* Try and read options from the specified uncssrc file */


  if (options.uncssrc) {
    try {
      /* Manually-specified options take precedence over uncssrc options */
      options = _.merge(utility.parseUncssrc(options.uncssrc), options);
    } catch (err) {
      if (err instanceof SyntaxError) {
        callback(new SyntaxError('UnCSS: uncssrc file is invalid JSON.'));
        return;
      }

      callback(err);
      return;
    }
  }
  /* Assign default values to options, unless specified */


  options = _.merge({
    banner: true,
    csspath: '',
    html: files,
    htmlRoot: null,
    ignore: [],
    ignoreSheets: [],
    inject: null,
    jsdom: jsdom.defaultOptions(),
    media: [],
    raw: null,
    report: false,
    stylesheets: null,
    timeout: 0,
    uncssrc: null,
    userAgent: 'uncss'
  }, options);
  process(options).then(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        css = _ref8[0],
        report = _ref8[1];

    return callback(null, css, report);
  }, callback);
}

function processAsPostCss(options, pages) {
  return uncss(pages, options.rawPostCss, options.ignore);
}

function process(opts) {
  return getHTML(opts.html, opts).then(function (pages) {
    function cleanup(result) {
      pages.forEach(function (page) {
        return page.window.close();
      });
      return result;
    }

    if (opts.usePostCssInternal) {
      return processAsPostCss(opts, pages).then(cleanup);
    }

    return getStylesheets(opts.files, opts, pages).then(getCSS).then(processWithTextApi).then(cleanup);
  });
}

var postcssPlugin = postcss.plugin('uncss', function (opts) {
  var options = _.merge({
    usePostCssInternal: true,
    // Ignore stylesheets in the HTML files; only use those from the stream
    ignoreSheets: [/\s*/],
    html: [],
    ignore: [],
    jsdom: jsdom.defaultOptions()
  }, opts);

  return function (css, result) {
    // eslint-disable-line no-unused-vars
    options = _.merge(options, {
      // This is used to pass the css object in to processAsPostCSS
      rawPostCss: css
    });
    return process(options);
  };
});
module.exports = init;
module.exports.postcssPlugin = postcssPlugin;