'use strict'; // Do a two-pass walk, first to get the list of packages that need to be
// bundled, then again to get the actual files and folders.
// Keep a cache of node_modules content and package.json data, so that the
// second walk doesn't have to re-do all the same work.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var bundleWalk = require('npm-bundled');

var BundleWalker = bundleWalk.BundleWalker;
var BundleWalkerSync = bundleWalk.BundleWalkerSync;

var ignoreWalk = require('ignore-walk');

var IgnoreWalker = ignoreWalk.Walker;
var IgnoreWalkerSync = ignoreWalk.WalkerSync;
var rootBuiltinRules = Symbol('root-builtin-rules');
var packageNecessaryRules = Symbol('package-necessary-rules');

var path = require('path');

var normalizePackageBin = require('npm-normalize-package-bin');

var defaultRules = ['.npmignore', '.gitignore', '**/.git', '**/.svn', '**/.hg', '**/CVS', '**/.git/**', '**/.svn/**', '**/.hg/**', '**/CVS/**', '/.lock-wscript', '/.wafpickle-*', '/build/config.gypi', 'npm-debug.log', '**/.npmrc', '.*.swp', '.DS_Store', '**/.DS_Store/**', '._*', '**/._*/**', '*.orig', '/package-lock.json', '/yarn.lock', 'archived-packages/**', 'core', '!core/', '!**/core/', '*.core', '*.vgcore', 'vgcore.*', 'core.+([0-9])']; // There may be others, but :?|<> are handled by node-tar

var nameIsBadForWindows = function nameIsBadForWindows(file) {
  return /\*/.test(file);
}; // a decorator that applies our custom rules to an ignore walker


var npmWalker = function npmWalker(Class) {
  return (
    /*#__PURE__*/
    function (_Class) {
      _inherits(Walker, _Class);

      function Walker(opt) {
        var _this;

        _classCallCheck(this, Walker);

        opt = opt || {}; // the order in which rules are applied.

        opt.ignoreFiles = [rootBuiltinRules, 'package.json', '.npmignore', '.gitignore', packageNecessaryRules];
        opt.includeEmpty = false;
        opt.path = opt.path || process.cwd();
        var dirName = path.basename(opt.path);
        var parentName = path.basename(path.dirname(opt.path));
        opt.follow = dirName === 'node_modules' || parentName === 'node_modules' && /^@/.test(dirName);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Walker).call(this, opt)); // ignore a bunch of things by default at the root level.
        // also ignore anything in node_modules, except bundled dependencies

        if (!_this.parent) {
          _this.bundled = opt.bundled || [];
          _this.bundledScopes = Array.from(new Set(_this.bundled.filter(function (f) {
            return /^@/.test(f);
          }).map(function (f) {
            return f.split('/')[0];
          })));
          var rules = defaultRules.join('\n') + '\n';
          _this.packageJsonCache = opt.packageJsonCache || new Map();

          _get(_getPrototypeOf(Walker.prototype), "onReadIgnoreFile", _assertThisInitialized(_this)).call(_assertThisInitialized(_this), rootBuiltinRules, rules, function (_) {
            return _;
          });
        } else {
          _this.bundled = [];
          _this.bundledScopes = [];
          _this.packageJsonCache = _this.parent.packageJsonCache;
        }

        return _this;
      }

      _createClass(Walker, [{
        key: "onReaddir",
        value: function onReaddir(entries) {
          var _this2 = this;

          if (!this.parent) {
            entries = entries.filter(function (e) {
              return e !== '.git' && !(e === 'node_modules' && _this2.bundled.length === 0);
            });
          }

          return _get(_getPrototypeOf(Walker.prototype), "onReaddir", this).call(this, entries);
        }
      }, {
        key: "filterEntry",
        value: function filterEntry(entry, partial) {
          // get the partial path from the root of the walk
          var p = this.path.substr(this.root.length + 1);
          var pkgre = /^node_modules\/(@[^\/]+\/?[^\/]+|[^\/]+)(\/.*)?$/;
          var isRoot = !this.parent;
          var pkg = isRoot && pkgre.test(entry) ? entry.replace(pkgre, '$1') : null;
          var rootNM = isRoot && entry === 'node_modules';
          var rootPJ = isRoot && entry === 'package.json';
          return (// if we're in a bundled package, check with the parent.
            /^node_modules($|\/)/i.test(p) ? this.parent.filterEntry(this.basename + '/' + entry, partial) // if package is bundled, all files included
            // also include @scope dirs for bundled scoped deps
            // they'll be ignored if no files end up in them.
            // However, this only matters if we're in the root.
            // node_modules folders elsewhere, like lib/node_modules,
            // should be included normally unless ignored.
            : pkg ? -1 !== this.bundled.indexOf(pkg) || -1 !== this.bundledScopes.indexOf(pkg) // only walk top node_modules if we want to bundle something
            : rootNM ? !!this.bundled.length // always include package.json at the root.
            : rootPJ ? true // otherwise, follow ignore-walk's logic
            : _get(_getPrototypeOf(Walker.prototype), "filterEntry", this).call(this, entry, partial)
          );
        }
      }, {
        key: "filterEntries",
        value: function filterEntries() {
          if (this.ignoreRules['package.json']) this.ignoreRules['.gitignore'] = this.ignoreRules['.npmignore'] = null;else if (this.ignoreRules['.npmignore']) this.ignoreRules['.gitignore'] = null;
          this.filterEntries = _get(_getPrototypeOf(Walker.prototype), "filterEntries", this);

          _get(_getPrototypeOf(Walker.prototype), "filterEntries", this).call(this);
        }
      }, {
        key: "addIgnoreFile",
        value: function addIgnoreFile(file, then) {
          var ig = path.resolve(this.path, file);
          if (this.packageJsonCache.has(ig)) this.onPackageJson(ig, this.packageJsonCache.get(ig), then);else _get(_getPrototypeOf(Walker.prototype), "addIgnoreFile", this).call(this, file, then);
        }
      }, {
        key: "onPackageJson",
        value: function onPackageJson(ig, pkg, then) {
          this.packageJsonCache.set(ig, pkg); // if there's a bin, browser or main, make sure we don't ignore it
          // also, don't ignore the package.json itself!
          //
          // Weird side-effect of this: a readme (etc) file will be included
          // if it exists anywhere within a folder with a package.json file.
          // The original intent was only to include these files in the root,
          // but now users in the wild are dependent on that behavior for
          // localized documentation and other use cases.  Adding a `/` to
          // these rules, while tempting and arguably more "correct", is a
          // breaking change.

          var rules = [pkg.browser ? '!' + pkg.browser : '', pkg.main ? '!' + pkg.main : '', '!package.json', '!npm-shrinkwrap.json', '!@(readme|copying|license|licence|notice|changes|changelog|history){,.*[^~$]}'];

          if (pkg.bin) {
            // always an object, because normalized already
            for (var key in pkg.bin) {
              rules.push('!' + pkg.bin[key]);
            }
          }

          var data = rules.filter(function (f) {
            return f;
          }).join('\n') + '\n';

          _get(_getPrototypeOf(Walker.prototype), "onReadIgnoreFile", this).call(this, packageNecessaryRules, data, function (_) {
            return _;
          });

          if (Array.isArray(pkg.files)) _get(_getPrototypeOf(Walker.prototype), "onReadIgnoreFile", this).call(this, 'package.json', '*\n' + pkg.files.map(function (f) {
            return '!' + f + '\n!' + f.replace(/\/+$/, '') + '/**';
          }).join('\n') + '\n', then);else then();
        } // override parent stat function to completely skip any filenames
        // that will break windows entirely.
        // XXX(isaacs) Next major version should make this an error instead.

      }, {
        key: "stat",
        value: function stat(entry, file, dir, then) {
          if (nameIsBadForWindows(entry)) then();else _get(_getPrototypeOf(Walker.prototype), "stat", this).call(this, entry, file, dir, then);
        } // override parent onstat function to nix all symlinks

      }, {
        key: "onstat",
        value: function onstat(st, entry, file, dir, then) {
          if (st.isSymbolicLink()) then();else _get(_getPrototypeOf(Walker.prototype), "onstat", this).call(this, st, entry, file, dir, then);
        }
      }, {
        key: "onReadIgnoreFile",
        value: function onReadIgnoreFile(file, data, then) {
          if (file === 'package.json') try {
            var ig = path.resolve(this.path, file);
            this.onPackageJson(ig, normalizePackageBin(JSON.parse(data)), then);
          } catch (er) {
            // ignore package.json files that are not json
            then();
          } else _get(_getPrototypeOf(Walker.prototype), "onReadIgnoreFile", this).call(this, file, data, then);
        }
      }, {
        key: "sort",
        value: function sort(a, b) {
          return _sort(a, b);
        }
      }]);

      return Walker;
    }(Class)
  );
};

var Walker =
/*#__PURE__*/
function (_npmWalker) {
  _inherits(Walker, _npmWalker);

  function Walker() {
    _classCallCheck(this, Walker);

    return _possibleConstructorReturn(this, _getPrototypeOf(Walker).apply(this, arguments));
  }

  _createClass(Walker, [{
    key: "walker",
    value: function walker(entry, then) {
      new Walker(this.walkerOpt(entry)).on('done', then).start();
    }
  }]);

  return Walker;
}(npmWalker(IgnoreWalker));

var WalkerSync =
/*#__PURE__*/
function (_npmWalker2) {
  _inherits(WalkerSync, _npmWalker2);

  function WalkerSync() {
    _classCallCheck(this, WalkerSync);

    return _possibleConstructorReturn(this, _getPrototypeOf(WalkerSync).apply(this, arguments));
  }

  _createClass(WalkerSync, [{
    key: "walker",
    value: function walker(entry, then) {
      new WalkerSync(this.walkerOpt(entry)).start();
      then();
    }
  }]);

  return WalkerSync;
}(npmWalker(IgnoreWalkerSync));

var walk = function walk(options, callback) {
  options = options || {};
  var p = new Promise(function (resolve, reject) {
    var bw = new BundleWalker(options);
    bw.on('done', function (bundled) {
      options.bundled = bundled;
      options.packageJsonCache = bw.packageJsonCache;
      new Walker(options).on('done', resolve).on('error', reject).start();
    });
    bw.start();
  });
  return callback ? p.then(function (res) {
    return callback(null, res);
  }, callback) : p;
};

var walkSync = function walkSync(options) {
  options = options || {};
  var bw = new BundleWalkerSync(options).start();
  options.bundled = bw.result;
  options.packageJsonCache = bw.packageJsonCache;
  var walker = new WalkerSync(options);
  walker.start();
  return walker.result;
}; // optimize for compressibility
// extname, then basename, then locale alphabetically
// https://twitter.com/isntitvacant/status/1131094910923231232


var _sort = function _sort(a, b) {
  var exta = path.extname(a).toLowerCase();
  var extb = path.extname(b).toLowerCase();
  var basea = path.basename(a).toLowerCase();
  var baseb = path.basename(b).toLowerCase();
  return exta.localeCompare(extb) || basea.localeCompare(baseb) || a.localeCompare(b);
};

module.exports = walk;
walk.sync = walkSync;
walk.Walker = Walker;
walk.WalkerSync = WalkerSync;