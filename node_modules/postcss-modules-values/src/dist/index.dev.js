"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _postcss = _interopRequireDefault(require("postcss"));

var _icssReplaceSymbols = _interopRequireWildcard(require("icss-replace-symbols"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
var matchValueDefinition = /(?:\s+|^)([\w-]+):?\s+(.+?)\s*$/g;
var matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
var options = {};
var importIndex = 0;

var createImportedName = options && options.createImportedName || function (importName
/*, path*/
) {
  return "i__const_".concat(importName.replace(/\W/g, '_'), "_").concat(importIndex++);
};

var _default = _postcss["default"].plugin('postcss-modules-values', function () {
  return function (css, result) {
    var importAliases = [];
    var definitions = {};

    var addDefinition = function addDefinition(atRule) {
      var matches;

      while (matches = matchValueDefinition.exec(atRule.params)) {
        var _matches = matches,
            _matches2 = _slicedToArray(_matches, 3),

        /*match*/
        key = _matches2[1],
            value = _matches2[2]; // Add to the definitions, knowing that values can refer to each other


        definitions[key] = (0, _icssReplaceSymbols.replaceAll)(definitions, value);
        atRule.remove();
      }
    };

    var addImport = function addImport(atRule) {
      var matches = matchImports.exec(atRule.params);

      if (matches) {
        var _matches3 = _slicedToArray(matches, 3),

        /*match*/
        aliases = _matches3[1],
            path = _matches3[2]; // We can use constants for path names


        if (definitions[path]) path = definitions[path];
        var imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, '$1').split(/\s*,\s*/).map(function (alias) {
          var tokens = matchImport.exec(alias);

          if (tokens) {
            var _tokens = _slicedToArray(tokens, 3),

            /*match*/
            theirName = _tokens[1],
                _tokens$ = _tokens[2],
                myName = _tokens$ === void 0 ? theirName : _tokens$;

            var importedName = createImportedName(myName);
            definitions[myName] = importedName;
            return {
              theirName: theirName,
              importedName: importedName
            };
          } else {
            throw new Error("@import statement \"".concat(alias, "\" is invalid!"));
          }
        });
        importAliases.push({
          path: path,
          imports: imports
        });
        atRule.remove();
      }
    };
    /* Look at all the @value statements and treat them as locals or as imports */


    css.walkAtRules('value', function (atRule) {
      if (matchImports.exec(atRule.params)) {
        addImport(atRule);
      } else {
        if (atRule.params.indexOf('@value') !== -1) {
          result.warn('Invalid value definition: ' + atRule.params);
        }

        addDefinition(atRule);
      }
    });
    /* We want to export anything defined by now, but don't add it to the CSS yet or
     it well get picked up by the replacement stuff */

    var exportDeclarations = Object.keys(definitions).map(function (key) {
      return _postcss["default"].decl({
        value: definitions[key],
        prop: key,
        raws: {
          before: "\n  "
        }
      });
    });
    /* If we have no definitions, don't continue */

    if (!Object.keys(definitions).length) return;
    /* Perform replacements */

    (0, _icssReplaceSymbols["default"])(css, definitions);
    /* Add export rules if any */

    if (exportDeclarations.length > 0) {
      var exportRule = _postcss["default"].rule({
        selector: ":export",
        raws: {
          after: "\n"
        }
      });

      exportRule.append(exportDeclarations);
      css.prepend(exportRule);
    }
    /* Add import rules */


    importAliases.reverse().forEach(function (_ref) {
      var path = _ref.path,
          imports = _ref.imports;

      var importRule = _postcss["default"].rule({
        selector: ":import(".concat(path, ")"),
        raws: {
          after: "\n"
        }
      });

      imports.forEach(function (_ref2) {
        var theirName = _ref2.theirName,
            importedName = _ref2.importedName;
        importRule.append({
          value: theirName,
          prop: importedName,
          raws: {
            before: "\n  "
          }
        });
      });
      css.prepend(importRule);
    });
  };
});

exports["default"] = _default;