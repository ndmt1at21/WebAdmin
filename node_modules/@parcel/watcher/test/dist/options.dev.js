"use strict";

var Watcher = require('../index');

var fs = require('@parcel/fs');

var path = require('path');

var assert = require('assert');

var _require = require('@parcel/test-utils'),
    sleep = _require.sleep;

describe('options', function () {
  var tmpFolder = path.join(__dirname, './tmp/');
  before(function () {
    fs.mkdirp(tmpFolder);
  });
  it('Should pass init options with correct ignored regex', function _callee() {
    var watcher, filepath, changed;
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            watcher = new Watcher({
              ignored: /file/
            });
            filepath = path.join(tmpFolder, 'file1.txt');
            _context.next = 4;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is a text document'));

          case 4:
            watcher.add(filepath);
            changed = false;
            watcher.once('change', function () {
              changed = true;
            });

            if (watcher.ready) {
              _context.next = 10;
              break;
            }

            _context.next = 10;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return watcher.once('ready', resolve);
            }));

          case 10:
            _context.next = 12;
            return regeneratorRuntime.awrap(sleep(250));

          case 12:
            _context.next = 14;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is not a text document'));

          case 14:
            _context.next = 16;
            return regeneratorRuntime.awrap(sleep(500));

          case 16:
            assert(!changed, 'File should not be flagged as changed.');
            _context.next = 19;
            return regeneratorRuntime.awrap(watcher.stop());

          case 19:
          case "end":
            return _context.stop();
        }
      }
    });
  });
  it('Should pass init options with a more complex ignored regex', function _callee2() {
    var watcher, filepaths, _i, _filepaths, filepath, changed, _i2, _filepaths2, _filepath;

    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            watcher = new Watcher({
              ignored: /file|config/
            });
            filepaths = [path.join(tmpFolder, 'file1.txt'), path.join(tmpFolder, 'config.json')];
            _i = 0, _filepaths = filepaths;

          case 3:
            if (!(_i < _filepaths.length)) {
              _context2.next = 11;
              break;
            }

            filepath = _filepaths[_i];
            _context2.next = 7;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is a text document'));

          case 7:
            watcher.add(filepath);

          case 8:
            _i++;
            _context2.next = 3;
            break;

          case 11:
            changed = false;
            watcher.once('change', function () {
              changed = true;
            });

            if (watcher.ready) {
              _context2.next = 16;
              break;
            }

            _context2.next = 16;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return watcher.once('ready', resolve);
            }));

          case 16:
            _context2.next = 18;
            return regeneratorRuntime.awrap(sleep(250));

          case 18:
            _i2 = 0, _filepaths2 = filepaths;

          case 19:
            if (!(_i2 < _filepaths2.length)) {
              _context2.next = 27;
              break;
            }

            _filepath = _filepaths2[_i2];
            _context2.next = 23;
            return regeneratorRuntime.awrap(fs.writeFile(_filepath, 'this is not a text document'));

          case 23:
            watcher.add(_filepath);

          case 24:
            _i2++;
            _context2.next = 19;
            break;

          case 27:
            _context2.next = 29;
            return regeneratorRuntime.awrap(sleep(500));

          case 29:
            assert(!changed, 'File should not be flagged as changed.');
            _context2.next = 32;
            return regeneratorRuntime.awrap(watcher.stop());

          case 32:
          case "end":
            return _context2.stop();
        }
      }
    });
  });
  it('Should not ignore any files outside of the regex', function _callee3() {
    var watcher, filepaths, _i3, _filepaths3, filepath, changed, _i4, _filepaths4, _filepath2;

    return regeneratorRuntime.async(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            watcher = new Watcher({
              ignored: /file|config/
            });
            filepaths = [path.join(tmpFolder, 'file1.txt'), path.join(tmpFolder, 'config.json'), path.join(tmpFolder, 'something')];
            _i3 = 0, _filepaths3 = filepaths;

          case 3:
            if (!(_i3 < _filepaths3.length)) {
              _context3.next = 11;
              break;
            }

            filepath = _filepaths3[_i3];
            _context3.next = 7;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is a text document'));

          case 7:
            watcher.add(filepath);

          case 8:
            _i3++;
            _context3.next = 3;
            break;

          case 11:
            changed = 0;
            watcher.once('change', function () {
              changed++;
            });

            if (watcher.ready) {
              _context3.next = 16;
              break;
            }

            _context3.next = 16;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return watcher.once('ready', resolve);
            }));

          case 16:
            _context3.next = 18;
            return regeneratorRuntime.awrap(sleep(250));

          case 18:
            _i4 = 0, _filepaths4 = filepaths;

          case 19:
            if (!(_i4 < _filepaths4.length)) {
              _context3.next = 27;
              break;
            }

            _filepath2 = _filepaths4[_i4];
            _context3.next = 23;
            return regeneratorRuntime.awrap(fs.writeFile(_filepath2, 'this is not a text document'));

          case 23:
            watcher.add(_filepath2);

          case 24:
            _i4++;
            _context3.next = 19;
            break;

          case 27:
            _context3.next = 29;
            return regeneratorRuntime.awrap(sleep(500));

          case 29:
            assert.equal(changed, 1, 'One file should have changed once.');
            _context3.next = 32;
            return regeneratorRuntime.awrap(watcher.stop());

          case 32:
          case "end":
            return _context3.stop();
        }
      }
    });
  });
});