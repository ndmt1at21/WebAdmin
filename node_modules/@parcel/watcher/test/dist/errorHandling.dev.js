"use strict";

var Watcher = require('../index');

var fs = require('@parcel/fs');

var path = require('path');

var assert = require('assert');

var _require = require('@parcel/test-utils'),
    sleep = _require.sleep;

describe('error handling', function () {
  var tmpFolder = path.join(__dirname, './tmp/');
  before(function () {
    fs.mkdirp(tmpFolder);
  });
  it('Should restart child process if it dies', function _callee() {
    var watcher, filepath, changed;
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            watcher = new Watcher({});
            filepath = path.join(tmpFolder, 'file1.txt');
            _context.next = 4;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is a text document'));

          case 4:
            watcher.add(filepath);
            changed = false;
            watcher.once('change', function () {
              changed = true;
            });

            if (watcher.ready) {
              _context.next = 10;
              break;
            }

            _context.next = 10;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return watcher.once('ready', resolve);
            }));

          case 10:
            _context.next = 12;
            return regeneratorRuntime.awrap(sleep(250));

          case 12:
            watcher._emulateChildDead();

            _context.next = 15;
            return regeneratorRuntime.awrap(sleep(1000));

          case 15:
            _context.next = 17;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is not a text document'));

          case 17:
            _context.next = 19;
            return regeneratorRuntime.awrap(sleep(500));

          case 19:
            assert(changed, 'Should have emitted a change event.');
            _context.next = 22;
            return regeneratorRuntime.awrap(watcher.stop());

          case 22:
          case "end":
            return _context.stop();
        }
      }
    });
  });
  it('Should restart child process on errors', function _callee2() {
    var watcher, filepath, hasThrown, changed;
    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            watcher = new Watcher({});
            filepath = path.join(tmpFolder, 'file1.txt');
            _context2.next = 4;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is a text document'));

          case 4:
            watcher.add(filepath);
            hasThrown = false;
            watcher.on('watcherError', function () {
              return hasThrown = true;
            });
            changed = false;
            watcher.once('change', function () {
              changed = true;
            });

            if (watcher.ready) {
              _context2.next = 12;
              break;
            }

            _context2.next = 12;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return watcher.once('ready', resolve);
            }));

          case 12:
            _context2.next = 14;
            return regeneratorRuntime.awrap(sleep(250));

          case 14:
            watcher._emulateChildError();

            _context2.next = 17;
            return regeneratorRuntime.awrap(sleep(1000));

          case 17:
            _context2.next = 19;
            return regeneratorRuntime.awrap(fs.writeFile(filepath, 'this is not a text document'));

          case 19:
            _context2.next = 21;
            return regeneratorRuntime.awrap(sleep(500));

          case 21:
            assert(changed, 'Should have emitted a change event.');
            _context2.next = 24;
            return regeneratorRuntime.awrap(watcher.stop());

          case 24:
            assert(hasThrown, 'Should have emitted an error event.');

          case 25:
          case "end":
            return _context2.stop();
        }
      }
    });
  });
});