"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _require = require('chokidar'),
    FSWatcher = _require.FSWatcher;

var _require2 = require('@parcel/utils'),
    errorUtils = _require2.errorUtils;

var optionsTransfer = require('./options');

var watcher;

function sendEvent(event, path) {
  process.send({
    event: event,
    path: path
  });
}

function handleError(e) {
  sendEvent('watcherError', errorUtils.errorToJson(e));
}

function init(options) {
  options = optionsTransfer.decode(options);
  watcher = new FSWatcher(options);
  watcher.on('all', sendEvent);
  sendEvent('ready');
}

function executeFunction(functionName, args) {
  try {
    var _watcher;

    (_watcher = watcher)[functionName].apply(_watcher, _toConsumableArray(args));
  } catch (e) {
    handleError(e);
  }
}

process.on('message', function (msg) {
  switch (msg.type) {
    case 'init':
      init(msg.options);
      break;

    case 'function':
      executeFunction(msg.name, msg.args);
      break;

    case 'die':
      process.exit();
      break;

    case 'emulate_error':
      throw new Error('this is an emulated error');
  }
});
process.on('error', handleError);
process.on('uncaughtException', handleError);
process.on('disconnect', function () {
  process.exit();
});