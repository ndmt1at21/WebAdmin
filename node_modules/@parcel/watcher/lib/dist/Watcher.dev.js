"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var fork = require('child_process').fork;

var optionsTransfer = require('./options');

var Path = require('path');

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require2 = require('@parcel/utils'),
    errorUtils = _require2.errorUtils;
/**
 * This watcher wraps chokidar so that we watch directories rather than individual files on macOS.
 * This prevents us from hitting EMFILE errors when running out of file descriptors.
 * Chokidar does not have support for watching directories on non-macOS platforms, so we disable
 * this behavior in order to prevent watching more individual files than necessary (e.g. node_modules).
 */


var Watcher =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Watcher, _EventEmitter);

  function Watcher() {
    var _this2;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      // FS events on macOS are flakey in the tests, which write lots of files very quickly
      // See https://github.com/paulmillr/chokidar/issues/612
      useFsEvents: process.platform === 'darwin' && process.env.NODE_ENV !== 'test',
      ignoreInitial: true,
      ignorePermissionErrors: true,
      ignored: /(^|[/\\])\.(git|cache)/
    };

    _classCallCheck(this, Watcher);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Watcher).call(this));
    _this2.options = optionsTransfer.encode(options);
    _this2.watchedPaths = new Set();
    _this2.child = null;
    _this2.ready = false;
    _this2.readyQueue = [];
    _this2.watchedDirectories = new Map();
    _this2.stopped = false;

    _this2.on('ready', function () {
      _this2.ready = true;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _this2.readyQueue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var func = _step.value;
          func();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      _this2.readyQueue = [];
    });

    _this2.startchild();

    return _this2;
  }

  _createClass(Watcher, [{
    key: "startchild",
    value: function startchild() {
      var _this3 = this;

      if (this.child) return;
      var filteredArgs = process.execArgv.filter(function (v) {
        return !/^--(debug|inspect)/.test(v);
      });
      var options = {
        execArgv: filteredArgs,
        env: process.env,
        cwd: process.cwd()
      };
      this.child = fork(Path.join(__dirname, 'child'), process.argv, options);

      if (this.watchedPaths.size > 0) {
        this.sendCommand('add', [Array.from(this.watchedPaths)]);
      }

      this.child.send({
        type: 'init',
        options: this.options
      });
      this.child.on('message', function (msg) {
        return _this3.handleEmit(msg.event, msg.path);
      });
      this.child.on('error', function () {});
      this.child.on('exit', function () {
        return _this3.handleClosed();
      }); // this.child.on('close', () => this.handleClosed());
    }
  }, {
    key: "handleClosed",
    value: function handleClosed() {
      if (!this.stopped) {
        // Restart the child
        this.child = null;
        this.ready = false;
        this.startchild();
      }

      this.emit('childDead');
    }
  }, {
    key: "handleEmit",
    value: function handleEmit(event, data) {
      if (event === 'watcherError') {
        data = errorUtils.jsonToError(data);
      }

      this.emit(event, data);
    }
  }, {
    key: "sendCommand",
    value: function sendCommand(func, args) {
      var _this4 = this;

      if (!this.ready) {
        return this.readyQueue.push(function () {
          return _this4.sendCommand(func, args);
        });
      }

      this.child.send({
        type: 'function',
        name: func,
        args: args
      });
    }
  }, {
    key: "_addPath",
    value: function _addPath(path) {
      if (!this.watchedPaths.has(path)) {
        this.watchedPaths.add(path);
        return true;
      }
    }
  }, {
    key: "add",
    value: function add(paths) {
      var added = false;

      if (Array.isArray(paths)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = paths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var path = _step2.value;
            added = !added ? this._addPath(path) : true;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        added = this._addPath(paths);
      }

      if (added) this.sendCommand('add', [paths]);
    }
  }, {
    key: "_closePath",
    value: function _closePath(path) {
      if (this.watchedPaths.has(path)) {
        this.watchedPaths["delete"](path);
      }

      this.sendCommand('_closePath', [path]);
    }
  }, {
    key: "_emulateChildDead",
    value: function _emulateChildDead() {
      if (!this.child) {
        return;
      }

      this.child.send({
        type: 'die'
      });
    }
  }, {
    key: "_emulateChildError",
    value: function _emulateChildError() {
      if (!this.child) {
        return;
      }

      this.child.send({
        type: 'emulate_error'
      });
    }
  }, {
    key: "getWatched",
    value: function getWatched() {
      var watchList = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.watchedPaths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var path = _step3.value;
          var key = this.options.cwd ? Path.relative(this.options.cwd, path) : path;
          watchList[key || '.'] = [];
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return watchList;
    }
    /**
     * Find a parent directory of `path` which is already watched
     */

  }, {
    key: "getWatchedParent",
    value: function getWatchedParent(path) {
      path = Path.dirname(path);
      var root = Path.parse(path).root;

      while (path !== root) {
        if (this.watchedDirectories.has(path)) {
          return path;
        }

        path = Path.dirname(path);
      }

      return null;
    }
    /**
     * Find a list of child directories of `path` which are already watched
     */

  }, {
    key: "getWatchedChildren",
    value: function getWatchedChildren(path) {
      path = Path.dirname(path) + Path.sep;
      var res = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.watchedDirectories.keys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var dir = _step4.value;

          if (dir.startsWith(path)) {
            res.push(dir);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return res;
    }
    /**
     * Add a path to the watcher
     */

  }, {
    key: "watch",
    value: function watch(path) {
      if (this.shouldWatchDirs) {
        // If there is no parent directory already watching this path, add a new watcher.
        var parent = this.getWatchedParent(path);

        if (!parent) {
          // Find watchers on child directories, and remove them. They will be handled by the new parent watcher.
          var children = this.getWatchedChildren(path);
          var count = 1;
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _dir = _step5.value;
              count += this.watchedDirectories.get(_dir);

              this._closePath(_dir);

              this.watchedDirectories["delete"](_dir);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          var dir = Path.dirname(path);
          this.add(dir);
          this.watchedDirectories.set(dir, count);
        } else {
          // Otherwise, increment the reference count of the parent watcher.
          this.watchedDirectories.set(parent, this.watchedDirectories.get(parent) + 1);
        }
      } else {
        this.add(path);
      }
    }
  }, {
    key: "_unwatch",
    value: function _unwatch(paths) {
      var removed = false;

      if (Array.isArray(paths)) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = paths[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var p = _step6.value;
            removed = !removed ? this.watchedPaths["delete"](p) : true;
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      } else {
        removed = this.watchedPaths["delete"](paths);
      }

      if (removed) this.sendCommand('unwatch', [paths]);
    }
    /**
     * Remove a path from the watcher
     */

  }, {
    key: "unwatch",
    value: function unwatch(path) {
      if (this.shouldWatchDirs) {
        var dir = this.getWatchedParent(path);

        if (dir) {
          // When the count of files watching a directory reaches zero, unwatch it.
          var count = this.watchedDirectories.get(dir) - 1;

          if (count === 0) {
            this.watchedDirectories["delete"](dir);

            this._unwatch(dir);
          } else {
            this.watchedDirectories.set(dir, count);
          }
        }
      } else {
        this._unwatch(path);
      }
    }
    /**
     * Stop watching all paths
     */

  }, {
    key: "stop",
    value: function stop() {
      var _this = this;

      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this.stopped = true;

                if (!_this.child) {
                  _context.next = 4;
                  break;
                }

                _this.child.kill();

                return _context.abrupt("return", new Promise(function (resolve) {
                  return _this.once('childDead', resolve);
                }));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }]);

  return Watcher;
}(EventEmitter);

module.exports = Watcher;