"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var chalk = require('chalk');

var readline = require('readline');

var prettyError = require('./prettyError');

var emoji = require('./emoji');

var _require = require('grapheme-breaker'),
    countBreaks = _require.countBreaks;

var stripAnsi = require('strip-ansi');

var ora = require('ora');

var WorkerFarm = require('@parcel/workers');

var path = require('path');

var fs = require('fs');

var Logger =
/*#__PURE__*/
function () {
  function Logger(options) {
    _classCallCheck(this, Logger);

    this.lines = 0;
    this.spinner = null;
    this.setOptions(options);
  }

  _createClass(Logger, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.logLevel = options && isNaN(options.logLevel) === false ? Number(options.logLevel) : 3;
      this.color = options && typeof options.color === 'boolean' ? options.color : chalk.supportsColor;
      this.emoji = options && options.emoji || emoji;
      this.chalk = new chalk.constructor({
        enabled: this.color
      });
      this.isTest = options && typeof options.isTest === 'boolean' ? options.isTest : process.env.NODE_ENV === 'test';
    }
  }, {
    key: "countLines",
    value: function countLines(message) {
      return stripAnsi(message).split('\n').reduce(function (p, line) {
        if (process.stdout.columns) {
          return p + Math.ceil((line.length || 1) / process.stdout.columns);
        }

        return p + 1;
      }, 0);
    }
  }, {
    key: "writeRaw",
    value: function writeRaw(message) {
      this.stopSpinner();
      this.lines += this.countLines(message) - 1;
      process.stdout.write(message);
    }
  }, {
    key: "write",
    value: function write(message) {
      var persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.logLevel > 3) {
        return this.verbose(message);
      }

      if (!persistent) {
        this.lines += this.countLines(message);
      }

      this.stopSpinner();

      this._log(message);
    }
  }, {
    key: "verbose",
    value: function verbose(message) {
      if (this.logLevel < 4) {
        return;
      }

      var currDate = new Date();
      message = "[".concat(currDate.toLocaleTimeString(), "]: ").concat(message);

      if (this.logLevel > 4) {
        if (!this.logFile) {
          this.logFile = fs.createWriteStream(path.join(process.cwd(), "parcel-debug-".concat(currDate.toISOString(), ".log")));
        }

        this.logFile.write(stripAnsi(message) + '\n');
      }

      this._log(message);
    }
  }, {
    key: "log",
    value: function log(message) {
      if (this.logLevel < 3) {
        return;
      }

      this.write(message);
    }
  }, {
    key: "persistent",
    value: function persistent(message) {
      if (this.logLevel < 3) {
        return;
      }

      this.write(this.chalk.bold(message), true);
    }
  }, {
    key: "warn",
    value: function warn(err) {
      if (this.logLevel < 2) {
        return;
      }

      this._writeError(err, this.emoji.warning, this.chalk.yellow);
    }
  }, {
    key: "error",
    value: function error(err) {
      if (this.logLevel < 1) {
        return;
      }

      this._writeError(err, this.emoji.error, this.chalk.red.bold);
    }
  }, {
    key: "success",
    value: function success(message) {
      this.log("".concat(this.emoji.success, "  ").concat(this.chalk.green.bold(message)));
    }
  }, {
    key: "formatError",
    value: function formatError(err, opts) {
      return prettyError(err, opts);
    }
  }, {
    key: "_writeError",
    value: function _writeError(err, emoji, color) {
      var _this$formatError = this.formatError(err, {
        color: this.color
      }),
          message = _this$formatError.message,
          stack = _this$formatError.stack;

      this.write(color("".concat(emoji, "  ").concat(message)));

      if (stack) {
        this.write(stack);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      if (!this.color || this.isTest || this.logLevel > 3) {
        return;
      }

      while (this.lines > 0) {
        readline.clearLine(process.stdout, 0);
        readline.moveCursor(process.stdout, 0, -1);
        this.lines--;
      }

      readline.cursorTo(process.stdout, 0);
      this.stopSpinner();
    }
  }, {
    key: "progress",
    value: function progress(message) {
      if (this.logLevel < 3) {
        return;
      }

      if (this.logLevel > 3) {
        return this.verbose(message);
      }

      var styledMessage = this.chalk.gray.bold(message);

      if (!this.spinner) {
        this.spinner = ora({
          text: styledMessage,
          stream: process.stdout,
          enabled: this.isTest ? false : undefined // fall back to ora default unless we need to explicitly disable it.

        }).start();
      } else {
        this.spinner.text = styledMessage;
      }
    }
  }, {
    key: "stopSpinner",
    value: function stopSpinner() {
      if (this.spinner) {
        this.spinner.stop();
        this.spinner = null;
      }
    }
  }, {
    key: "handleMessage",
    value: function handleMessage(options) {
      this[options.method].apply(this, _toConsumableArray(options.args));
    }
  }, {
    key: "_log",
    value: function _log(message) {
      // eslint-disable-next-line no-console
      console.log(message);
    }
  }, {
    key: "table",
    value: function table(columns, _table) {
      // Measure column widths
      var colWidths = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _table[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var row = _step.value;
          var i = 0;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = row[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var item = _step3.value;
              colWidths[i] = Math.max(colWidths[i] || 0, stringWidth(item));
              i++;
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        } // Render rows

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _table[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _row = _step2.value;

          var items = _row.map(function (item, i) {
            // Add padding between columns unless the alignment is the opposite to the
            // next column and pad to the column width.
            var padding = !columns[i + 1] || columns[i + 1].align === columns[i].align ? 4 : 0;
            return pad(item, colWidths[i] + padding, columns[i].align);
          });

          this.log(items.join(''));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);

  return Logger;
}(); // Pad a string with spaces on either side


function pad(text, length) {
  var align = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'left';
  var pad = ' '.repeat(length - stringWidth(text));

  if (align === 'right') {
    return pad + text;
  }

  return text + pad;
} // Count visible characters in a string


function stringWidth(string) {
  return countBreaks(stripAnsi('' + string));
} // If we are in a worker, make a proxy class which will
// send the logger calls to the main process via IPC.
// These are handled in WorkerFarm and directed to handleMessage above.


if (WorkerFarm.isWorker()) {
  var LoggerProxy = function LoggerProxy() {
    _classCallCheck(this, LoggerProxy);
  };

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    var _loop = function _loop() {
      var method = _step4.value;

      LoggerProxy.prototype[method] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        WorkerFarm.callMaster({
          location: __filename,
          method: method,
          args: args
        }, false);
      };
    };

    for (var _iterator4 = Object.getOwnPropertyNames(Logger.prototype)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  module.exports = new LoggerProxy();
} else {
  module.exports = new Logger();
}