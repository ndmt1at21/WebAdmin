"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require2 = require('@parcel/utils'),
    errorUtils = _require2.errorUtils;

var Worker = require('./Worker');

var cpuCount = require('./cpuCount');

var shared = null;
/**
 * workerPath should always be defined inside farmOptions
 */

var WorkerFarm =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(WorkerFarm, _EventEmitter);

  function WorkerFarm(options) {
    var _this;

    var farmOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, WorkerFarm);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WorkerFarm).call(this));
    _this.options = {
      maxConcurrentWorkers: WorkerFarm.getNumWorkers(),
      maxConcurrentCallsPerWorker: WorkerFarm.getConcurrentCallsPerWorker(),
      forcedKillTime: 500,
      warmWorkers: true,
      useLocalWorker: true
    };

    if (farmOptions) {
      _this.options = Object.assign(_this.options, farmOptions);
    }

    _this.warmWorkers = 0;
    _this.workers = new Map();
    _this.callQueue = [];

    if (!_this.options.workerPath) {
      throw new Error('Please provide a worker path!');
    }

    _this.localWorker = require(_this.options.workerPath);
    _this.run = _this.mkhandle('run');

    _this.init(options);

    return _this;
  }

  _createClass(WorkerFarm, [{
    key: "warmupWorker",
    value: function warmupWorker(method, args) {
      var _this2 = this;

      // Workers are already stopping
      if (this.ending) {
        return;
      } // Workers are not warmed up yet.
      // Send the job to a remote worker in the background,
      // but use the result from the local worker - it will be faster.


      var promise = this.addCall(method, [].concat(_toConsumableArray(args), [true]));

      if (promise) {
        promise.then(function () {
          _this2.warmWorkers++;

          if (_this2.warmWorkers >= _this2.workers.size) {
            _this2.emit('warmedup');
          }
        })["catch"](function () {});
      }
    }
  }, {
    key: "shouldStartRemoteWorkers",
    value: function shouldStartRemoteWorkers() {
      return this.options.maxConcurrentWorkers > 1 || process.env.NODE_ENV === 'test' || !this.options.useLocalWorker;
    }
  }, {
    key: "mkhandle",
    value: function mkhandle(method) {
      var _this3 = this;

      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // Child process workers are slow to start (~600ms).
        // While we're waiting, just run on the main thread.
        // This significantly speeds up startup time.
        if (_this3.shouldUseRemoteWorkers()) {
          return _this3.addCall(method, [].concat(args, [false]));
        } else {
          var _this3$localWorker;

          if (_this3.options.warmWorkers && _this3.shouldStartRemoteWorkers()) {
            _this3.warmupWorker(method, args);
          }

          return (_this3$localWorker = _this3.localWorker)[method].apply(_this3$localWorker, args.concat([false]));
        }
      };
    }
  }, {
    key: "onError",
    value: function onError(error, worker) {
      // Handle ipc errors
      if (error.code === 'ERR_IPC_CHANNEL_CLOSED') {
        return this.stopWorker(worker);
      }
    }
  }, {
    key: "startChild",
    value: function startChild() {
      var _this4 = this;

      var worker = new Worker(this.options);
      worker.fork(this.options.workerPath, this.bundlerOptions);
      worker.on('request', function (data) {
        return _this4.processRequest(data, worker);
      });
      worker.on('ready', function () {
        return _this4.processQueue();
      });
      worker.on('response', function () {
        return _this4.processQueue();
      });
      worker.on('error', function (err) {
        return _this4.onError(err, worker);
      });
      worker.once('exit', function () {
        return _this4.stopWorker(worker);
      });
      this.workers.set(worker.id, worker);
    }
  }, {
    key: "stopWorker",
    value: function stopWorker(worker) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, call;

      return regeneratorRuntime.async(function stopWorker$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (worker.stopped) {
                _context.next = 27;
                break;
              }

              this.workers["delete"](worker.id);
              worker.isStopping = true;

              if (!worker.calls.size) {
                _context.next = 23;
                break;
              }

              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 7;

              for (_iterator = worker.calls.values()[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                call = _step.value;
                call.retries++;
                this.callQueue.unshift(call);
              }

              _context.next = 15;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](7);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 15:
              _context.prev = 15;
              _context.prev = 16;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 18:
              _context.prev = 18;

              if (!_didIteratorError) {
                _context.next = 21;
                break;
              }

              throw _iteratorError;

            case 21:
              return _context.finish(18);

            case 22:
              return _context.finish(15);

            case 23:
              worker.calls = null;
              _context.next = 26;
              return regeneratorRuntime.awrap(worker.stop());

            case 26:
              // Process any requests that failed and start a new worker
              this.processQueue();

            case 27:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[7, 11, 15, 23], [16,, 18, 22]]);
    }
  }, {
    key: "processQueue",
    value: function processQueue() {
      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, worker;

      return regeneratorRuntime.async(function processQueue$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(this.ending || !this.callQueue.length)) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              if (this.workers.size < this.options.maxConcurrentWorkers) {
                this.startChild();
              }

              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context2.prev = 6;
              _iterator2 = this.workers.values()[Symbol.iterator]();

            case 8:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context2.next = 18;
                break;
              }

              worker = _step2.value;

              if (this.callQueue.length) {
                _context2.next = 12;
                break;
              }

              return _context2.abrupt("break", 18);

            case 12:
              if (!(!worker.ready || worker.stopped || worker.isStopping)) {
                _context2.next = 14;
                break;
              }

              return _context2.abrupt("continue", 15);

            case 14:
              if (worker.calls.size < this.options.maxConcurrentCallsPerWorker) {
                worker.call(this.callQueue.shift());
              }

            case 15:
              _iteratorNormalCompletion2 = true;
              _context2.next = 8;
              break;

            case 18:
              _context2.next = 24;
              break;

            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](6);
              _didIteratorError2 = true;
              _iteratorError2 = _context2.t0;

            case 24:
              _context2.prev = 24;
              _context2.prev = 25;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 27:
              _context2.prev = 27;

              if (!_didIteratorError2) {
                _context2.next = 30;
                break;
              }

              throw _iteratorError2;

            case 30:
              return _context2.finish(27);

            case 31:
              return _context2.finish(24);

            case 32:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[6, 20, 24, 32], [25,, 27, 31]]);
    }
  }, {
    key: "processRequest",
    value: function processRequest(data) {
      var worker,
          result,
          method,
          args,
          location,
          awaitResponse,
          mod,
          _args3 = arguments;
      return regeneratorRuntime.async(function processRequest$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              worker = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;
              result = {
                idx: data.idx,
                type: 'response'
              };
              method = data.method;
              args = data.args;
              location = data.location;
              awaitResponse = data.awaitResponse;

              if (location) {
                _context3.next = 8;
                break;
              }

              throw new Error('Unknown request');

            case 8:
              mod = require(location);
              _context3.prev = 9;
              result.contentType = 'data';

              if (!method) {
                _context3.next = 17;
                break;
              }

              _context3.next = 14;
              return regeneratorRuntime.awrap(mod[method].apply(mod, _toConsumableArray(args)));

            case 14:
              result.content = _context3.sent;
              _context3.next = 20;
              break;

            case 17:
              _context3.next = 19;
              return regeneratorRuntime.awrap(mod.apply(void 0, _toConsumableArray(args)));

            case 19:
              result.content = _context3.sent;

            case 20:
              _context3.next = 26;
              break;

            case 22:
              _context3.prev = 22;
              _context3.t0 = _context3["catch"](9);
              result.contentType = 'error';
              result.content = errorUtils.errorToJson(_context3.t0);

            case 26:
              if (!awaitResponse) {
                _context3.next = 32;
                break;
              }

              if (!worker) {
                _context3.next = 31;
                break;
              }

              worker.send(result);
              _context3.next = 32;
              break;

            case 31:
              return _context3.abrupt("return", result);

            case 32:
            case "end":
              return _context3.stop();
          }
        }
      }, null, null, [[9, 22]]);
    }
  }, {
    key: "addCall",
    value: function addCall(method, args) {
      var _this5 = this;

      if (this.ending) {
        throw new Error('Cannot add a worker call if workerfarm is ending.');
      }

      return new Promise(function (resolve, reject) {
        _this5.callQueue.push({
          method: method,
          args: args,
          retries: 0,
          resolve: resolve,
          reject: reject
        });

        _this5.processQueue();
      });
    }
  }, {
    key: "end",
    value: function end() {
      var _this6 = this;

      return regeneratorRuntime.async(function end$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              this.ending = true;
              _context4.next = 3;
              return regeneratorRuntime.awrap(Promise.all(Array.from(this.workers.values()).map(function (worker) {
                return _this6.stopWorker(worker);
              })));

            case 3:
              this.ending = false;
              shared = null;

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "init",
    value: function init(bundlerOptions) {
      this.bundlerOptions = bundlerOptions;

      if (this.shouldStartRemoteWorkers()) {
        this.persistBundlerOptions();
      }

      this.localWorker.init(bundlerOptions);
      this.startMaxWorkers();
    }
  }, {
    key: "persistBundlerOptions",
    value: function persistBundlerOptions() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.workers.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var worker = _step3.value;
          worker.init(this.bundlerOptions);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "startMaxWorkers",
    value: function startMaxWorkers() {
      // Starts workers untill the maximum is reached
      if (this.workers.size < this.options.maxConcurrentWorkers) {
        for (var i = 0; i < this.options.maxConcurrentWorkers - this.workers.size; i++) {
          this.startChild();
        }
      }
    }
  }, {
    key: "shouldUseRemoteWorkers",
    value: function shouldUseRemoteWorkers() {
      return !this.options.useLocalWorker || this.warmWorkers >= this.workers.size || !this.options.warmWorkers;
    }
  }], [{
    key: "getShared",
    value: function getShared(options, farmOptions) {
      return regeneratorRuntime.async(function getShared$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!(shared && farmOptions)) {
                _context5.next = 4;
                break;
              }

              _context5.next = 3;
              return regeneratorRuntime.awrap(shared.end());

            case 3:
              shared = null;

            case 4:
              if (!shared) {
                shared = new WorkerFarm(options, farmOptions);
              } else if (options) {
                shared.init(options);
              }

              if (!(!shared && !options)) {
                _context5.next = 7;
                break;
              }

              throw new Error('Workerfarm should be initialised using options');

            case 7:
              return _context5.abrupt("return", shared);

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      });
    }
  }, {
    key: "getNumWorkers",
    value: function getNumWorkers() {
      return process.env.PARCEL_WORKERS ? parseInt(process.env.PARCEL_WORKERS, 10) : cpuCount();
    }
  }, {
    key: "callMaster",
    value: function callMaster(request) {
      var awaitResponse,
          child,
          _args6 = arguments;
      return regeneratorRuntime.async(function callMaster$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              awaitResponse = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : true;

              if (!WorkerFarm.isWorker()) {
                _context6.next = 6;
                break;
              }

              child = require('./child');
              return _context6.abrupt("return", child.addCall(request, awaitResponse));

            case 6:
              _context6.next = 8;
              return regeneratorRuntime.awrap(WorkerFarm.getShared());

            case 8:
              _context6.t0 = request;
              return _context6.abrupt("return", _context6.sent.processRequest(_context6.t0));

            case 10:
            case "end":
              return _context6.stop();
          }
        }
      });
    }
  }, {
    key: "isWorker",
    value: function isWorker() {
      return process.send && require.main.filename === require.resolve('./child');
    }
  }, {
    key: "getConcurrentCallsPerWorker",
    value: function getConcurrentCallsPerWorker() {
      return parseInt(process.env.PARCEL_MAX_CONCURRENT_CALLS, 10) || 5;
    }
  }]);

  return WorkerFarm;
}(EventEmitter);

module.exports = WorkerFarm;