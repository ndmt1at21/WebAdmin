"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var childProcess = require('child_process');

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require2 = require('@parcel/utils'),
    errorUtils = _require2.errorUtils;

var childModule = require.resolve('./child');

var WORKER_ID = 0;

var Worker =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Worker, _EventEmitter);

  function Worker(options) {
    var _this;

    _classCallCheck(this, Worker);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Worker).call(this));
    _this.options = options;
    _this.id = WORKER_ID++;
    _this.sendQueue = [];
    _this.processQueue = true;
    _this.calls = new Map();
    _this.exitCode = null;
    _this.callId = 0;
    _this.ready = false;
    _this.stopped = false;
    _this.isStopping = false;
    return _this;
  }

  _createClass(Worker, [{
    key: "fork",
    value: function fork(forkModule, bundlerOptions) {
      var _this2 = this;

      var filteredArgs, options;
      return regeneratorRuntime.async(function fork$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              filteredArgs = process.execArgv.filter(function (v) {
                return !/^--(debug|inspect)/.test(v);
              });
              options = {
                execArgv: filteredArgs,
                env: process.env,
                cwd: process.cwd()
              };
              this.child = childProcess.fork(childModule, process.argv, options);
              this.child.on('message', function (data) {
                return _this2.receive(data);
              });
              this.child.once('exit', function (code) {
                _this2.exitCode = code;

                _this2.emit('exit', code);
              });
              this.child.on('error', function (err) {
                _this2.emit('error', err);
              });
              _context.next = 8;
              return regeneratorRuntime.awrap(new Promise(function (resolve, reject) {
                _this2.call({
                  method: 'childInit',
                  args: [forkModule],
                  retries: 0,
                  resolve: resolve,
                  reject: reject
                });
              }));

            case 8:
              _context.next = 10;
              return regeneratorRuntime.awrap(this.init(bundlerOptions));

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "init",
    value: function init(bundlerOptions) {
      var _this3 = this;

      return regeneratorRuntime.async(function init$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this.ready = false;
              return _context2.abrupt("return", new Promise(function (_resolve, reject) {
                _this3.call({
                  method: 'init',
                  args: [bundlerOptions],
                  retries: 0,
                  resolve: function resolve() {
                    _this3.ready = true;

                    _this3.emit('ready');

                    _resolve.apply(void 0, arguments);
                  },
                  reject: reject
                });
              }));

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "send",
    value: function send(data) {
      var _this4 = this;

      if (!this.processQueue) {
        return this.sendQueue.push(data);
      }

      var result = this.child.send(data, function (error) {
        if (error && error instanceof Error) {
          // Ignore this, the workerfarm handles child errors
          return;
        }

        _this4.processQueue = true;

        if (_this4.sendQueue.length > 0) {
          var queueCopy = _this4.sendQueue.slice(0);

          _this4.sendQueue = [];
          queueCopy.forEach(function (entry) {
            return _this4.send(entry);
          });
        }
      });

      if (!result || /^win/.test(process.platform)) {
        // Queue is handling too much messages throttle it
        this.processQueue = false;
      }
    }
  }, {
    key: "call",
    value: function call(_call) {
      if (this.stopped || this.isStopping) {
        return;
      }

      var idx = this.callId++;
      this.calls.set(idx, _call);
      this.send({
        type: 'request',
        idx: idx,
        child: this.id,
        method: _call.method,
        args: _call.args
      });
    }
  }, {
    key: "receive",
    value: function receive(data) {
      if (this.stopped || this.isStopping) {
        return;
      }

      var idx = data.idx;
      var type = data.type;
      var content = data.content;
      var contentType = data.contentType;

      if (type === 'request') {
        this.emit('request', data);
      } else if (type === 'response') {
        var call = this.calls.get(idx);

        if (!call) {
          // Return for unknown calls, these might accur if a third party process uses workers
          return;
        }

        if (contentType === 'error') {
          call.reject(errorUtils.jsonToError(content));
        } else {
          call.resolve(content);
        }

        this.calls["delete"](idx);
        this.emit('response', data);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this5 = this;

      var forceKill;
      return regeneratorRuntime.async(function stop$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (this.stopped) {
                _context3.next = 8;
                break;
              }

              this.stopped = true;

              if (!this.child) {
                _context3.next = 8;
                break;
              }

              this.child.send('die');
              forceKill = setTimeout(function () {
                return _this5.child.kill('SIGINT');
              }, this.options.forcedKillTime);
              _context3.next = 7;
              return regeneratorRuntime.awrap(new Promise(function (resolve) {
                _this5.child.once('exit', resolve);
              }));

            case 7:
              clearTimeout(forceKill);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }]);

  return Worker;
}(EventEmitter);

module.exports = Worker;