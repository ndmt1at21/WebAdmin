"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('@parcel/utils'),
    errorUtils = _require.errorUtils;

var Child =
/*#__PURE__*/
function () {
  function Child() {
    _classCallCheck(this, Child);

    if (!process.send) {
      throw new Error('Only create Child instances in a worker!');
    }

    this.module = undefined;
    this.childId = undefined;
    this.callQueue = [];
    this.responseQueue = new Map();
    this.responseId = 0;
    this.maxConcurrentCalls = 10;
  }

  _createClass(Child, [{
    key: "messageListener",
    value: function messageListener(data) {
      if (data === 'die') {
        return this.end();
      }

      var type = data.type;

      if (type === 'response') {
        return this.handleResponse(data);
      } else if (type === 'request') {
        return this.handleRequest(data);
      }
    }
  }, {
    key: "send",
    value: function send(data) {
      var _this = this;

      return regeneratorRuntime.async(function send$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              process.send(data, function (err) {
                if (err && err instanceof Error) {
                  if (err.code === 'ERR_IPC_CHANNEL_CLOSED') {
                    // IPC connection closed
                    // no need to keep the worker running if it can't send or receive data
                    return _this.end();
                  }
                }
              });

            case 1:
            case "end":
              return _context.stop();
          }
        }
      });
    }
  }, {
    key: "childInit",
    value: function childInit(module, childId) {
      this.module = require(module);
      this.childId = childId;
    }
  }, {
    key: "handleRequest",
    value: function handleRequest(data) {
      var idx, child, method, args, result, _this$module;

      return regeneratorRuntime.async(function handleRequest$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              idx = data.idx;
              child = data.child;
              method = data.method;
              args = data.args;
              result = {
                idx: idx,
                child: child,
                type: 'response'
              };
              _context2.prev = 5;
              result.contentType = 'data';

              if (!(method === 'childInit')) {
                _context2.next = 11;
                break;
              }

              result.content = this.childInit.apply(this, _toConsumableArray(args).concat([child]));
              _context2.next = 14;
              break;

            case 11:
              _context2.next = 13;
              return regeneratorRuntime.awrap((_this$module = this.module)[method].apply(_this$module, _toConsumableArray(args)));

            case 13:
              result.content = _context2.sent;

            case 14:
              _context2.next = 20;
              break;

            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](5);
              result.contentType = 'error';
              result.content = errorUtils.errorToJson(_context2.t0);

            case 20:
              this.send(result);

            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[5, 16]]);
    }
  }, {
    key: "handleResponse",
    value: function handleResponse(data) {
      var idx, contentType, content, call;
      return regeneratorRuntime.async(function handleResponse$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              idx = data.idx;
              contentType = data.contentType;
              content = data.content;
              call = this.responseQueue.get(idx);

              if (contentType === 'error') {
                call.reject(errorUtils.jsonToError(content));
              } else {
                call.resolve(content);
              }

              this.responseQueue["delete"](idx); // Process the next call

              this.processQueue();

            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    } // Keep in mind to make sure responses to these calls are JSON.Stringify safe

  }, {
    key: "addCall",
    value: function addCall(request) {
      var awaitResponse,
          call,
          promise,
          _args4 = arguments;
      return regeneratorRuntime.async(function addCall$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              awaitResponse = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : true;
              call = request;
              call.type = 'request';
              call.child = this.childId;
              call.awaitResponse = awaitResponse;

              if (awaitResponse) {
                promise = new Promise(function (resolve, reject) {
                  call.resolve = resolve;
                  call.reject = reject;
                });
              }

              this.callQueue.push(call);
              this.processQueue();
              return _context4.abrupt("return", promise);

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "sendRequest",
    value: function sendRequest(call) {
      var idx;
      return regeneratorRuntime.async(function sendRequest$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (call.awaitResponse) {
                idx = this.responseId++;
                this.responseQueue.set(idx, call);
              }

              this.send({
                idx: idx,
                child: call.child,
                type: call.type,
                location: call.location,
                method: call.method,
                args: call.args,
                awaitResponse: call.awaitResponse
              });

            case 2:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "processQueue",
    value: function processQueue() {
      return regeneratorRuntime.async(function processQueue$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (this.callQueue.length) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt("return");

            case 2:
              if (this.responseQueue.size < this.maxConcurrentCalls) {
                this.sendRequest(this.callQueue.shift());
              }

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "end",
    value: function end() {
      process.exit();
    }
  }]);

  return Child;
}();

var child = new Child();
process.on('message', child.messageListener.bind(child));
module.exports = child;