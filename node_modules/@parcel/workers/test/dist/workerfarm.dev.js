"use strict";

var assert = require('assert');

var WorkerFarm = require('../index');

describe('WorkerFarm', function () {
  it('Should start up workers', function _callee() {
    var workerfarm;
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            workerfarm = new WorkerFarm({}, {
              warmWorkers: false,
              useLocalWorker: false,
              workerPath: require.resolve('./integration/workerfarm/ping.js')
            });
            _context.t0 = assert;
            _context.next = 4;
            return regeneratorRuntime.awrap(workerfarm.run());

          case 4:
            _context.t1 = _context.sent;

            _context.t0.equal.call(_context.t0, _context.t1, 'pong');

            _context.next = 8;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 8:
          case "end":
            return _context.stop();
        }
      }
    });
  });
  it('Should handle 1000 requests without any issue', function _callee2() {
    var workerfarm, promises, i;
    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            workerfarm = new WorkerFarm({}, {
              warmWorkers: false,
              useLocalWorker: false,
              workerPath: require.resolve('./integration/workerfarm/echo.js')
            });
            promises = [];

            for (i = 0; i < 1000; i++) {
              promises.push(workerfarm.run(i));
            }

            _context2.next = 5;
            return regeneratorRuntime.awrap(Promise.all(promises));

          case 5:
            _context2.next = 7;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    });
  });
  it('Should consistently initialise workers, even after 100 re-inits', function _callee3() {
    var options, workerfarm, i, _i;

    return regeneratorRuntime.async(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            options = {
              key: 0
            };
            workerfarm = new WorkerFarm(options, {
              warmWorkers: false,
              useLocalWorker: false,
              workerPath: require.resolve('./integration/workerfarm/init.js')
            });
            i = 0;

          case 3:
            if (!(i < 100)) {
              _context3.next = 21;
              break;
            }

            options.key = i;
            workerfarm.init(options);
            _i = 0;

          case 7:
            if (!(_i < workerfarm.workers.size)) {
              _context3.next = 17;
              break;
            }

            _context3.t0 = assert;
            _context3.next = 11;
            return regeneratorRuntime.awrap(workerfarm.run());

          case 11:
            _context3.t1 = _context3.sent.key;
            _context3.t2 = options.key;

            _context3.t0.equal.call(_context3.t0, _context3.t1, _context3.t2);

          case 14:
            _i++;
            _context3.next = 7;
            break;

          case 17:
            assert.equal(workerfarm.shouldUseRemoteWorkers(), true);

          case 18:
            i++;
            _context3.next = 3;
            break;

          case 21:
            _context3.next = 23;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 23:
          case "end":
            return _context3.stop();
        }
      }
    });
  });
  it('Should warm up workers', function _callee4() {
    var workerfarm, i;
    return regeneratorRuntime.async(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            workerfarm = new WorkerFarm({}, {
              warmWorkers: true,
              useLocalWorker: true,
              workerPath: require.resolve('./integration/workerfarm/echo.js')
            });
            i = 0;

          case 2:
            if (!(i < 100)) {
              _context4.next = 12;
              break;
            }

            _context4.t0 = assert;
            _context4.next = 6;
            return regeneratorRuntime.awrap(workerfarm.run(i));

          case 6:
            _context4.t1 = _context4.sent;
            _context4.t2 = i;

            _context4.t0.equal.call(_context4.t0, _context4.t1, _context4.t2);

          case 9:
            i++;
            _context4.next = 2;
            break;

          case 12:
            _context4.next = 14;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return workerfarm.once('warmedup', resolve);
            }));

          case 14:
            assert(workerfarm.workers.size > 0, 'Should have spawned workers.');
            assert(workerfarm.warmWorkers >= workerfarm.workers.size, 'Should have warmed up workers.');
            _context4.next = 18;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 18:
          case "end":
            return _context4.stop();
        }
      }
    });
  });
  it('Should use the local worker', function _callee5() {
    var workerfarm;
    return regeneratorRuntime.async(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            workerfarm = new WorkerFarm({}, {
              warmWorkers: true,
              useLocalWorker: true,
              workerPath: require.resolve('./integration/workerfarm/echo.js')
            });
            _context5.t0 = assert;
            _context5.next = 4;
            return regeneratorRuntime.awrap(workerfarm.run('hello world'));

          case 4:
            _context5.t1 = _context5.sent;

            _context5.t0.equal.call(_context5.t0, _context5.t1, 'hello world');

            assert.equal(workerfarm.shouldUseRemoteWorkers(), false);
            _context5.next = 9;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 9:
          case "end":
            return _context5.stop();
        }
      }
    });
  });
  it('Should be able to use bi-directional communication', function _callee6() {
    var workerfarm;
    return regeneratorRuntime.async(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            workerfarm = new WorkerFarm({}, {
              warmWorkers: false,
              useLocalWorker: false,
              workerPath: require.resolve('./integration/workerfarm/ipc.js')
            });
            _context6.t0 = assert;
            _context6.next = 4;
            return regeneratorRuntime.awrap(workerfarm.run(1, 2));

          case 4:
            _context6.t1 = _context6.sent;

            _context6.t0.equal.call(_context6.t0, _context6.t1, 3);

            _context6.next = 8;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 8:
          case "end":
            return _context6.stop();
        }
      }
    });
  });
  it('Should be able to handle 1000 bi-directional calls', function _callee7() {
    var workerfarm, i;
    return regeneratorRuntime.async(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            workerfarm = new WorkerFarm({}, {
              warmWorkers: false,
              useLocalWorker: false,
              workerPath: require.resolve('./integration/workerfarm/ipc.js')
            });
            i = 0;

          case 2:
            if (!(i < 1000)) {
              _context7.next = 12;
              break;
            }

            _context7.t0 = assert;
            _context7.next = 6;
            return regeneratorRuntime.awrap(workerfarm.run(1 + i, 2));

          case 6:
            _context7.t1 = _context7.sent;
            _context7.t2 = 3 + i;

            _context7.t0.equal.call(_context7.t0, _context7.t1, _context7.t2);

          case 9:
            i++;
            _context7.next = 2;
            break;

          case 12:
            _context7.next = 14;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 14:
          case "end":
            return _context7.stop();
        }
      }
    });
  });
  it('Bi-directional call should return masters pid', function _callee8() {
    var workerfarm, result;
    return regeneratorRuntime.async(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            workerfarm = new WorkerFarm({}, {
              warmWorkers: false,
              useLocalWorker: false,
              workerPath: require.resolve('./integration/workerfarm/ipc-pid.js')
            });
            _context8.next = 3;
            return regeneratorRuntime.awrap(workerfarm.run());

          case 3:
            result = _context8.sent;
            assert.equal(result.length, 2);
            assert.equal(result[1], process.pid);
            assert.notEqual(result[0], process.pid);
            _context8.next = 9;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 9:
          case "end":
            return _context8.stop();
        }
      }
    });
  });
  it('Should handle 10 big concurrent requests without any issue', function _callee9() {
    var workerfarm, bigData, i, promises, _i2;

    return regeneratorRuntime.async(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            // This emulates the node.js ipc bug for win32
            workerfarm = new WorkerFarm({}, {
              warmWorkers: false,
              useLocalWorker: false,
              workerPath: require.resolve('./integration/workerfarm/echo.js')
            });
            bigData = [];

            for (i = 0; i < 10000; i++) {
              bigData.push('This is some big data');
            }

            promises = [];

            for (_i2 = 0; _i2 < 10; _i2++) {
              promises.push(workerfarm.run(bigData));
            }

            _context9.next = 7;
            return regeneratorRuntime.awrap(Promise.all(promises));

          case 7:
            _context9.next = 9;
            return regeneratorRuntime.awrap(workerfarm.end());

          case 9:
          case "end":
            return _context9.stop();
        }
      }
    });
  });
});