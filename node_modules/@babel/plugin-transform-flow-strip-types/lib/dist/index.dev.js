"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _pluginSyntaxFlow = _interopRequireDefault(require("@babel/plugin-syntax-flow"));

var _core = require("@babel/core");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var _default = (0, _helperPluginUtils.declare)(function (api, opts) {
  api.assertVersion(7);
  var FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
  var skipStrip = false;
  var _opts$requireDirectiv = opts.requireDirective,
      requireDirective = _opts$requireDirectiv === void 0 ? false : _opts$requireDirectiv,
      _opts$allowDeclareFie = opts.allowDeclareFields,
      allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
  return {
    name: "transform-flow-strip-types",
    inherits: _pluginSyntaxFlow["default"],
    visitor: {
      Program: function Program(path, _ref) {
        var comments = _ref.file.ast.comments;
        skipStrip = false;
        var directiveFound = false;

        if (comments) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = comments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var comment = _step.value;

              if (FLOW_DIRECTIVE.test(comment.value)) {
                directiveFound = true;
                comment.value = comment.value.replace(FLOW_DIRECTIVE, "");

                if (!comment.value.replace(/\*/g, "").trim()) {
                  comment.ignore = true;
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        if (!directiveFound && requireDirective) {
          skipStrip = true;
        }
      },
      ImportDeclaration: function ImportDeclaration(path) {
        if (skipStrip) return;
        if (!path.node.specifiers.length) return;
        var typeCount = 0;
        path.node.specifiers.forEach(function (_ref2) {
          var importKind = _ref2.importKind;

          if (importKind === "type" || importKind === "typeof") {
            typeCount++;
          }
        });

        if (typeCount === path.node.specifiers.length) {
          path.remove();
        }
      },
      Flow: function Flow(path) {
        if (skipStrip) {
          throw path.buildCodeFrameError("A @flow directive is required when using Flow annotations with " + "the `requireDirective` option.");
        }

        path.remove();
      },
      ClassPrivateProperty: function ClassPrivateProperty(path) {
        if (skipStrip) return;
        path.node.typeAnnotation = null;
      },
      Class: function Class(path) {
        if (skipStrip) return;
        path.node["implements"] = null;
        path.get("body.body").forEach(function (child) {
          if (child.isClassProperty()) {
            var node = child.node;

            if (!allowDeclareFields && node.declare) {
              throw child.buildCodeFrameError("The 'declare' modifier is only allowed when the " + "'allowDeclareFields' option of " + "@babel/plugin-transform-flow-strip-types or " + "@babel/preset-flow is enabled.");
            }

            if (node.declare) {
              child.remove();
            } else if (!allowDeclareFields && !node.value && !node.decorators) {
              child.remove();
            } else {
              node.variance = null;
              node.typeAnnotation = null;
            }
          }
        });
      },
      AssignmentPattern: function AssignmentPattern(_ref3) {
        var node = _ref3.node;
        if (skipStrip) return;
        node.left.optional = false;
      },
      Function: function Function(_ref4) {
        var node = _ref4.node;
        if (skipStrip) return;

        for (var i = 0; i < node.params.length; i++) {
          var param = node.params[i];
          param.optional = false;

          if (param.type === "AssignmentPattern") {
            param.left.optional = false;
          }
        }

        node.predicate = null;
      },
      TypeCastExpression: function TypeCastExpression(path) {
        if (skipStrip) return;
        var node = path.node;

        do {
          node = node.expression;
        } while (_core.types.isTypeCastExpression(node));

        path.replaceWith(node);
      },
      CallExpression: function CallExpression(_ref5) {
        var node = _ref5.node;
        if (skipStrip) return;
        node.typeArguments = null;
      },
      OptionalCallExpression: function OptionalCallExpression(_ref6) {
        var node = _ref6.node;
        if (skipStrip) return;
        node.typeArguments = null;
      },
      NewExpression: function NewExpression(_ref7) {
        var node = _ref7.node;
        if (skipStrip) return;
        node.typeArguments = null;
      }
    }
  };
});

exports["default"] = _default;