"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.helper = helper;

var t = _interopRequireWildcard(require("@babel/types"));

var _helperModuleImports = require("@babel/helper-module-imports");

var _helperAnnotateAsPure = _interopRequireDefault(require("@babel/helper-annotate-as-pure"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var DEFAULT = {
  importSource: "react",
  runtime: "automatic",
  pragma: "React.createElement",
  pragmaFrag: "React.Fragment"
};

function helper(babel, options) {
  var FILE_NAME_VAR = "_jsxFileName";
  var JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
  var JSX_RUNTIME_ANNOTATION_REGEX = /\*?\s*@jsxRuntime\s+([^\s]+)/;
  var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
  var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;
  var IMPORT_NAME_SIZE = options.development ? 3 : 4;
  var _options$importSource = options.importSource,
      IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT.importSource : _options$importSource,
      _options$runtime = options.runtime,
      RUNTIME_DEFAULT = _options$runtime === void 0 ? DEFAULT.runtime : _options$runtime,
      _options$pragma = options.pragma,
      PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT.pragma : _options$pragma,
      _options$pragmaFrag = options.pragmaFrag,
      PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT.pragmaFrag : _options$pragmaFrag;
  var injectMetaPropertiesVisitor = {
    JSXOpeningElement: function JSXOpeningElement(path, state) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = path.get("attributes")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var attr = _step.value;
          if (!attr.isJSXElement()) continue;
          var name = attr.node.name.name;

          if (name === "__source" || name === "__self") {
            throw path.buildCodeFrameError("__source and __self should not be defined in props and are reserved for internal usage.");
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var source = t.jsxAttribute(t.jsxIdentifier("__source"), t.jsxExpressionContainer(makeSource(path, state)));
      var self = t.jsxAttribute(t.jsxIdentifier("__self"), t.jsxExpressionContainer(t.thisExpression()));
      path.pushContainer("attributes", [source, self]);
    }
  };
  return {
    JSXNamespacedName: function JSXNamespacedName(path, state) {
      var throwIfNamespace = state.opts.throwIfNamespace === undefined ? true : !!state.opts.throwIfNamespace;

      if (throwIfNamespace) {
        throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
      }
    },
    JSXSpreadChild: function JSXSpreadChild(path) {
      throw path.buildCodeFrameError("Spread children are not supported in React.");
    },
    JSXElement: {
      exit: function exit(path, file) {
        var callExpr;

        if (file.get("@babel/plugin-react-jsx/runtime") === "classic" || shouldUseCreateElement(path)) {
          callExpr = buildCreateElementCall(path, file);
        } else {
          callExpr = buildJSXElementCall(path, file);
        }

        path.replaceWith(t.inherits(callExpr, path.node));
      }
    },
    JSXFragment: {
      exit: function exit(path, file) {
        var callExpr;

        if (file.get("@babel/plugin-react-jsx/runtime") === "classic") {
          callExpr = buildCreateElementFragmentCall(path, file);
        } else {
          callExpr = buildJSXFragmentCall(path, file);
        }

        path.replaceWith(t.inherits(callExpr, path.node));
      }
    },
    JSXAttribute: function JSXAttribute(path) {
      if (t.isJSXElement(path.node.value)) {
        path.node.value = t.jsxExpressionContainer(path.node.value);
      }
    },
    Program: {
      enter: function enter(path, state) {
        if (hasJSX(path)) {
          var file = state.file;
          var runtime = RUNTIME_DEFAULT;
          var source = IMPORT_SOURCE_DEFAULT;
          var sourceSet = !!options.importSource;
          var pragma = PRAGMA_DEFAULT;
          var pragmaFrag = PRAGMA_FRAG_DEFAULT;
          var pragmaSet = !!options.pragma;
          var pragmaFragSet = !!options.pragmaFrag;

          if (file.ast.comments) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = file.ast.comments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var comment = _step2.value;
                var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

                if (sourceMatches) {
                  source = sourceMatches[1];
                  sourceSet = true;
                }

                var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

                if (runtimeMatches) {
                  runtime = runtimeMatches[1];
                }

                var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

                if (jsxMatches) {
                  pragma = jsxMatches[1];
                  pragmaSet = true;
                }

                var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

                if (jsxFragMatches) {
                  pragmaFrag = jsxFragMatches[1];
                  pragmaFragSet = true;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }

          state.set("@babel/plugin-react-jsx/runtime", runtime);

          if (runtime === "classic") {
            if (sourceSet) {
              throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");
            }

            state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(pragma));
            state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(pragmaFrag));
            state.set("@babel/plugin-react-jsx/usedFragment", false);
            state.set("@babel/plugin-react-jsx/pragmaSet", pragma !== DEFAULT.pragma);
            state.set("@babel/plugin-react-jsx/pragmaFragSet", pragmaFrag !== DEFAULT.pragmaFrag);
          } else if (runtime === "automatic") {
            if (pragmaSet || pragmaFragSet) {
              throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
            }

            var importName = addAutoImports(path, Object.assign({}, state.opts, {
              source: source
            }));
            state.set("@babel/plugin-react-jsx/jsxIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsx", importName)));
            state.set("@babel/plugin-react-jsx/jsxStaticIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsxs", importName)));
            state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(createIdentifierName(path, "createElement", importName)));
            state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(createIdentifierName(path, "Fragment", importName)));
            state.set("@babel/plugin-react-jsx/importSourceSet", source !== DEFAULT.importSource);
          } else {
            throw path.buildCodeFrameError("Runtime must be either \"classic\" or \"automatic\".");
          }

          if (options.development) {
            path.traverse(injectMetaPropertiesVisitor, state);
          }
        }
      },
      exit: function exit(path, state) {
        if (state.get("@babel/plugin-react-jsx/runtime") === "classic" && state.get("@babel/plugin-react-jsx/pragmaSet") && state.get("@babel/plugin-react-jsx/usedFragment") && !state.get("@babel/plugin-react-jsx/pragmaFragSet")) {
          throw new Error("transform-react-jsx: pragma has been set but " + "pragmaFrag has not been set");
        }
      }
    }
  };

  function shouldUseCreateElement(path) {
    var openingPath = path.get("openingElement");
    var attributes = openingPath.node.attributes;
    var seenPropsSpread = false;

    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes[i];

      if (seenPropsSpread && t.isJSXAttribute(attr) && attr.name.name === "key") {
        return true;
      } else if (t.isJSXSpreadAttribute(attr)) {
        seenPropsSpread = true;
      }
    }

    return false;
  }

  function createIdentifierName(path, name, importName) {
    if ((0, _helperModuleImports.isModule)(path)) {
      var identifierName = "".concat(importName[name]);
      return identifierName;
    } else {
      return "".concat(importName[name], ".").concat(name);
    }
  }

  function getImportNames(parentPath) {
    var imports = new Set();
    parentPath.traverse({
      "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
        if (path.type === "JSXFragment") imports.add("Fragment");
        var openingPath = path.get("openingElement");
        var validChildren = t.react.buildChildren(openingPath.parent);
        var importName;

        if (path.type === "JSXElement" && shouldUseCreateElement(path)) {
          importName = "createElement";
        } else if (options.development) {
          importName = "jsxDEV";
        } else if (validChildren.length > 1) {
          importName = "jsxs";
        } else {
          importName = "jsx";
        }

        imports.add(importName);

        if (imports.size === IMPORT_NAME_SIZE) {
          path.stop();
        }
      }
    });
    return imports;
  }

  function hasJSX(parentPath) {
    var fileHasJSX = false;
    parentPath.traverse({
      "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
        fileHasJSX = true;
        path.stop();
      }
    });
    return fileHasJSX;
  }

  function getSource(source, importName) {
    switch (importName) {
      case "Fragment":
        return "".concat(source, "/").concat(options.development ? "jsx-dev-runtime" : "jsx-runtime");

      case "jsxDEV":
        return "".concat(source, "/jsx-dev-runtime");

      case "jsx":
      case "jsxs":
        return "".concat(source, "/jsx-runtime");

      case "createElement":
        return source;
    }
  }

  function addAutoImports(path, state) {
    var imports = getImportNames(path, state);

    if ((0, _helperModuleImports.isModule)(path)) {
      var importMap = {};
      imports.forEach(function (importName) {
        if (!importMap[importName]) {
          importMap[importName] = (0, _helperModuleImports.addNamed)(path, importName, getSource(state.source, importName), {
            importedInterop: "uncompiled",
            ensureLiveReference: true
          }).name;
        }
      });
      return importMap;
    } else {
      var _importMap = {};
      var sourceMap = {};
      imports.forEach(function (importName) {
        var source = getSource(state.source, importName);

        if (!_importMap[importName]) {
          if (!sourceMap[source]) {
            sourceMap[source] = (0, _helperModuleImports.addNamespace)(path, source, {
              importedInterop: "uncompiled",
              ensureLiveReference: true
            }).name;
          }

          _importMap[importName] = sourceMap[source];
        }
      });
      return _importMap;
    }
  }

  function createIdentifierParser(id) {
    return function () {
      return id.split(".").map(function (name) {
        return t.identifier(name);
      }).reduce(function (object, property) {
        return t.memberExpression(object, property);
      });
    };
  }

  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
    var fileLineLiteral = lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();
    var fileColumnLiteral = column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();
    var fileNameProperty = t.objectProperty(t.identifier("fileName"), fileNameIdentifier);
    var lineNumberProperty = t.objectProperty(t.identifier("lineNumber"), fileLineLiteral);
    var columnNumberProperty = t.objectProperty(t.identifier("columnNumber"), fileColumnLiteral);
    return t.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
  }

  function makeSource(path, state) {
    var location = path.node.loc;

    if (!location) {
      return path.scope.buildUndefinedNode();
    }

    if (!state.fileNameIdentifier) {
      var _state$filename = state.filename,
          filename = _state$filename === void 0 ? "" : _state$filename;
      var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
      var scope = path.hub.getScope();

      if (scope) {
        scope.push({
          id: fileNameIdentifier,
          init: t.stringLiteral(filename)
        });
      }

      state.fileNameIdentifier = fileNameIdentifier;
    }

    return makeTrace(t.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
  }

  function convertJSXIdentifier(node, parent) {
    if (t.isJSXIdentifier(node)) {
      if (node.name === "this" && t.isReferenced(node, parent)) {
        return t.thisExpression();
      } else if (t.isValidIdentifier(node.name, false)) {
        node.type = "Identifier";
      } else {
        return t.stringLiteral(node.name);
      }
    } else if (t.isJSXMemberExpression(node)) {
      return t.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
    } else if (t.isJSXNamespacedName(node)) {
      return t.stringLiteral("".concat(node.namespace.name, ":").concat(node.name.name));
    }

    return node;
  }

  function convertAttributeValue(node) {
    if (t.isJSXExpressionContainer(node)) {
      return node.expression;
    } else {
      return node;
    }
  }

  function convertAttribute(node) {
    var value = convertAttributeValue(node.value || t.booleanLiteral(true));

    if (t.isJSXSpreadAttribute(node)) {
      return t.spreadElement(node.argument);
    }

    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {
      value.value = value.value.replace(/\n\s+/g, " ");

      if (value.extra && value.extra.raw) {
        delete value.extra.raw;
      }
    }

    if (t.isJSXNamespacedName(node.name)) {
      node.name = t.stringLiteral(node.name.namespace.name + ":" + node.name.name.name);
    } else if (t.isValidIdentifier(node.name.name, false)) {
      node.name.type = "Identifier";
    } else {
      node.name = t.stringLiteral(node.name.name);
    }

    return t.inherits(t.objectProperty(node.name, value), node);
  }

  function buildJSXElementCall(path, file) {
    var openingPath = path.get("openingElement");
    openingPath.parent.children = t.react.buildChildren(openingPath.parent);
    var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
    var args = [];
    var tagName;

    if (t.isIdentifier(tagExpr)) {
      tagName = tagExpr.name;
    } else if (t.isLiteral(tagExpr)) {
      tagName = tagExpr.value;
    }

    var state = {
      tagExpr: tagExpr,
      tagName: tagName,
      args: args,
      pure: false
    };

    if (options.pre) {
      options.pre(state, file);
    }

    var attribs = [];
    var extracted = Object.create(null);
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = openingPath.get("attributes")[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var attr = _step3.value;

        if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {
          var name = attr.node.name.name;

          switch (name) {
            case "__source":
            case "__self":
              if (extracted[name]) throw sourceSelfError(path, name);

            case "key":
              extracted[name] = convertAttributeValue(attr.node.value);
              break;

            default:
              attribs.push(attr.node);
          }
        } else {
          attribs.push(attr.node);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    if (attribs.length || path.node.children.length) {
      attribs = buildJSXOpeningElementAttributes(attribs, file, path.node.children);
    } else {
      attribs = t.objectExpression([]);
    }

    args.push(attribs);

    if (!options.development) {
      if (extracted.key !== undefined) {
        args.push(extracted.key);
      }
    } else {
      var _extracted$key, _extracted$__source, _extracted$__self;

      args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : t.thisExpression());
    }

    if (options.post) {
      options.post(state, file);
    }

    var call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);
    if (state.pure) (0, _helperAnnotateAsPure["default"])(call);
    return call;
  }

  function buildJSXOpeningElementAttributes(attribs, file, children) {
    var props = attribs.map(convertAttribute);

    if (children && children.length > 0) {
      if (children.length === 1) {
        props.push(t.objectProperty(t.identifier("children"), children[0]));
      } else {
        props.push(t.objectProperty(t.identifier("children"), t.arrayExpression(children)));
      }
    }

    return t.objectExpression(props);
  }

  function buildJSXFragmentCall(path, file) {
    var openingPath = path.get("openingElement");
    openingPath.parent.children = t.react.buildChildren(openingPath.parent);
    var args = [];
    var tagName = null;
    var tagExpr = file.get("@babel/plugin-react-jsx/jsxFragIdentifier")();
    var state = {
      tagExpr: tagExpr,
      tagName: tagName,
      args: args,
      pure: false
    };

    if (options.pre) {
      options.pre(state, file);
    }

    var childrenNode;

    if (path.node.children.length > 0) {
      if (path.node.children.length === 1) {
        childrenNode = path.node.children[0];
      } else {
        childrenNode = t.arrayExpression(path.node.children);
      }
    }

    args.push(t.objectExpression(childrenNode !== undefined ? [t.objectProperty(t.identifier("children"), childrenNode)] : []));

    if (options.development) {
      args.push(path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1));
    }

    if (options.post) {
      options.post(state, file);
    }

    var call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);
    if (state.pure) (0, _helperAnnotateAsPure["default"])(call);
    return call;
  }

  function buildCreateElementFragmentCall(path, file) {
    if (options.filter && !options.filter(path.node, file)) {
      return;
    }

    var openingPath = path.get("openingElement");
    openingPath.parent.children = t.react.buildChildren(openingPath.parent);
    var args = [];
    var tagName = null;
    var tagExpr = file.get("@babel/plugin-react-jsx/jsxFragIdentifier")();
    var state = {
      tagExpr: tagExpr,
      tagName: tagName,
      args: args,
      pure: false
    };

    if (options.pre) {
      options.pre(state, file);
    }

    args.push.apply(args, [t.nullLiteral()].concat(_toConsumableArray(path.node.children)));

    if (options.post) {
      options.post(state, file);
    }

    file.set("@babel/plugin-react-jsx/usedFragment", true);
    var call = state.call || t.callExpression(state.createElementCallee, args);
    if (state.pure) (0, _helperAnnotateAsPure["default"])(call);
    return call;
  }

  function buildCreateElementCall(path, file) {
    var openingPath = path.get("openingElement");
    openingPath.parent.children = t.react.buildChildren(openingPath.parent);
    var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
    var args = [];
    var tagName;

    if (t.isIdentifier(tagExpr)) {
      tagName = tagExpr.name;
    } else if (t.isLiteral(tagExpr)) {
      tagName = tagExpr.value;
    }

    var state = {
      tagExpr: tagExpr,
      tagName: tagName,
      args: args,
      pure: false
    };

    if (options.pre) {
      options.pre(state, file);
    }

    var attribs = buildCreateElementOpeningElementAttributes(path, openingPath.node.attributes);
    args.push.apply(args, [attribs].concat(_toConsumableArray(path.node.children)));

    if (options.post) {
      options.post(state, file);
    }

    var call = state.call || t.callExpression(state.createElementCallee, args);
    if (state.pure) (0, _helperAnnotateAsPure["default"])(call);
    return call;
  }

  function buildCreateElementOpeningElementAttributes(path, attribs) {
    var props = [];
    var found = Object.create(null);
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = attribs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var attr = _step4.value;
        var name = t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name) && attr.name.name;

        if (name === "__source" || name === "__self") {
          if (found[name]) throw sourceSelfError(path, name);
          found[name] = true;
          if (!options.development) continue;
        }

        props.push(convertAttribute(attr));
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    return props.length > 0 ? t.objectExpression(props) : t.nullLiteral();
  }

  function sourceSelfError(path, name) {
    var pluginName = "transform-react-jsx-".concat(name.slice(2));
    return path.buildCodeFrameError("Duplicate ".concat(name, " prop found. You are most likely using the deprecated ").concat(pluginName, " Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config."));
  }
}