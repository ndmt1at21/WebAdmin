'use strict'; // TODO: Use the `URL` global when targeting Node.js 10

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var URLParser = typeof URL === 'undefined' ? require('url').URL : URL; // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs

var DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
var DATA_URL_DEFAULT_CHARSET = 'us-ascii';

var testParameter = function testParameter(name, filters) {
  return filters.some(function (filter) {
    return filter instanceof RegExp ? filter.test(name) : filter === name;
  });
};

var normalizeDataURL = function normalizeDataURL(urlString, _ref) {
  var stripHash = _ref.stripHash;
  var parts = urlString.match(/^data:(.*?),(.*?)(?:#(.*))?$/);

  if (!parts) {
    throw new Error("Invalid URL: ".concat(urlString));
  }

  var mediaType = parts[1].split(';');
  var body = parts[2];
  var hash = stripHash ? '' : parts[3];
  var base64 = false;

  if (mediaType[mediaType.length - 1] === 'base64') {
    mediaType.pop();
    base64 = true;
  } // Lowercase MIME type


  var mimeType = (mediaType.shift() || '').toLowerCase();
  var attributes = mediaType.map(function (attribute) {
    var _attribute$split$map = attribute.split('=').map(function (string) {
      return string.trim();
    }),
        _attribute$split$map2 = _slicedToArray(_attribute$split$map, 2),
        key = _attribute$split$map2[0],
        _attribute$split$map3 = _attribute$split$map2[1],
        value = _attribute$split$map3 === void 0 ? '' : _attribute$split$map3; // Lowercase `charset`


    if (key === 'charset') {
      value = value.toLowerCase();

      if (value === DATA_URL_DEFAULT_CHARSET) {
        return '';
      }
    }

    return "".concat(key).concat(value ? "=".concat(value) : '');
  }).filter(Boolean);

  var normalizedMediaType = _toConsumableArray(attributes);

  if (base64) {
    normalizedMediaType.push('base64');
  }

  if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }

  return "data:".concat(normalizedMediaType.join(';'), ",").concat(base64 ? body.trim() : body).concat(hash ? "#".concat(hash) : '');
};

var normalizeUrl = function normalizeUrl(urlString, options) {
  options = _objectSpread({
    defaultProtocol: 'http:',
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeDirectoryIndex: false,
    sortQueryParameters: true
  }, options); // TODO: Remove this at some point in the future

  if (Reflect.has(options, 'normalizeHttps')) {
    throw new Error('options.normalizeHttps is renamed to options.forceHttp');
  }

  if (Reflect.has(options, 'normalizeHttp')) {
    throw new Error('options.normalizeHttp is renamed to options.forceHttps');
  }

  if (Reflect.has(options, 'stripFragment')) {
    throw new Error('options.stripFragment is renamed to options.stripHash');
  }

  urlString = urlString.trim(); // Data URL

  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }

  var hasRelativeProtocol = urlString.startsWith('//');
  var isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString); // Prepend protocol

  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }

  var urlObj = new URLParser(urlString);

  if (options.forceHttp && options.forceHttps) {
    throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
  }

  if (options.forceHttp && urlObj.protocol === 'https:') {
    urlObj.protocol = 'http:';
  }

  if (options.forceHttps && urlObj.protocol === 'http:') {
    urlObj.protocol = 'https:';
  } // Remove auth


  if (options.stripAuthentication) {
    urlObj.username = '';
    urlObj.password = '';
  } // Remove hash


  if (options.stripHash) {
    urlObj.hash = '';
  } // Remove duplicate slashes if not preceded by a protocol


  if (urlObj.pathname) {
    // TODO: Use the following instead when targeting Node.js 10
    // `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
    urlObj.pathname = urlObj.pathname.replace(/((?!:).|^)\/{2,}/g, function (_, p1) {
      if (/^(?!\/)/g.test(p1)) {
        return "".concat(p1, "/");
      }

      return '/';
    });
  } // Decode URI octets


  if (urlObj.pathname) {
    urlObj.pathname = decodeURI(urlObj.pathname);
  } // Remove directory index


  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }

  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    var pathComponents = urlObj.pathname.split('/');
    var lastComponent = pathComponents[pathComponents.length - 1];

    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, pathComponents.length - 1);
      urlObj.pathname = pathComponents.slice(1).join('/') + '/';
    }
  }

  if (urlObj.hostname) {
    // Remove trailing dot
    urlObj.hostname = urlObj.hostname.replace(/\.$/, ''); // Remove `www.`

    if (options.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(urlObj.hostname)) {
      // Each label should be max 63 at length (min: 2).
      // The extension should be max 5 at length (min: 2).
      // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
      urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
    }
  } // Remove query unwanted parameters


  if (Array.isArray(options.removeQueryParameters)) {
    for (var _i2 = 0, _arr2 = _toConsumableArray(urlObj.searchParams.keys()); _i2 < _arr2.length; _i2++) {
      var key = _arr2[_i2];

      if (testParameter(key, options.removeQueryParameters)) {
        urlObj.searchParams["delete"](key);
      }
    }
  } // Sort query parameters


  if (options.sortQueryParameters) {
    urlObj.searchParams.sort();
  }

  if (options.removeTrailingSlash) {
    urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
  } // Take advantage of many of the Node `url` normalizations


  urlString = urlObj.toString(); // Remove ending `/`

  if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '') {
    urlString = urlString.replace(/\/$/, '');
  } // Restore relative protocol, if applicable


  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, '//');
  } // Remove http/https


  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, '');
  }

  return urlString;
};

module.exports = normalizeUrl; // TODO: Remove this for the next major release

module.exports["default"] = normalizeUrl;