'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var stringWidth = require('string-width');

var chalk = require('chalk');

var widestLine = require('widest-line');

var cliBoxes = require('cli-boxes');

var camelCase = require('camelcase');

var ansiAlign = require('ansi-align');

var termSize = require('term-size');

var getObject = function getObject(detail) {
  var object;

  if (typeof detail === 'number') {
    object = {
      top: detail,
      right: detail * 3,
      bottom: detail,
      left: detail * 3
    };
  } else {
    object = _objectSpread({
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, detail);
  }

  return object;
};

var getBorderChars = function getBorderChars(borderStyle) {
  var sides = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft', 'vertical', 'horizontal'];
  var chararacters;

  if (typeof borderStyle === 'string') {
    chararacters = cliBoxes[borderStyle];

    if (!chararacters) {
      throw new TypeError("Invalid border style: ".concat(borderStyle));
    }
  } else {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = sides[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var side = _step.value;

        if (!borderStyle[side] || typeof borderStyle[side] !== 'string') {
          throw new TypeError("Invalid border style: ".concat(side));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    chararacters = borderStyle;
  }

  return chararacters;
};

var isHex = function isHex(color) {
  return color.match(/^#[0-f]{3}(?:[0-f]{3})?$/i);
};

var isColorValid = function isColorValid(color) {
  return typeof color === 'string' && (chalk[color] || isHex(color));
};

var getColorFn = function getColorFn(color) {
  return isHex(color) ? chalk.hex(color) : chalk[color];
};

var getBGColorFn = function getBGColorFn(color) {
  return isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];
};

module.exports = function (text, options) {
  options = _objectSpread({
    padding: 0,
    borderStyle: 'single',
    dimBorder: false,
    align: 'left',
    "float": 'left'
  }, options);

  if (options.borderColor && !isColorValid(options.borderColor)) {
    throw new Error("".concat(options.borderColor, " is not a valid borderColor"));
  }

  if (options.backgroundColor && !isColorValid(options.backgroundColor)) {
    throw new Error("".concat(options.backgroundColor, " is not a valid backgroundColor"));
  }

  var chars = getBorderChars(options.borderStyle);
  var padding = getObject(options.padding);
  var margin = getObject(options.margin);

  var colorizeBorder = function colorizeBorder(border) {
    var newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;
    return options.dimBorder ? chalk.dim(newBorder) : newBorder;
  };

  var colorizeContent = function colorizeContent(content) {
    return options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;
  };

  text = ansiAlign(text, {
    align: options.align
  });
  var NL = '\n';
  var PAD = ' ';
  var lines = text.split(NL);

  if (padding.top > 0) {
    lines = new Array(padding.top).fill('').concat(lines);
  }

  if (padding.bottom > 0) {
    lines = lines.concat(new Array(padding.bottom).fill(''));
  }

  var contentWidth = widestLine(text) + padding.left + padding.right;
  var paddingLeft = PAD.repeat(padding.left);

  var _termSize = termSize(),
      columns = _termSize.columns;

  var marginLeft = PAD.repeat(margin.left);

  if (options["float"] === 'center') {
    var padWidth = Math.max((columns - contentWidth) / 2, 0);
    marginLeft = PAD.repeat(padWidth);
  } else if (options["float"] === 'right') {
    var _padWidth = Math.max(columns - contentWidth - margin.right - 2, 0);

    marginLeft = PAD.repeat(_padWidth);
  }

  var horizontal = chars.horizontal.repeat(contentWidth);
  var top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + horizontal + chars.topRight);
  var bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));
  var side = colorizeBorder(chars.vertical);
  var middle = lines.map(function (line) {
    var paddingRight = PAD.repeat(contentWidth - stringWidth(line) - padding.left);
    return marginLeft + side + colorizeContent(paddingLeft + line + paddingRight) + side;
  }).join(NL);
  return top + NL + middle + NL + bottom;
};

module.exports._borderStyles = cliBoxes;