"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var t = __importStar(require("@babel/types"));

if (!(Array.isArray(t.TYPES) && t.TYPES.every(function (t) {
  return typeof t === 'string';
}))) {
  throw new Error('@babel/types TYPES does not match the expected type.');
}

var FLIPPED_ALIAS_KEYS = t.FLIPPED_ALIAS_KEYS;
var TYPES = new Set(t.TYPES);

if (!(FLIPPED_ALIAS_KEYS && // tslint:disable-next-line: strict-type-predicates
_typeof(FLIPPED_ALIAS_KEYS) === 'object' && Object.keys(FLIPPED_ALIAS_KEYS).every(function (key) {
  return Array.isArray(FLIPPED_ALIAS_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates
  FLIPPED_ALIAS_KEYS[key].every(function (v) {
    return typeof v === 'string';
  });
}))) {
  throw new Error('@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.');
}
/**
 * This serves thre functions:
 *
 * 1. Take any "aliases" and explode them to refecence the concrete types
 * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions
 * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged
 */


function explode(input) {
  var results = {};

  for (var key in input) {
    var aliases = FLIPPED_ALIAS_KEYS[key];

    if (aliases) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var concreteKey = _step.value;

          if (concreteKey in results) {
            if (typeof input[key] === 'function') {
              results[concreteKey].enter.push(input[key]);
            } else {
              if (input[key].enter) results[concreteKey].enter.push(input[key].enter);
              if (input[key].exit) results[concreteKey].exit.push(input[key].exit);
            }
          } else {
            if (typeof input[key] === 'function') {
              results[concreteKey] = {
                enter: [input[key]],
                exit: []
              };
            } else {
              results[concreteKey] = {
                enter: input[key].enter ? [input[key].enter] : [],
                exit: input[key].exit ? [input[key].exit] : []
              };
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else if (TYPES.has(key)) {
      if (key in results) {
        if (typeof input[key] === 'function') {
          results[key].enter.push(input[key]);
        } else {
          if (input[key].enter) results[key].enter.push(input[key].enter);
          if (input[key].exit) results[key].exit.push(input[key].exit);
        }
      } else {
        if (typeof input[key] === 'function') {
          results[key] = {
            enter: [input[key]],
            exit: []
          };
        } else {
          results[key] = {
            enter: input[key].enter ? [input[key].enter] : [],
            exit: input[key].exit ? [input[key].exit] : []
          };
        }
      }
    }
  }

  return results;
}

exports["default"] = explode;