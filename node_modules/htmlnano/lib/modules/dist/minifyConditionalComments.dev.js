"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = minifyConditionalComments;

var _htmlnano = _interopRequireDefault(require("../htmlnano"));

var _helpers = require("../helpers");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // Spec: https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/ms537512(v=vs.85)


var CONDITIONAL_COMMENT_REGEXP = /(<!--\[if\s+?[^<>[\]]+?]>)([\s\S]+?)(<!\[endif\]-->)/gm;
/** Minify content inside conditional comments */

function minifyConditionalComments(tree, htmlnanoOptions) {
  var i, len, node;
  return regeneratorRuntime.async(function minifyConditionalComments$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          i = 0, len = tree.length;

        case 1:
          if (!(i < len)) {
            _context.next = 14;
            break;
          }

          node = tree[i];

          if (!(typeof node === 'string' && (0, _helpers.isConditionalComment)(node))) {
            _context.next = 7;
            break;
          }

          _context.next = 6;
          return regeneratorRuntime.awrap(minifycontentInsideConditionalComments(node, htmlnanoOptions));

        case 6:
          tree[i] = _context.sent;

        case 7:
          if (!(node.content && node.content.length)) {
            _context.next = 11;
            break;
          }

          _context.next = 10;
          return regeneratorRuntime.awrap(minifyConditionalComments(node.content, htmlnanoOptions));

        case 10:
          tree[i].content = _context.sent;

        case 11:
          i++;
          _context.next = 1;
          break;

        case 14:
          return _context.abrupt("return", tree);

        case 15:
        case "end":
          return _context.stop();
      }
    }
  });
}

function minifycontentInsideConditionalComments(text, htmlnanoOptions) {
  var match, matches;
  return regeneratorRuntime.async(function minifycontentInsideConditionalComments$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          matches = []; // FIXME!
          // String#matchAll is supported since Node.js 12

          while ((match = CONDITIONAL_COMMENT_REGEXP.exec(text)) !== null) {
            matches.push([match[1], match[2], match[3]]);
          }

          if (matches.length) {
            _context3.next = 4;
            break;
          }

          return _context3.abrupt("return", Promise.resolve(text));

        case 4:
          return _context3.abrupt("return", Promise.all(matches.map(function _callee(match) {
            var result;
            return regeneratorRuntime.async(function _callee$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return regeneratorRuntime.awrap(_htmlnano["default"].process(match[1], htmlnanoOptions, {}, {}));

                  case 2:
                    result = _context2.sent;
                    return _context2.abrupt("return", match[0] + result.html + match[2]);

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            });
          })));

        case 5:
        case "end":
          return _context3.stop();
      }
    }
  });
}