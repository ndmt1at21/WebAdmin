"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('htmlparser2'),
    Parser = _require.Parser;
/**
 * @see https://github.com/fb55/htmlparser2/wiki/Parser-options
 */


var defaultOptions = {
  lowerCaseTags: false,
  lowerCaseAttributeNames: false,
  decodeEntities: false
};
var defaultDirectives = [{
  name: '!doctype',
  start: '<',
  end: '>'
}];
/**
 * Parse html to PostHTMLTree
 * @param  {String} html
 * @param  {Object} [options=defaultOptions]
 * @return {PostHTMLTree}
 */

function postHTMLParser(html, options) {
  var bufArray = [];
  var results = [];

  bufArray.last = function () {
    return this[this.length - 1];
  };

  function isDirective(_ref, tag) {
    var name = _ref.name;

    if (name instanceof RegExp) {
      var regex = new RegExp(name.source, 'i');
      return regex.test(tag);
    }

    if (tag !== name) {
      return false;
    }

    return true;
  }

  function parserDirective(name, data) {
    var directives = [].concat(defaultDirectives, options.directives || []);
    var last = bufArray.last();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var directive = _step.value;
        var directiveText = directive.start + data + directive.end;
        name = name.toLowerCase();

        if (isDirective(directive, name)) {
          if (!last) {
            results.push(directiveText);
            return;
          }

          if (last.content === undefined) {
            last.content = [];
          }

          last.content.push(directiveText);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  function normalizeArributes(attrs) {
    var result = {};
    Object.keys(attrs).forEach(function (key) {
      var object = {};
      object[key] = attrs[key].replace(/&quot;/g, '"');
      Object.assign(result, object);
    });
    return result;
  }

  var parser = new Parser({
    onprocessinginstruction: parserDirective,
    oncomment: function oncomment(data) {
      var comment = "<!--".concat(data, "-->");
      var last = bufArray.last();

      if (!last) {
        results.push(comment);
        return;
      }

      if (last.content === undefined) {
        last.content = [];
      }

      last.content.push(comment);
    },
    onopentag: function onopentag(tag, attrs) {
      var buf = {
        tag: tag
      };

      if (Object.keys(attrs).length > 0) {
        buf.attrs = normalizeArributes(attrs);
      }

      bufArray.push(buf);
    },
    onclosetag: function onclosetag() {
      var buf = bufArray.pop();

      if (!bufArray.length > 0) {
        results.push(buf);
        return;
      }

      var last = bufArray.last();

      if (!Array.isArray(last.content)) {
        last.content = [];
      }

      last.content.push(buf);
    },
    ontext: function ontext(text) {
      var last = bufArray.last();

      if (!last) {
        results.push(text);
        return;
      }

      if (last.content && last.content.length > 0 && typeof last.content[last.content.length - 1] === 'string') {
        last.content[last.content.length - 1] = "".concat(last.content[last.content.length - 1]).concat(text);
        return;
      }

      if (last.content === undefined) {
        last.content = [];
      }

      last.content.push(text);
    }
  }, options || defaultOptions);
  parser.write(html);
  parser.end();
  return results;
}

function parserWrapper() {
  var option;

  function parser(html) {
    var opt = _objectSpread({}, defaultOptions, {}, option);

    return postHTMLParser(html, opt);
  }

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 1 && Boolean(args[0]) && args[0].constructor.name === 'Object') {
    option = args[0];
    return parser;
  }

  option = args[1];
  return parser(args[0]);
}

module.exports = parserWrapper;
module.exports.defaultOptions = defaultOptions;
module.exports.defaultDirectives = defaultDirectives;