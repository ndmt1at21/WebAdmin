'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EE = require('events').EventEmitter;

var cons = require('constants');

var fs = require('fs');

module.exports = function (f, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  var p = new Promise(function (res, rej) {
    new Touch(validOpts(options, f, null)).on('done', res).on('error', rej);
  });
  return cb ? p.then(function (res) {
    return cb(null, res);
  }, cb) : p;
};

module.exports.sync = module.exports.touchSync = function (f, options) {
  return new TouchSync(validOpts(options, f, null)), undefined;
};

module.exports.ftouch = function (fd, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  var p = new Promise(function (res, rej) {
    new Touch(validOpts(options, null, fd)).on('done', res).on('error', rej);
  });
  return cb ? p.then(function (res) {
    return cb(null, res);
  }, cb) : p;
};

module.exports.ftouchSync = function (fd, opt) {
  return new TouchSync(validOpts(opt, null, fd)), undefined;
};

var validOpts = function validOpts(options, path, fd) {
  options = Object.create(options || {});
  options.fd = fd;
  options.path = path; // {mtime: true}, {ctime: true}
  // If set to something else, then treat as epoch ms value

  var now = parseInt(new Date(options.time || Date.now()).getTime() / 1000);
  if (!options.atime && !options.mtime) options.atime = options.mtime = now;else {
    if (true === options.atime) options.atime = now;
    if (true === options.mtime) options.mtime = now;
  }
  var oflags = 0;
  if (!options.force) oflags = oflags | cons.O_RDWR;
  if (!options.nocreate) oflags = oflags | cons.O_CREAT;
  options.oflags = oflags;
  return options;
};

var Touch =
/*#__PURE__*/
function (_EE) {
  _inherits(Touch, _EE);

  function Touch(options) {
    var _this;

    _classCallCheck(this, Touch);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Touch).call(this, options));
    _this.fd = options.fd;
    _this.path = options.path;
    _this.atime = options.atime;
    _this.mtime = options.mtime;
    _this.ref = options.ref;
    _this.nocreate = !!options.nocreate;
    _this.force = !!options.force;
    _this.closeAfter = options.closeAfter;
    _this.oflags = options.oflags;
    _this.options = options;

    if (typeof _this.fd !== 'number') {
      _this.closeAfter = true;

      _this.open();
    } else _this.onopen(null, _this.fd);

    return _this;
  }

  _createClass(Touch, [{
    key: "emit",
    value: function emit(ev, data) {
      // we only emit when either done or erroring
      // in both cases, need to close
      this.close();
      return _get(_getPrototypeOf(Touch.prototype), "emit", this).call(this, ev, data);
    }
  }, {
    key: "close",
    value: function close() {
      if (typeof this.fd === 'number' && this.closeAfter) fs.close(this.fd, function () {});
    }
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;

      fs.open(this.path, this.oflags, function (er, fd) {
        return _this2.onopen(er, fd);
      });
    }
  }, {
    key: "onopen",
    value: function onopen(er, fd) {
      if (er) {
        if (er.code === 'EISDIR') this.onopen(null, null);else if (er.code === 'ENOENT' && this.nocreate) this.emit('done');else this.emit('error', er);
      } else {
        this.fd = fd;
        if (this.ref) this.statref();else if (!this.atime || !this.mtime) this.fstat();else this.futimes();
      }
    }
  }, {
    key: "statref",
    value: function statref() {
      var _this3 = this;

      fs.stat(this.ref, function (er, st) {
        if (er) _this3.emit('error', er);else _this3.onstatref(st);
      });
    }
  }, {
    key: "onstatref",
    value: function onstatref(st) {
      this.atime = this.atime && parseInt(st.atime.getTime() / 1000, 10);
      this.mtime = this.mtime && parseInt(st.mtime.getTime() / 1000, 10);
      if (!this.atime || !this.mtime) this.fstat();else this.futimes();
    }
  }, {
    key: "fstat",
    value: function fstat() {
      var _this4 = this;

      var stat = this.fd ? 'fstat' : 'stat';
      var target = this.fd || this.path;
      fs[stat](target, function (er, st) {
        if (er) _this4.emit('error', er);else _this4.onfstat(st);
      });
    }
  }, {
    key: "onfstat",
    value: function onfstat(st) {
      if (typeof this.atime !== 'number') this.atime = parseInt(st.atime.getTime() / 1000, 10);
      if (typeof this.mtime !== 'number') this.mtime = parseInt(st.mtime.getTime() / 1000, 10);
      this.futimes();
    }
  }, {
    key: "futimes",
    value: function futimes() {
      var _this5 = this;

      var utimes = this.fd ? 'futimes' : 'utimes';
      var target = this.fd || this.path;
      fs[utimes](target, '' + this.atime, '' + this.mtime, function (er) {
        if (er) _this5.emit('error', er);else _this5.emit('done');
      });
    }
  }]);

  return Touch;
}(EE);

var TouchSync =
/*#__PURE__*/
function (_Touch) {
  _inherits(TouchSync, _Touch);

  function TouchSync() {
    _classCallCheck(this, TouchSync);

    return _possibleConstructorReturn(this, _getPrototypeOf(TouchSync).apply(this, arguments));
  }

  _createClass(TouchSync, [{
    key: "open",
    value: function open() {
      try {
        this.onopen(null, fs.openSync(this.path, this.oflags));
      } catch (er) {
        this.onopen(er);
      }
    }
  }, {
    key: "statref",
    value: function statref() {
      var threw = true;

      try {
        this.onstatref(fs.statSync(this.ref));
        threw = false;
      } finally {
        if (threw) this.close();
      }
    }
  }, {
    key: "fstat",
    value: function fstat() {
      var threw = true;
      var stat = this.fd ? 'fstatSync' : 'statSync';
      var target = this.fd || this.path;

      try {
        this.onfstat(fs[stat](target));
        threw = false;
      } finally {
        if (threw) this.close();
      }
    }
  }, {
    key: "futimes",
    value: function futimes() {
      var threw = true;
      var utimes = this.fd ? 'futimesSync' : 'utimesSync';
      var target = this.fd || this.path;

      try {
        fs[utimes](target, this.atime, this.mtime);
        threw = false;
      } finally {
        if (threw) this.close();
      }

      this.emit('done');
    }
  }, {
    key: "close",
    value: function close() {
      if (typeof this.fd === 'number' && this.closeAfter) try {
        fs.closeSync(this.fd);
      } catch (er) {}
    }
  }]);

  return TouchSync;
}(Touch);