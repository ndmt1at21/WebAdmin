"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var HTTP_STATUS_CODES = require("http").STATUS_CODES;

var _require = require("child_process"),
    spawnSync = _require.spawnSync;

var _require2 = require("whatwg-url"),
    URL = _require2.URL;

var whatwgEncoding = require("whatwg-encoding");

var tough = require("tough-cookie");

var MIMEType = require("whatwg-mimetype");

var conversions = require("webidl-conversions");

var xhrUtils = require("./xhr-utils");

var DOMException = require("domexception");

var xhrSymbols = require("./xmlhttprequest-symbols");

var _require3 = require("../utils"),
    addConstants = _require3.addConstants;

var _require4 = require("./helpers/document-base-url"),
    documentBaseURLSerialized = _require4.documentBaseURLSerialized;

var _require5 = require("./helpers/strings"),
    asciiCaseInsensitiveMatch = _require5.asciiCaseInsensitiveMatch;

var idlUtils = require("./generated/utils");

var Document = require("./generated/Document");

var Blob = require("./generated/Blob");

var FormData = require("./generated/FormData");

var XMLHttpRequestEventTarget = require("./generated/XMLHttpRequestEventTarget");

var XMLHttpRequestUpload = require("./generated/XMLHttpRequestUpload");

var ProgressEvent = require("./generated/ProgressEvent");

var _require6 = require("../browser/parser"),
    parseIntoDocument = _require6.parseIntoDocument;

var _require7 = require("./domparsing/serialization"),
    fragmentSerialization = _require7.fragmentSerialization;

var _require8 = require("./helpers/create-event-accessor"),
    setupForSimpleEventAccessors = _require8.setupForSimpleEventAccessors;

var _require9 = require("./helpers/json"),
    parseJSONFromBytes = _require9.parseJSONFromBytes;

var _require10 = require("./helpers/events"),
    fireAnEvent = _require10.fireAnEvent;

var syncWorkerFile = require.resolve ? require.resolve("./xhr-sync-worker.js") : null;
var tokenRegexp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
var fieldValueRegexp = /^[ \t]*(?:[\x21-\x7E\x80-\xFF](?:[ \t][\x21-\x7E\x80-\xFF])?)*[ \t]*$/;
var forbiddenRequestHeaders = new Set(["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"]);
var forbiddenResponseHeaders = new Set(["set-cookie", "set-cookie2"]);
var uniqueResponseHeaders = new Set(["content-type", "content-length", "user-agent", "referer", "host", "authorization", "proxy-authorization", "if-modified-since", "if-unmodified-since", "from", "location", "max-forwards"]);
var corsSafeResponseHeaders = new Set(["cache-control", "content-language", "content-type", "expires", "last-modified", "pragma"]);
var allowedRequestMethods = new Set(["OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE"]);
var forbiddenRequestMethods = new Set(["TRACK", "TRACE", "CONNECT"]);
var XMLHttpRequestResponseType = new Set(["", "arraybuffer", "blob", "document", "json", "text"]);

module.exports = function createXMLHttpRequest(window) {
  var XMLHttpRequest =
  /*#__PURE__*/
  function (_XMLHttpRequestEventT) {
    _inherits(XMLHttpRequest, _XMLHttpRequestEventT);

    function XMLHttpRequest() {
      var _this;

      _classCallCheck(this, XMLHttpRequest);

      // eslint-disable-line constructor-super
      var theThis = Object.create((this instanceof XMLHttpRequest ? this.constructor : void 0).prototype);
      XMLHttpRequestEventTarget.setup(theThis);
      theThis.upload = XMLHttpRequestUpload.create();
      theThis.upload._ownerDocument = window.document;
      theThis[xhrSymbols.flag] = {
        synchronous: false,
        withCredentials: false,
        mimeType: null,
        auth: null,
        method: undefined,
        responseType: "",
        requestHeaders: {},
        referrer: theThis._ownerDocument.URL,
        uri: "",
        timeout: 0,
        body: undefined,
        formData: false,
        preflight: false,
        requestManager: theThis._ownerDocument._requestManager,
        strictSSL: window._resourceLoader._strictSSL,
        proxy: window._resourceLoader._proxy,
        cookieJar: theThis._ownerDocument._cookieJar,
        encoding: theThis._ownerDocument._encoding,
        origin: theThis._ownerDocument.origin,
        userAgent: window.navigator.userAgent
      };
      theThis[xhrSymbols.properties] = {
        beforeSend: false,
        send: false,
        timeoutStart: 0,
        timeoutId: 0,
        timeoutFn: null,
        client: null,
        responseHeaders: {},
        filteredResponseHeaders: [],
        responseBuffer: null,
        responseCache: null,
        responseTextCache: null,
        responseXMLCache: null,
        responseURL: "",
        readyState: XMLHttpRequest.UNSENT,
        status: 0,
        statusText: "",
        error: "",
        uploadComplete: false,
        uploadListener: false,
        // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.
        // In that case the termination reason is "fatal", not "end-user abort".
        abortError: false,
        cookieJar: theThis._ownerDocument._cookieJar,
        bufferStepSize: 1 * 1024 * 1024,
        // pre-allocate buffer increase step size. init value is 1MB
        totalReceivedChunkSize: 0
      };
      return _possibleConstructorReturn(_this, theThis);
    }

    _createClass(XMLHttpRequest, [{
      key: "abort",
      value: function abort() {
        var properties = this[xhrSymbols.properties]; // Terminate the request

        clearTimeout(properties.timeoutId);
        properties.timeoutFn = null;
        properties.timeoutStart = 0;
        var client = properties.client;

        if (client) {
          client.abort();
          properties.client = null;
        }

        if (properties.abortError) {
          // Special case that ideally shouldn't be going through the public API at all.
          // Run the https://xhr.spec.whatwg.org/#handle-errors "fatal" steps.
          properties.readyState = XMLHttpRequest.DONE;
          properties.send = false;
          xhrUtils.setResponseToNetworkError(this);
          return;
        }

        if (this.readyState === XMLHttpRequest.OPENED && properties.send || this.readyState === XMLHttpRequest.HEADERS_RECEIVED || this.readyState === XMLHttpRequest.LOADING) {
          xhrUtils.requestErrorSteps(this, "abort");
        }

        if (this.readyState === XMLHttpRequest.DONE) {
          properties.readyState = XMLHttpRequest.UNSENT;
          xhrUtils.setResponseToNetworkError(this);
        }
      }
    }, {
      key: "getAllResponseHeaders",
      value: function getAllResponseHeaders() {
        var properties = this[xhrSymbols.properties];
        var readyState = this.readyState;

        if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {
          return "";
        }

        return Object.keys(properties.responseHeaders).filter(function (key) {
          return properties.filteredResponseHeaders.indexOf(key) === -1;
        }).map(function (key) {
          return [conversions.ByteString(key).toLowerCase(), properties.responseHeaders[key]].join(": ");
        }).join("\r\n");
      }
    }, {
      key: "getResponseHeader",
      value: function getResponseHeader(header) {
        var properties = this[xhrSymbols.properties];
        var readyState = this.readyState;

        if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {
          return null;
        }

        var lcHeader = conversions.ByteString(header).toLowerCase();

        if (properties.filteredResponseHeaders.find(function (filtered) {
          return lcHeader === filtered.toLowerCase();
        })) {
          return null;
        }

        return _getResponseHeader(this, lcHeader);
      }
    }, {
      key: "open",
      value: function open(method, uri, asynchronous, user, password) {
        if (!this._ownerDocument) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        var flag = this[xhrSymbols.flag];
        var properties = this[xhrSymbols.properties];
        var argumentCount = arguments.length;

        if (argumentCount < 2) {
          throw new TypeError("Not enough arguments (expected at least 2)");
        }

        method = conversions.ByteString(method);
        uri = conversions.USVString(uri);

        if (user) {
          user = conversions.USVString(user);
        }

        if (password) {
          password = conversions.USVString(password);
        }

        if (!tokenRegexp.test(method)) {
          throw new DOMException("The string did not match the expected pattern.", "SyntaxError");
        }

        var upperCaseMethod = method.toUpperCase();

        if (forbiddenRequestMethods.has(upperCaseMethod)) {
          throw new DOMException("The operation is insecure.", "SecurityError");
        }

        var client = properties.client;

        if (client && typeof client.abort === "function") {
          client.abort();
        }

        if (allowedRequestMethods.has(upperCaseMethod)) {
          method = upperCaseMethod;
        }

        if (typeof asynchronous !== "undefined") {
          flag.synchronous = !asynchronous;
        } else {
          flag.synchronous = false;
        }

        if (flag.responseType && flag.synchronous) {
          throw new DOMException("The object does not support the operation or argument.", "InvalidAccessError");
        }

        if (flag.synchronous && flag.timeout) {
          throw new DOMException("The object does not support the operation or argument.", "InvalidAccessError");
        }

        flag.method = method;
        var urlObj;

        try {
          urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));
        } catch (e) {
          throw new DOMException("The string did not match the expected pattern.", "SyntaxError");
        }

        if (user || password && !urlObj.username) {
          flag.auth = {
            user: user,
            pass: password
          };
          urlObj.username = "";
          urlObj.password = "";
        }

        flag.uri = urlObj.href;
        flag.requestHeaders = {};
        flag.preflight = false;
        properties.send = false;
        properties.uploadListener = false;
        properties.requestBuffer = null;
        properties.requestCache = null;
        properties.abortError = false;
        properties.responseURL = "";
        readyStateChange(this, XMLHttpRequest.OPENED);
      }
    }, {
      key: "overrideMimeType",
      value: function overrideMimeType(mime) {
        mime = String(mime);
        var readyState = this.readyState;

        if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        this[xhrSymbols.flag].overrideMIMEType = "application/octet-stream"; // Waiting for better spec: https://github.com/whatwg/xhr/issues/157

        var parsed = MIMEType.parse(mime);

        if (parsed) {
          this[xhrSymbols.flag].overrideMIMEType = parsed.essence;
          var charset = parsed.parameters.get("charset");

          if (charset) {
            this[xhrSymbols.flag].overrideCharset = whatwgEncoding.labelToName(charset);
          }
        }
      }
    }, {
      key: "send",
      value: function send(body) {
        var _this2 = this;

        body = coerceBodyArg(body); // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65

        if (!this._ownerDocument) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        var flag = this[xhrSymbols.flag];
        var properties = this[xhrSymbols.properties];

        if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        properties.beforeSend = true;

        try {
          if (flag.method === "GET" || flag.method === "HEAD") {
            body = null;
          }

          if (body !== null) {
            var encoding = null;
            var mimeType = null;

            if (Document.isImpl(body)) {
              encoding = "UTF-8";
              mimeType = (body._parsingMode === "html" ? "text/html" : "application/xml") + ";charset=UTF-8";
              flag.body = fragmentSerialization(body, {
                requireWellFormed: false
              });
            } else {
              if (typeof body === "string") {
                encoding = "UTF-8";
              }

              var _extractBody = extractBody(body),
                  buffer = _extractBody.buffer,
                  formData = _extractBody.formData,
                  contentType = _extractBody.contentType;

              mimeType = contentType;
              flag.body = buffer || formData;
              flag.formData = Boolean(formData);
            }

            var existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, "content-type");

            if (mimeType !== null && existingContentType === null) {
              flag.requestHeaders["Content-Type"] = mimeType;
            } else if (existingContentType !== null && encoding !== null) {
              // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what
              // the spec will be, in the meantime.
              var parsed = MIMEType.parse(existingContentType);

              if (parsed) {
                var charset = parsed.parameters.get("charset");

                if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {
                  parsed.parameters.set("charset", encoding);
                }

                xhrUtils.updateRequestHeader(flag.requestHeaders, "content-type", parsed.toString());
              }
            }
          }
        } finally {
          if (properties.beforeSend) {
            properties.beforeSend = false;
          } else {
            throw new DOMException("The object is in an invalid state.", "InvalidStateError");
          }
        }

        if (Object.keys(idlUtils.implForWrapper(this.upload)._eventListeners).length > 0) {
          properties.uploadListener = true;
        } // request doesn't like zero-length bodies


        if (flag.body && flag.body.byteLength === 0) {
          flag.body = null;
        }

        if (flag.synchronous) {
          var flagStr = JSON.stringify(flag, function (k, v) {
            if (this === flag && k === "requestManager") {
              return null;
            }

            if (this === flag && k === "pool" && v) {
              return {
                maxSockets: v.maxSockets
              };
            }

            return v;
          });
          var res = spawnSync(process.execPath, [syncWorkerFile], {
            input: flagStr
          });

          if (res.status !== 0) {
            throw new Error(res.stderr.toString());
          }

          if (res.error) {
            if (typeof res.error === "string") {
              res.error = new Error(res.error);
            }

            throw res.error;
          }

          var response = JSON.parse(res.stdout.toString());

          if (response.properties.responseBuffer && response.properties.responseBuffer.data) {
            response.properties.responseBuffer = Buffer.from(response.properties.responseBuffer.data);
          }

          if (response.properties.cookieJar) {
            response.properties.cookieJar = tough.CookieJar.deserializeSync(response.properties.cookieJar, this._ownerDocument._cookieJar.store);
          }

          response.properties.readyState = XMLHttpRequest.LOADING;
          this[xhrSymbols.properties] = response.properties;

          if (response.properties.error) {
            xhrUtils.dispatchError(this);
            throw new DOMException(response.properties.error, "NetworkError");
          } else {
            var responseBuffer = this[xhrSymbols.properties].responseBuffer;
            var contentLength = _getResponseHeader(this, "content-length") || "0";
            var bufferLength = parseInt(contentLength) || responseBuffer.length;
            var progressObj = {
              lengthComputable: false
            };

            if (bufferLength !== 0) {
              progressObj.total = bufferLength;
              progressObj.loaded = bufferLength;
              progressObj.lengthComputable = true;
            }

            fireAnEvent("progress", this, ProgressEvent, progressObj);
            readyStateChange(this, XMLHttpRequest.DONE);
            fireAnEvent("load", this, ProgressEvent, progressObj);
            fireAnEvent("loadend", this, ProgressEvent, progressObj);
          }
        } else {
          properties.send = true;
          fireAnEvent("loadstart", this, ProgressEvent);
          var client = xhrUtils.createClient(this);
          properties.client = client; // For new client, reset totalReceivedChunkSize and bufferStepSize

          properties.totalReceivedChunkSize = 0;
          properties.bufferStepSize = 1 * 1024 * 1024;
          properties.origin = flag.origin;
          client.on("error", function (err) {
            client.removeAllListeners();
            properties.error = err;
            xhrUtils.dispatchError(_this2);
          });
          client.on("response", function (res) {
            return receiveResponse(_this2, res);
          });
          client.on("redirect", function () {
            var response = client.response;
            var destUrlObj = new URL(response.request.headers.Referer);
            var urlObj = new URL(response.request.uri.href);

            if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {
              properties.origin = "null";
            }

            response.request.headers.Origin = properties.origin;

            if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== "data:") {
              if (!xhrUtils.validCORSHeaders(_this2, response, flag, properties, flag.origin)) {
                return;
              }

              if (urlObj.username || urlObj.password) {
                properties.error = "Userinfo forbidden in cors redirect";
                xhrUtils.dispatchError(_this2);
              }
            }
          });

          if (body !== null && body !== "") {
            properties.uploadComplete = false;
            setDispatchProgressEvents(this);
          } else {
            properties.uploadComplete = true;
          }

          if (this.timeout > 0) {
            properties.timeoutStart = new Date().getTime();

            properties.timeoutFn = function () {
              client.abort();

              if (!(_this2.readyState === XMLHttpRequest.UNSENT || _this2.readyState === XMLHttpRequest.OPENED && !properties.send || _this2.readyState === XMLHttpRequest.DONE)) {
                properties.send = false;
                var stateChanged = false;

                if (!properties.uploadComplete) {
                  fireAnEvent("progress", _this2.upload, ProgressEvent);
                  readyStateChange(_this2, XMLHttpRequest.DONE);
                  fireAnEvent("timeout", _this2.upload, ProgressEvent);
                  fireAnEvent("loadend", _this2.upload, ProgressEvent);
                  stateChanged = true;
                }

                fireAnEvent("progress", _this2, ProgressEvent);

                if (!stateChanged) {
                  readyStateChange(_this2, XMLHttpRequest.DONE);
                }

                fireAnEvent("timeout", _this2, ProgressEvent);
                fireAnEvent("loadend", _this2, ProgressEvent);
              }

              properties.readyState = XMLHttpRequest.UNSENT;
            };

            properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);
          }
        }
      }
    }, {
      key: "setRequestHeader",
      value: function setRequestHeader(header, value) {
        var flag = this[xhrSymbols.flag];
        var properties = this[xhrSymbols.properties];

        if (arguments.length !== 2) {
          throw new TypeError("2 arguments required for setRequestHeader");
        }

        header = conversions.ByteString(header);
        value = conversions.ByteString(value);

        if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        value = normalizeHeaderValue(value);

        if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {
          throw new DOMException("The string did not match the expected pattern.", "SyntaxError");
        }

        var lcHeader = header.toLowerCase();

        if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith("sec-") || lcHeader.startsWith("proxy-")) {
          return;
        }

        var keys = Object.keys(flag.requestHeaders);
        var n = keys.length;

        while (n--) {
          var key = keys[n];

          if (key.toLowerCase() === lcHeader) {
            flag.requestHeaders[key] += ", " + value;
            return;
          }
        }

        flag.requestHeaders[header] = value;
      }
    }, {
      key: "readyState",
      get: function get() {
        return this[xhrSymbols.properties].readyState;
      }
    }, {
      key: "status",
      get: function get() {
        return this[xhrSymbols.properties].status;
      }
    }, {
      key: "statusText",
      get: function get() {
        return this[xhrSymbols.properties].statusText;
      }
    }, {
      key: "responseType",
      get: function get() {
        return this[xhrSymbols.flag].responseType;
      },
      set: function set(responseType) {
        var flag = this[xhrSymbols.flag];

        if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {
          throw new DOMException("The object does not support the operation or argument.", "InvalidAccessError");
        }

        if (!XMLHttpRequestResponseType.has(responseType)) {
          responseType = "";
        }

        flag.responseType = responseType;
      }
    }, {
      key: "response",
      get: function get() {
        var properties = this[xhrSymbols.properties];

        if (properties.responseCache) {
          return properties.responseCache;
        }

        var res = "";
        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;

        switch (this.responseType) {
          case "":
          case "text":
            {
              res = this.responseText;
              break;
            }

          case "arraybuffer":
            {
              if (!responseBuffer) {
                return null;
              }

              res = new Uint8Array(responseBuffer).buffer;
              break;
            }

          case "blob":
            {
              if (!responseBuffer) {
                return null;
              }

              var contentType = finalMIMEType(this);
              res = Blob.create([[new Uint8Array(responseBuffer)], {
                type: contentType || ""
              }]);
              break;
            }

          case "document":
            {
              res = this.responseXML;
              break;
            }

          case "json":
            {
              if (this.readyState !== XMLHttpRequest.DONE || !responseBuffer) {
                res = null;
              }

              try {
                res = parseJSONFromBytes(responseBuffer);
              } catch (e) {
                res = null;
              }

              break;
            }
        }

        properties.responseCache = res;
        return res;
      }
    }, {
      key: "responseText",
      get: function get() {
        var properties = this[xhrSymbols.properties];

        if (this.responseType !== "" && this.responseType !== "text") {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {
          return "";
        }

        if (properties.responseTextCache) {
          return properties.responseTextCache;
        }

        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;

        if (!responseBuffer) {
          return "";
        }

        var fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || "UTF-8";
        var res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);
        properties.responseTextCache = res;
        return res;
      }
    }, {
      key: "responseXML",
      get: function get() {
        var flag = this[xhrSymbols.flag];
        var properties = this[xhrSymbols.properties];

        if (this.responseType !== "" && this.responseType !== "document") {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        if (this.readyState !== XMLHttpRequest.DONE) {
          return null;
        }

        if (properties.responseXMLCache) {
          return properties.responseXMLCache;
        }

        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;

        if (!responseBuffer) {
          return null;
        }

        var contentType = finalMIMEType(this);
        var isHTML = false;
        var isXML = false;
        var parsed = MIMEType.parse(contentType);

        if (parsed) {
          isHTML = parsed.isHTML();
          isXML = parsed.isXML();

          if (!isXML && !isHTML) {
            return null;
          }
        }

        if (this.responseType === "" && isHTML) {
          return null;
        }

        var encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || "UTF-8";
        var resText = whatwgEncoding.decode(responseBuffer, encoding);

        if (!resText) {
          return null;
        }

        var res = Document.create([], {
          options: {
            url: flag.uri,
            lastModified: new Date(_getResponseHeader(this, "last-modified")),
            parsingMode: isHTML ? "html" : "xml",
            cookieJar: {
              setCookieSync: function setCookieSync() {
                return undefined;
              },
              getCookieStringSync: function getCookieStringSync() {
                return "";
              }
            },
            encoding: encoding,
            parseOptions: this._ownerDocument._parseOptions
          }
        });
        var resImpl = idlUtils.implForWrapper(res);

        try {
          parseIntoDocument(resText, resImpl);
        } catch (e) {
          properties.responseXMLCache = null;
          return null;
        }

        res.close();
        properties.responseXMLCache = res;
        return res;
      }
    }, {
      key: "responseURL",
      get: function get() {
        return this[xhrSymbols.properties].responseURL;
      }
    }, {
      key: "timeout",
      get: function get() {
        return this[xhrSymbols.flag].timeout;
      },
      set: function set(val) {
        var flag = this[xhrSymbols.flag];
        var properties = this[xhrSymbols.properties];

        if (flag.synchronous) {
          throw new DOMException("The object does not support the operation or argument.", "InvalidAccessError");
        }

        flag.timeout = val;
        clearTimeout(properties.timeoutId);

        if (val > 0 && properties.timeoutFn) {
          properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));
        } else {
          properties.timeoutFn = null;
          properties.timeoutStart = 0;
        }
      }
    }, {
      key: "withCredentials",
      get: function get() {
        return this[xhrSymbols.flag].withCredentials;
      },
      set: function set(val) {
        var flag = this[xhrSymbols.flag];
        var properties = this[xhrSymbols.properties];

        if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        if (properties.send) {
          throw new DOMException("The object is in an invalid state.", "InvalidStateError");
        }

        flag.withCredentials = val;
      }
    }, {
      key: "_ownerDocument",
      get: function get() {
        return idlUtils.implForWrapper(window.document);
      }
    }]);

    return XMLHttpRequest;
  }(XMLHttpRequestEventTarget["interface"]);

  Object.defineProperty(XMLHttpRequest.prototype, Symbol.toStringTag, {
    value: "XMLHttpRequest",
    writable: false,
    enumerable: false,
    configurable: true
  });
  setupForSimpleEventAccessors(XMLHttpRequest.prototype, ["readystatechange"]);
  addConstants(XMLHttpRequest, {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  });

  function readyStateChange(xhr, readyState) {
    var properties = xhr[xhrSymbols.properties];

    if (properties.readyState === readyState) {
      return;
    }

    properties.readyState = readyState;
    fireAnEvent("readystatechange", xhr);
  }

  function receiveResponse(xhr, response) {
    var properties = xhr[xhrSymbols.properties];
    var flag = xhr[xhrSymbols.flag];
    var statusCode = response.statusCode;
    var byteOffset = 0;
    var headers = {};
    var filteredResponseHeaders = [];
    var headerMap = {};
    var rawHeaders = response.rawHeaders;
    var n = Number(rawHeaders.length);

    for (var i = 0; i < n; i += 2) {
      var k = rawHeaders[i];
      var kl = k.toLowerCase();
      var v = rawHeaders[i + 1];

      if (uniqueResponseHeaders.has(kl)) {
        if (headerMap[kl] !== undefined) {
          delete headers[headerMap[kl]];
        }

        headers[k] = v;
      } else if (headerMap[kl] !== undefined) {
        headers[headerMap[kl]] += ", " + v;
      } else {
        headers[k] = v;
      }

      headerMap[kl] = k;
    }

    var destUrlObj = new URL(response.request.uri.href);

    if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== "data:") {
      if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {
        return;
      }

      var acehStr = response.headers["access-control-expose-headers"];
      var aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);

      for (var header in headers) {
        var lcHeader = header.toLowerCase();

        if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {
          filteredResponseHeaders.push(header);
        }
      }
    }

    for (var _header in headers) {
      var _lcHeader = _header.toLowerCase();

      if (forbiddenResponseHeaders.has(_lcHeader)) {
        filteredResponseHeaders.push(_header);
      }
    }

    properties.responseURL = destUrlObj.href;
    properties.status = statusCode;
    properties.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || "";
    properties.responseHeaders = headers;
    properties.filteredResponseHeaders = filteredResponseHeaders;
    var contentLength = _getResponseHeader(xhr, "content-length") || "0";
    var bufferLength = parseInt(contentLength) || 0;
    var progressObj = {
      lengthComputable: false
    };
    var lastProgressReported;

    if (bufferLength !== 0) {
      progressObj.total = bufferLength;
      progressObj.loaded = 0;
      progressObj.lengthComputable = true;
    } // pre-allocate buffer.


    properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);
    properties.responseCache = null;
    properties.responseTextCache = null;
    properties.responseXMLCache = null;
    readyStateChange(xhr, XMLHttpRequest.HEADERS_RECEIVED);

    if (!properties.client) {
      // The request was aborted in reaction to the readystatechange event.
      return;
    } // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the
    // Content-Length).


    response.on("data", function (chunk) {
      byteOffset += chunk.length;
      progressObj.loaded = byteOffset;
    });
    properties.client.on("data", function (chunk) {
      properties.totalReceivedChunkSize += chunk.length;

      if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {
        properties.bufferStepSize *= 2;

        while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {
          properties.bufferStepSize *= 2;
        }

        var tmpBuf = Buffer.alloc(properties.bufferStepSize);
        properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);
        properties.responseBuffer = tmpBuf;
      }

      chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);
      properties.responseCache = null;
      properties.responseTextCache = null;
      properties.responseXMLCache = null;

      if (properties.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
        properties.readyState = XMLHttpRequest.LOADING;
      }

      fireAnEvent("readystatechange", xhr);

      if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {
        if (lastProgressReported !== progressObj.loaded) {
          // This is a necessary check in the gzip case where we can be getting new data from the client, as it
          // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.
          lastProgressReported = progressObj.loaded;
          fireAnEvent("progress", xhr, ProgressEvent, progressObj);
        }
      }
    });
    properties.client.on("end", function () {
      clearTimeout(properties.timeoutId);
      properties.timeoutFn = null;
      properties.timeoutStart = 0;
      properties.client = null;
      fireAnEvent("progress", xhr, ProgressEvent, progressObj);
      readyStateChange(xhr, XMLHttpRequest.DONE);
      fireAnEvent("load", xhr, ProgressEvent, progressObj);
      fireAnEvent("loadend", xhr, ProgressEvent, progressObj);
    });
  }

  function setDispatchProgressEvents(xhr) {
    var properties = xhr[xhrSymbols.properties];
    var client = properties.client;
    var upload = xhr.upload;
    var total = 0;
    var lengthComputable = false;
    var length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, "content-length"));

    if (length) {
      total = length;
      lengthComputable = true;
    }

    var initProgress = {
      lengthComputable: lengthComputable,
      total: total,
      loaded: 0
    };

    if (properties.uploadListener) {
      fireAnEvent("loadstart", upload, ProgressEvent, initProgress);
    }

    client.on("request", function (req) {
      req.on("response", function () {
        properties.uploadComplete = true;

        if (!properties.uploadListener) {
          return;
        }

        var progress = {
          lengthComputable: lengthComputable,
          total: total,
          loaded: total
        };
        fireAnEvent("progress", upload, ProgressEvent, progress);
        fireAnEvent("load", upload, ProgressEvent, progress);
        fireAnEvent("loadend", upload, ProgressEvent, progress);
      });
    });
  }

  return XMLHttpRequest;
};

function finalMIMEType(xhr) {
  var flag = xhr[xhrSymbols.flag];
  return flag.overrideMIMEType || _getResponseHeader(xhr, "content-type");
}

function finalCharset(xhr) {
  var flag = xhr[xhrSymbols.flag];

  if (flag.overrideCharset) {
    return flag.overrideCharset;
  }

  var parsedContentType = MIMEType.parse(_getResponseHeader(xhr, "content-type"));

  if (parsedContentType) {
    return whatwgEncoding.labelToName(parsedContentType.parameters.get("charset"));
  }

  return null;
}

function _getResponseHeader(xhr, lcHeader) {
  var properties = xhr[xhrSymbols.properties];
  var keys = Object.keys(properties.responseHeaders);
  var n = keys.length;

  while (n--) {
    var key = keys[n];

    if (key.toLowerCase() === lcHeader) {
      return properties.responseHeaders[key];
    }
  }

  return null;
}

function normalizeHeaderValue(value) {
  return value.replace(/^[\x09\x0A\x0D\x20]+/, "").replace(/[\x09\x0A\x0D\x20]+$/, "");
}

function coerceBodyArg(body) {
  // Implements the IDL conversion for `optional (Document or BodyInit)? body = null`
  if (body === undefined || body === null) {
    return null;
  }

  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
    return body;
  }

  var impl = idlUtils.implForWrapper(body);

  if (impl) {
    // TODO: allow URLSearchParams or ReadableStream
    if (Blob.isImpl(impl) || FormData.isImpl(impl) || Document.isImpl(impl)) {
      return impl;
    }
  }

  return conversions.USVString(body);
}

function extractBody(bodyInit) {
  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract
  // except we represent the body as a Node.js Buffer instead,
  // or a special case for FormData since we want request to handle that. Probably it would be
  // cleaner (and allow a future without request) if we did the form encoding ourself.
  if (Blob.isImpl(bodyInit)) {
    return {
      buffer: bodyInit._buffer,
      contentType: bodyInit.type === "" ? null : bodyInit.type
    };
  } else if (bodyInit instanceof ArrayBuffer) {
    return {
      buffer: Buffer.from(bodyInit),
      contentType: null
    };
  } else if (ArrayBuffer.isView(bodyInit)) {
    return {
      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),
      contentType: null
    };
  } else if (FormData.isImpl(bodyInit)) {
    var formData = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = bodyInit._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var entry = _step.value;
        var val = void 0;

        if (Blob.isImpl(entry.value)) {
          var blob = entry.value;
          val = {
            name: entry.name,
            value: blob._buffer,
            options: {
              filename: blob.name,
              contentType: blob.type,
              knownLength: blob.size
            }
          };
        } else {
          val = entry;
        }

        formData.push(val);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return {
      formData: formData
    };
  } // Must be a string


  return {
    buffer: Buffer.from(bodyInit, "utf-8"),
    contentType: "text/plain;charset=UTF-8"
  };
}