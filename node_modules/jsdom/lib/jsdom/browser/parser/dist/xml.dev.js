"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require("saxes"),
    SaxesParser = _require.SaxesParser;

var DOMException = require("domexception");

var DocumentFragment = require("../../living/generated/DocumentFragment");

var DocumentType = require("../../living/generated/DocumentType");

var CDATASection = require("../../living/generated/CDATASection");

var Comment = require("../../living/generated/Comment");

var ProcessingInstruction = require("../../living/generated/ProcessingInstruction");

var Text = require("../../living/generated/Text");

var attributes = require("../../living/attributes");

var _require2 = require("../../living/helpers/namespaces"),
    HTML_NS = _require2.HTML_NS;

var HTML5_DOCTYPE = /<!doctype html>/i;
var PUBLIC_DOCTYPE = /<!doctype\s+([^\s]+)\s+public\s+"([^"]+)"\s+"([^"]+)"/i;
var SYSTEM_DOCTYPE = /<!doctype\s+([^\s]+)\s+system\s+"([^"]+)"/i;
var CUSTOM_NAME_DOCTYPE = /<!doctype\s+([^\s>]+)/i;

function parseDocType(doc, html) {
  if (HTML5_DOCTYPE.test(html)) {
    return createDocumentType(doc, "html", "", "");
  }

  var publicPieces = PUBLIC_DOCTYPE.exec(html);

  if (publicPieces) {
    return createDocumentType(doc, publicPieces[1], publicPieces[2], publicPieces[3]);
  }

  var systemPieces = SYSTEM_DOCTYPE.exec(html);

  if (systemPieces) {
    return createDocumentType(doc, systemPieces[1], "", systemPieces[2]);
  }

  var namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || "html";
  return createDocumentType(doc, namePiece, "", "");
}

function createDocumentType(ownerDocument, name, publicId, systemId) {
  return DocumentType.createImpl([], {
    ownerDocument: ownerDocument,
    name: name,
    publicId: publicId,
    systemId: systemId
  });
}

function appendChild(parent, child) {
  // Template elements do not have children but instead store their content in a separate hierarchy.
  if (parent.tagName === "template" && parent.namespaceURI === HTML_NS) {
    parent._templateContents._insert(child, null);
  } else {
    parent._insert(child, null);
  }
}

function createParser(rootNode, ownerDocument, saxesOptions) {
  var parser = new SaxesParser(saxesOptions);
  var openStack = [rootNode];
  parser.ontext = saxesOptions.fragment ? // In a fragment, all text events produced by saxes must result in a text
  // node.
  function (data) {
    appendChild(openStack[openStack.length - 1], Text.createImpl([], {
      data: data,
      ownerDocument: ownerDocument
    }));
  } : // When parsing a whole document, we must ignore those text nodes that are
  // produced outside the root element. Saxes produces events for them,
  // but DOM trees do not record text outside the root element.
  function (data) {
    if (openStack.length > 1) {
      appendChild(openStack[openStack.length - 1], Text.createImpl([], {
        data: data,
        ownerDocument: ownerDocument
      }));
    }
  };

  parser.oncdata = function (data) {
    appendChild(openStack[openStack.length - 1], CDATASection.createImpl([], {
      data: data,
      ownerDocument: ownerDocument
    }));
  };

  parser.onopentag = function (tag) {
    var tagLocal = tag.local,
        tagURI = tag.uri,
        tagPrefix = tag.prefix,
        tagAttributes = tag.attributes;

    var elem = ownerDocument._createElementWithCorrectElementInterface(tagLocal, tagURI);

    elem._prefix = tagPrefix || null;
    elem._namespaceURI = tagURI || null; // We mark a script element as "parser-inserted", which prevents it from
    // being immediately executed.

    if (tagLocal === "script" && tagURI === HTML_NS) {
      elem._parserInserted = true;
    }

    for (var _i = 0, _Object$keys = Object.keys(tagAttributes); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      var _tagAttributes$key = tagAttributes[key],
          prefix = _tagAttributes$key.prefix,
          local = _tagAttributes$key.local,
          uri = _tagAttributes$key.uri,
          value = _tagAttributes$key.value;
      attributes.setAttributeValue(elem, local, value, prefix === "" ? null : prefix, uri === "" ? null : uri);
    }

    appendChild(openStack[openStack.length - 1], elem);
    openStack.push(elem);
  };

  parser.onclosetag = function () {
    var elem = openStack.pop(); // Once a script is populated, we can execute it.

    if (elem.localName === "script" && elem.namespaceURI === HTML_NS) {
      elem._eval();
    }
  };

  parser.oncomment = function (data) {
    appendChild(openStack[openStack.length - 1], Comment.createImpl([], {
      data: data,
      ownerDocument: ownerDocument
    }));
  };

  parser.onprocessinginstruction = function (_ref) {
    var target = _ref.target,
        body = _ref.body;
    appendChild(openStack[openStack.length - 1], ProcessingInstruction.createImpl([], {
      target: target,
      data: body,
      ownerDocument: ownerDocument
    }));
  };

  parser.ondoctype = function (dt) {
    appendChild(openStack[openStack.length - 1], parseDocType(ownerDocument, "<!doctype ".concat(dt, ">")));
    var entityMatcher = /<!ENTITY ([^ ]+) "([^"]+)">/g;
    var result;

    while (result = entityMatcher.exec(dt)) {
      var _result = result,
          _result2 = _slicedToArray(_result, 3),
          name = _result2[1],
          value = _result2[2];

      if (!(name in parser.ENTITIES)) {
        parser.ENTITIES[name] = value;
      }
    }
  };

  parser.onerror = function (err) {
    throw new DOMException(err.message, "SyntaxError");
  };

  return parser;
}

function parseFragment(markup, contextElement) {
  var ownerDocument = contextElement._ownerDocument;
  var fragment = DocumentFragment.createImpl([], {
    ownerDocument: ownerDocument
  }); // Only parseFragment needs resolvePrefix per the saxes documentation:
  // https://github.com/lddubeau/saxes#parsing-xml-fragments

  var parser = createParser(fragment, ownerDocument, {
    xmlns: true,
    fragment: true,
    resolvePrefix: function resolvePrefix(prefix) {
      // saxes wants undefined as the return value if the prefix is not defined, not null.
      return contextElement.lookupNamespaceURI(prefix) || undefined;
    }
  });
  parser.write(markup).close();
  return fragment;
}

function parseIntoDocument(markup, ownerDocument) {
  var parser = createParser(ownerDocument, ownerDocument, {
    xmlns: true
  });
  parser.write(markup).close();
  return ownerDocument;
}

module.exports = {
  parseFragment: parseFragment,
  parseIntoDocument: parseIntoDocument
};