"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var vm = require("vm");

var webIDLConversions = require("webidl-conversions");

var _require = require("cssstyle"),
    CSSStyleDeclaration = _require.CSSStyleDeclaration;

var _require2 = require("w3c-hr-time"),
    RawPerformance = _require2.Performance;

var notImplemented = require("./not-implemented");

var _require3 = require("../utils"),
    define = _require3.define,
    mixin = _require3.mixin;

var Element = require("../living/generated/Element");

var EventTarget = require("../living/generated/EventTarget");

var PageTransitionEvent = require("../living/generated/PageTransitionEvent");

var namedPropertiesWindow = require("../living/named-properties-window");

var cssom = require("cssom");

var postMessage = require("../living/post-message");

var DOMException = require("domexception");

var _require4 = require("abab"),
    btoa = _require4.btoa,
    atob = _require4.atob;

var idlUtils = require("../living/generated/utils");

var createXMLHttpRequest = require("../living/xmlhttprequest");

var createFileReader = require("../living/generated/FileReader").createInterface;

var createWebSocket = require("../living/generated/WebSocket").createInterface;

var WebSocketImpl = require("../living/websockets/WebSocket-impl").implementation;

var BarProp = require("../living/generated/BarProp");

var Document = require("../living/generated/Document");

var External = require("../living/generated/External");

var Navigator = require("../living/generated/Navigator");

var Performance = require("../living/generated/Performance");

var Screen = require("../living/generated/Screen");

var Storage = require("../living/generated/Storage");

var createAbortController = require("../living/generated/AbortController").createInterface;

var createAbortSignal = require("../living/generated/AbortSignal").createInterface;

var reportException = require("../living/helpers/runtime-script-errors");

var _require5 = require("../living/helpers/selectors"),
    matchesDontThrow = _require5.matchesDontThrow;

var _require6 = require("../living/helpers/events"),
    fireAnEvent = _require6.fireAnEvent;

var SessionHistory = require("../living/window/SessionHistory");

var GlobalEventHandlersImpl = require("../living/nodes/GlobalEventHandlers-impl").implementation;

var WindowEventHandlersImpl = require("../living/nodes/WindowEventHandlers-impl").implementation;

var defaultStyleSheet = require("./default-stylesheet");

var parsedDefaultStyleSheet; // NB: the require() must be after assigning `module.exports` because this require() is circular
// TODO: this above note might not even be true anymore... figure out the cycle and document it, or clean up.

module.exports = Window;

var dom = require("../living");

dom.Window = Window; // NOTE: per https://heycam.github.io/webidl/#Global, all properties on the Window object must be own-properties.
// That is why we assign everything inside of the constructor, instead of using a shared prototype.
// You can verify this in e.g. Firefox or Internet Explorer, which do a good job with Web IDL compliance.

function Window(options) {
  var _this = this;

  EventTarget.setup(this);
  var rawPerformance = new RawPerformance();
  var windowInitialized = rawPerformance.now();
  var window = this;
  mixin(window, WindowEventHandlersImpl.prototype);
  mixin(window, GlobalEventHandlersImpl.prototype);

  this._initGlobalEvents(); ///// INTERFACES FROM THE DOM
  // TODO: consider a mode of some sort where these are not shared between all DOM instances
  // It'd be very memory-expensive in most cases, though.


  for (var name in dom) {
    Object.defineProperty(window, name, {
      enumerable: false,
      configurable: true,
      writable: true,
      value: dom[name]
    });
  } ///// PRIVATE DATA PROPERTIES


  this._resourceLoader = options.resourceLoader; // vm initialization is deferred until script processing is activated

  this._globalProxy = this;
  Object.defineProperty(idlUtils.implForWrapper(this), idlUtils.wrapperSymbol, {
    get: function get() {
      return _this._globalProxy;
    }
  });
  var timers = Object.create(null);
  var animationFrameCallbacks = Object.create(null); // List options explicitly to be clear which are passed through

  this._document = Document.create([], {
    options: {
      parsingMode: options.parsingMode,
      contentType: options.contentType,
      encoding: options.encoding,
      cookieJar: options.cookieJar,
      url: options.url,
      lastModified: options.lastModified,
      referrer: options.referrer,
      concurrentNodeIterators: options.concurrentNodeIterators,
      parseOptions: options.parseOptions,
      defaultView: this._globalProxy,
      global: this
    }
  }); // https://html.spec.whatwg.org/#session-history

  this._sessionHistory = new SessionHistory({
    document: idlUtils.implForWrapper(this._document),
    url: idlUtils.implForWrapper(this._document)._URL,
    stateObject: null
  }, this);
  this._virtualConsole = options.virtualConsole;
  this._runScripts = options.runScripts;

  if (this._runScripts === "outside-only" || this._runScripts === "dangerously") {
    contextifyWindow(this);
  } // Set up the window as if it's a top level window.
  // If it's not, then references will be corrected by frame/iframe code.


  this._parent = this._top = this._globalProxy;
  this._frameElement = null; // This implements window.frames.length, since window.frames returns a
  // self reference to the window object.  This value is incremented in the
  // HTMLFrameElement implementation.

  this._length = 0;
  this._pretendToBeVisual = options.pretendToBeVisual;
  this._storageQuota = options.storageQuota; // Some properties (such as localStorage and sessionStorage) share data
  // between windows in the same origin. This object is intended
  // to contain such data.

  if (options.commonForOrigin && options.commonForOrigin[this._document.origin]) {
    this._commonForOrigin = options.commonForOrigin;
  } else {
    this._commonForOrigin = _defineProperty({}, this._document.origin, {
      localStorageArea: new Map(),
      sessionStorageArea: new Map(),
      windowsInSameOrigin: [this]
    });
  }

  this._currentOriginData = this._commonForOrigin[this._document.origin]; ///// WEB STORAGE

  this._localStorage = Storage.create([], {
    associatedWindow: this,
    storageArea: this._currentOriginData.localStorageArea,
    type: "localStorage",
    url: this._document.documentURI,
    storageQuota: this._storageQuota
  });
  this._sessionStorage = Storage.create([], {
    associatedWindow: this,
    storageArea: this._currentOriginData.sessionStorageArea,
    type: "sessionStorage",
    url: this._document.documentURI,
    storageQuota: this._storageQuota
  }); ///// GETTERS

  var locationbar = BarProp.create();
  var menubar = BarProp.create();
  var personalbar = BarProp.create();
  var scrollbars = BarProp.create();
  var statusbar = BarProp.create();
  var toolbar = BarProp.create();
  var external = External.create();
  var navigator = Navigator.create([], {
    userAgent: this._resourceLoader._userAgent
  });
  var performance = Performance.create([], {
    rawPerformance: rawPerformance
  });
  var screen = Screen.create();
  define(this, {
    get length() {
      return window._length;
    },

    get window() {
      return window._globalProxy;
    },

    get frameElement() {
      return idlUtils.wrapperForImpl(window._frameElement);
    },

    get frames() {
      return window._globalProxy;
    },

    get self() {
      return window._globalProxy;
    },

    get parent() {
      return window._parent;
    },

    get top() {
      return window._top;
    },

    get document() {
      return window._document;
    },

    get external() {
      return external;
    },

    get location() {
      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._location);
    },

    get history() {
      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._history);
    },

    get navigator() {
      return navigator;
    },

    get locationbar() {
      return locationbar;
    },

    get menubar() {
      return menubar;
    },

    get personalbar() {
      return personalbar;
    },

    get scrollbars() {
      return scrollbars;
    },

    get statusbar() {
      return statusbar;
    },

    get toolbar() {
      return toolbar;
    },

    get performance() {
      return performance;
    },

    get screen() {
      return screen;
    },

    get localStorage() {
      if (this._document.origin === "null") {
        throw new DOMException("localStorage is not available for opaque origins", "SecurityError");
      }

      return this._localStorage;
    },

    get sessionStorage() {
      if (this._document.origin === "null") {
        throw new DOMException("sessionStorage is not available for opaque origins", "SecurityError");
      }

      return this._sessionStorage;
    }

  });
  namedPropertiesWindow.initializeWindow(this, this._globalProxy); ///// METHODS for [ImplicitThis] hack
  // See https://lists.w3.org/Archives/Public/public-script-coord/2015JanMar/0109.html

  this.addEventListener = this.addEventListener.bind(this);
  this.removeEventListener = this.removeEventListener.bind(this);
  this.dispatchEvent = this.dispatchEvent.bind(this); ///// METHODS

  var latestTimerId = 0;
  var latestAnimationFrameCallbackId = 0;

  this.setTimeout = function (fn, ms) {
    var args = [];

    for (var i = 2; i < arguments.length; ++i) {
      args[i - 2] = arguments[i];
    }

    return startTimer(window, setTimeout, clearTimeout, ++latestTimerId, fn, ms, timers, args);
  };

  this.setInterval = function (fn, ms) {
    var args = [];

    for (var i = 2; i < arguments.length; ++i) {
      args[i - 2] = arguments[i];
    }

    return startTimer(window, setInterval, clearInterval, ++latestTimerId, fn, ms, timers, args);
  };

  this.clearInterval = stopTimer.bind(this, timers);
  this.clearTimeout = stopTimer.bind(this, timers);

  if (this._pretendToBeVisual) {
    this.requestAnimationFrame = function (fn) {
      var timestamp = rawPerformance.now() - windowInitialized;
      var fps = 1000 / 60;
      return startTimer(window, setTimeout, clearTimeout, ++latestAnimationFrameCallbackId, fn, fps, animationFrameCallbacks, [timestamp]);
    };

    this.cancelAnimationFrame = stopTimer.bind(this, animationFrameCallbacks);
  }

  this.__stopAllTimers = function () {
    stopAllTimers(timers);
    stopAllTimers(animationFrameCallbacks);
    latestTimerId = 0;
    latestAnimationFrameCallbackId = 0;
    timers = Object.create(null);
    animationFrameCallbacks = Object.create(null);
  };

  function Option(text, value, defaultSelected, selected) {
    if (text === undefined) {
      text = "";
    }

    text = webIDLConversions.DOMString(text);

    if (value !== undefined) {
      value = webIDLConversions.DOMString(value);
    }

    defaultSelected = webIDLConversions["boolean"](defaultSelected);
    selected = webIDLConversions["boolean"](selected);

    var option = window._document.createElement("option");

    var impl = idlUtils.implForWrapper(option);

    if (text !== "") {
      impl.text = text;
    }

    if (value !== undefined) {
      impl.setAttributeNS(null, "value", value);
    }

    if (defaultSelected) {
      impl.setAttributeNS(null, "selected", "");
    }

    impl._selectedness = selected;
    return option;
  }

  Object.defineProperty(Option, "prototype", {
    value: this.HTMLOptionElement.prototype,
    configurable: false,
    enumerable: false,
    writable: false
  });
  Object.defineProperty(window, "Option", {
    value: Option,
    configurable: true,
    enumerable: false,
    writable: true
  });

  function Image() {
    var img = window._document.createElement("img");

    var impl = idlUtils.implForWrapper(img);

    if (arguments.length > 0) {
      impl.setAttributeNS(null, "width", String(arguments[0]));
    }

    if (arguments.length > 1) {
      impl.setAttributeNS(null, "height", String(arguments[1]));
    }

    return img;
  }

  Object.defineProperty(Image, "prototype", {
    value: this.HTMLImageElement.prototype,
    configurable: false,
    enumerable: false,
    writable: false
  });
  Object.defineProperty(window, "Image", {
    value: Image,
    configurable: true,
    enumerable: false,
    writable: true
  });

  function Audio(src) {
    var audio = window._document.createElement("audio");

    var impl = idlUtils.implForWrapper(audio);
    impl.setAttributeNS(null, "preload", "auto");

    if (src !== undefined) {
      impl.setAttributeNS(null, "src", String(src));
    }

    return audio;
  }

  Object.defineProperty(Audio, "prototype", {
    value: this.HTMLAudioElement.prototype,
    configurable: false,
    enumerable: false,
    writable: false
  });
  Object.defineProperty(window, "Audio", {
    value: Audio,
    configurable: true,
    enumerable: false,
    writable: true
  });
  this.postMessage = postMessage;

  this.atob = function (str) {
    var result = atob(str);

    if (result === null) {
      throw new DOMException("The string to be decoded contains invalid characters.", "InvalidCharacterError");
    }

    return result;
  };

  this.btoa = function (str) {
    var result = btoa(str);

    if (result === null) {
      throw new DOMException("The string to be encoded contains invalid characters.", "InvalidCharacterError");
    }

    return result;
  };

  this.FileReader = createFileReader({
    window: this
  })["interface"];
  this.WebSocket = createWebSocket({
    window: this
  })["interface"];
  var AbortSignalWrapper = createAbortSignal({
    window: this
  });
  this.AbortSignal = AbortSignalWrapper["interface"];
  this.AbortController = createAbortController({
    AbortSignal: AbortSignalWrapper
  })["interface"];
  this.XMLHttpRequest = createXMLHttpRequest(this); // TODO: necessary for Blob and FileReader due to different-globals weirdness; investigate how to avoid this.

  this.ArrayBuffer = ArrayBuffer;
  this.Int8Array = Int8Array;
  this.Uint8Array = Uint8Array;
  this.Uint8ClampedArray = Uint8ClampedArray;
  this.Int16Array = Int16Array;
  this.Uint16Array = Uint16Array;
  this.Int32Array = Int32Array;
  this.Uint32Array = Uint32Array;
  this.Float32Array = Float32Array;
  this.Float64Array = Float64Array;

  this.stop = function () {
    var manager = idlUtils.implForWrapper(this._document)._requestManager;

    if (manager) {
      manager.close();
    }
  };

  this.close = function () {
    // Recursively close child frame windows, then ourselves.
    var currentWindow = this;

    (function windowCleaner(windowToClean) {
      for (var i = 0; i < windowToClean.length; i++) {
        windowCleaner(windowToClean[i]);
      } // We"re already in our own window.close().


      if (windowToClean !== currentWindow) {
        windowToClean.close();
      }
    })(this); // Clear out all listeners. Any in-flight or upcoming events should not get delivered.


    idlUtils.implForWrapper(this)._eventListeners = Object.create(null);

    if (this._document) {
      if (this._document.body) {
        this._document.body.innerHTML = "";
      }

      if (this._document.close) {
        // It's especially important to clear out the listeners here because document.close() causes a "load" event to
        // fire.
        idlUtils.implForWrapper(this._document)._eventListeners = Object.create(null);

        this._document.close();
      }

      var doc = idlUtils.implForWrapper(this._document);

      if (doc._requestManager) {
        doc._requestManager.close();
      }

      delete this._document;
    }

    this.__stopAllTimers();

    WebSocketImpl.cleanUpWindow(this);
  };

  this.getComputedStyle = function (elt) {
    elt = Element.convert(elt);
    var declaration = new CSSStyleDeclaration();
    var _Array$prototype = Array.prototype,
        forEach = _Array$prototype.forEach,
        indexOf = _Array$prototype.indexOf;
    var _elt = elt,
        style = _elt.style;

    function setPropertiesFromRule(rule) {
      if (!rule.selectorText) {
        return;
      }

      var cssSelectorSplitRe = /((?:[^,"']|"[^"]*"|'[^']*')+)/;
      var selectors = rule.selectorText.split(cssSelectorSplitRe);
      var matched = false;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = selectors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var selectorText = _step.value;

          if (selectorText !== "" && selectorText !== "," && !matched && matchesDontThrow(elt, selectorText)) {
            matched = true;
            forEach.call(rule.style, function (property) {
              declaration.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    function readStylesFromStyleSheet(sheet) {
      forEach.call(sheet.cssRules, function (rule) {
        if (rule.media) {
          if (indexOf.call(rule.media, "screen") !== -1) {
            forEach.call(rule.cssRules, setPropertiesFromRule);
          }
        } else {
          setPropertiesFromRule(rule);
        }
      });
    }

    if (!parsedDefaultStyleSheet) {
      parsedDefaultStyleSheet = cssom.parse(defaultStyleSheet);
    }

    readStylesFromStyleSheet(parsedDefaultStyleSheet);
    forEach.call(elt.ownerDocument.styleSheets, readStylesFromStyleSheet);
    forEach.call(style, function (property) {
      declaration.setProperty(property, style.getPropertyValue(property), style.getPropertyPriority(property));
    });
    return declaration;
  }; // The captureEvents() and releaseEvents() methods must do nothing


  this.captureEvents = function () {};

  this.releaseEvents = function () {}; ///// PUBLIC DATA PROPERTIES (TODO: should be getters)


  function wrapConsoleMethod(method) {
    return function () {
      var _window$_virtualConso;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_window$_virtualConso = window._virtualConsole).emit.apply(_window$_virtualConso, [method].concat(args));
    };
  }

  this.console = {
    assert: wrapConsoleMethod("assert"),
    clear: wrapConsoleMethod("clear"),
    count: wrapConsoleMethod("count"),
    countReset: wrapConsoleMethod("countReset"),
    debug: wrapConsoleMethod("debug"),
    dir: wrapConsoleMethod("dir"),
    dirxml: wrapConsoleMethod("dirxml"),
    error: wrapConsoleMethod("error"),
    group: wrapConsoleMethod("group"),
    groupCollapsed: wrapConsoleMethod("groupCollapsed"),
    groupEnd: wrapConsoleMethod("groupEnd"),
    info: wrapConsoleMethod("info"),
    log: wrapConsoleMethod("log"),
    table: wrapConsoleMethod("table"),
    time: wrapConsoleMethod("time"),
    timeEnd: wrapConsoleMethod("timeEnd"),
    trace: wrapConsoleMethod("trace"),
    warn: wrapConsoleMethod("warn")
  };

  function notImplementedMethod(name) {
    return function () {
      notImplemented(name, window);
    };
  }

  define(this, {
    name: "",
    status: "",
    devicePixelRatio: 1,
    innerWidth: 1024,
    innerHeight: 768,
    outerWidth: 1024,
    outerHeight: 768,
    pageXOffset: 0,
    pageYOffset: 0,
    screenX: 0,
    screenLeft: 0,
    screenY: 0,
    screenTop: 0,
    scrollX: 0,
    scrollY: 0,
    alert: notImplementedMethod("window.alert"),
    blur: notImplementedMethod("window.blur"),
    confirm: notImplementedMethod("window.confirm"),
    focus: notImplementedMethod("window.focus"),
    moveBy: notImplementedMethod("window.moveBy"),
    moveTo: notImplementedMethod("window.moveTo"),
    open: notImplementedMethod("window.open"),
    print: notImplementedMethod("window.print"),
    prompt: notImplementedMethod("window.prompt"),
    resizeBy: notImplementedMethod("window.resizeBy"),
    resizeTo: notImplementedMethod("window.resizeTo"),
    scroll: notImplementedMethod("window.scroll"),
    scrollBy: notImplementedMethod("window.scrollBy"),
    scrollTo: notImplementedMethod("window.scrollTo")
  }); ///// INITIALIZATION

  process.nextTick(function () {
    if (!window.document) {
      return; // window might've been closed already
    }

    if (window.document.readyState === "complete") {
      fireAnEvent("load", window, undefined, {}, window.document);
    } else {
      window.document.addEventListener("load", function () {
        fireAnEvent("load", window, undefined, {}, window.document);

        if (!idlUtils.implForWrapper(window._document)._pageShowingFlag) {
          idlUtils.implForWrapper(window._document)._pageShowingFlag = true;
          fireAnEvent("pageshow", window, PageTransitionEvent, {
            persisted: false
          }, window.document);
        }
      });
    }
  });
}

Object.setPrototypeOf(Window, EventTarget["interface"]);
Object.setPrototypeOf(Window.prototype, EventTarget["interface"].prototype);
Object.defineProperty(Window.prototype, Symbol.toStringTag, {
  value: "Window",
  writable: false,
  enumerable: false,
  configurable: true
});

function startTimer(window, startFn, stopFn, timerId, callback, ms, timerStorage, args) {
  if (!window || !window._document) {
    return undefined;
  }

  if (typeof callback !== "function") {
    var code = String(callback);
    callback = window._globalProxy.eval.bind(window, code + "\n//# sourceURL=".concat(window.location.href));
  }

  var oldCallback = callback;

  callback = function callback() {
    try {
      oldCallback.apply(window._globalProxy, args);
    } catch (e) {
      reportException(window, e, window.location.href);
    }
  };

  var res = startFn(callback, ms);
  timerStorage[timerId] = [res, stopFn];
  return timerId;
}

function stopTimer(timerStorage, id) {
  var timer = timerStorage[id];

  if (timer) {
    // Need to .call() with undefined to ensure the thisArg is not timer itself
    timer[1].call(undefined, timer[0]);
    delete timerStorage[id];
  }
}

function stopAllTimers(timers) {
  Object.keys(timers).forEach(function (key) {
    var timer = timers[key]; // Need to .call() with undefined to ensure the thisArg is not timer itself

    timer[1].call(undefined, timer[0]);
  });
}

function contextifyWindow(window) {
  if (vm.isContext(window)) {
    return;
  }

  vm.createContext(window);
  var documentImpl = idlUtils.implForWrapper(window._document);
  documentImpl._defaultView = window._globalProxy = vm.runInContext("this", window);
}