'use strict';
/* eslint-disable no-new-wrappers, no-eval, camelcase, operator-linebreak */

var _escapes;

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

module.exports = makeParserClass(require('./parser.js'));
module.exports.makeParserClass = makeParserClass;

var TomlError =
/*#__PURE__*/
function (_Error) {
  _inherits(TomlError, _Error);

  function TomlError(msg) {
    var _this;

    _classCallCheck(this, TomlError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TomlError).call(this, msg));
    _this.name = 'TomlError';
    /* istanbul ignore next */

    if (Error.captureStackTrace) Error.captureStackTrace(_assertThisInitialized(_this), TomlError);
    _this.fromTOML = true;
    _this.wrapped = null;
    return _this;
  }

  return TomlError;
}(_wrapNativeSuper(Error));

TomlError.wrap = function (err) {
  var terr = new TomlError(err.message);
  terr.code = err.code;
  terr.wrapped = err;
  return terr;
};

module.exports.TomlError = TomlError;

var createDateTime = require('./create-datetime.js');

var createDateTimeFloat = require('./create-datetime-float.js');

var createDate = require('./create-date.js');

var createTime = require('./create-time.js');

var CTRL_I = 0x09;
var CTRL_J = 0x0A;
var CTRL_M = 0x0D;
var CTRL_CHAR_BOUNDARY = 0x1F; // the last non-character in the latin1 region of unicode, except DEL

var CHAR_SP = 0x20;
var CHAR_QUOT = 0x22;
var CHAR_NUM = 0x23;
var CHAR_APOS = 0x27;
var CHAR_PLUS = 0x2B;
var CHAR_COMMA = 0x2C;
var CHAR_HYPHEN = 0x2D;
var CHAR_PERIOD = 0x2E;
var CHAR_0 = 0x30;
var CHAR_1 = 0x31;
var CHAR_7 = 0x37;
var CHAR_9 = 0x39;
var CHAR_COLON = 0x3A;
var CHAR_EQUALS = 0x3D;
var CHAR_A = 0x41;
var CHAR_E = 0x45;
var CHAR_F = 0x46;
var CHAR_T = 0x54;
var CHAR_U = 0x55;
var CHAR_Z = 0x5A;
var CHAR_LOWBAR = 0x5F;
var CHAR_a = 0x61;
var CHAR_b = 0x62;
var CHAR_e = 0x65;
var CHAR_f = 0x66;
var CHAR_i = 0x69;
var CHAR_l = 0x6C;
var CHAR_n = 0x6E;
var CHAR_o = 0x6F;
var CHAR_r = 0x72;
var CHAR_s = 0x73;
var CHAR_t = 0x74;
var CHAR_u = 0x75;
var CHAR_x = 0x78;
var CHAR_z = 0x7A;
var CHAR_LCUB = 0x7B;
var CHAR_RCUB = 0x7D;
var CHAR_LSQB = 0x5B;
var CHAR_BSOL = 0x5C;
var CHAR_RSQB = 0x5D;
var CHAR_DEL = 0x7F;
var SURROGATE_FIRST = 0xD800;
var SURROGATE_LAST = 0xDFFF;
var escapes = (_escapes = {}, _defineProperty(_escapes, CHAR_b, "\b"), _defineProperty(_escapes, CHAR_t, "\t"), _defineProperty(_escapes, CHAR_n, "\n"), _defineProperty(_escapes, CHAR_f, "\f"), _defineProperty(_escapes, CHAR_r, "\r"), _defineProperty(_escapes, CHAR_QUOT, "\""), _defineProperty(_escapes, CHAR_BSOL, "\\"), _escapes);

function isDigit(cp) {
  return cp >= CHAR_0 && cp <= CHAR_9;
}

function isHexit(cp) {
  return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
}

function isBit(cp) {
  return cp === CHAR_1 || cp === CHAR_0;
}

function isOctit(cp) {
  return cp >= CHAR_0 && cp <= CHAR_7;
}

function isAlphaNumQuoteHyphen(cp) {
  return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}

function isAlphaNumHyphen(cp) {
  return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}

var _type = Symbol('type');

var _declared = Symbol('declared');

var hasOwnProperty = Object.prototype.hasOwnProperty;
var defineProperty = Object.defineProperty;
var descriptor = {
  configurable: true,
  enumerable: true,
  writable: true,
  value: undefined
};

function hasKey(obj, key) {
  if (hasOwnProperty.call(obj, key)) return true;
  if (key === '__proto__') defineProperty(obj, '__proto__', descriptor);
  return false;
}

var INLINE_TABLE = Symbol('inline-table');

function InlineTable() {
  return Object.defineProperties({}, _defineProperty({}, _type, {
    value: INLINE_TABLE
  }));
}

function isInlineTable(obj) {
  if (obj === null || _typeof(obj) !== 'object') return false;
  return obj[_type] === INLINE_TABLE;
}

var TABLE = Symbol('table');

function Table() {
  var _Object$definePropert2;

  return Object.defineProperties({}, (_Object$definePropert2 = {}, _defineProperty(_Object$definePropert2, _type, {
    value: TABLE
  }), _defineProperty(_Object$definePropert2, _declared, {
    value: false,
    writable: true
  }), _Object$definePropert2));
}

function isTable(obj) {
  if (obj === null || _typeof(obj) !== 'object') return false;
  return obj[_type] === TABLE;
}

var _contentType = Symbol('content-type');

var INLINE_LIST = Symbol('inline-list');

function InlineList(type) {
  var _Object$definePropert3;

  return Object.defineProperties([], (_Object$definePropert3 = {}, _defineProperty(_Object$definePropert3, _type, {
    value: INLINE_LIST
  }), _defineProperty(_Object$definePropert3, _contentType, {
    value: type
  }), _Object$definePropert3));
}

function isInlineList(obj) {
  if (obj === null || _typeof(obj) !== 'object') return false;
  return obj[_type] === INLINE_LIST;
}

var LIST = Symbol('list');

function List() {
  return Object.defineProperties([], _defineProperty({}, _type, {
    value: LIST
  }));
}

function isList(obj) {
  if (obj === null || _typeof(obj) !== 'object') return false;
  return obj[_type] === LIST;
} // in an eval, to let bundlers not slurp in a util proxy


var _custom;

try {
  var utilInspect = eval("require('util').inspect");
  _custom = utilInspect.custom;
} catch (_) {}
/* eval require not available in transpiled bundle */

/* istanbul ignore next */


var _inspect = _custom || 'inspect';

var BoxedBigInt =
/*#__PURE__*/
function () {
  function BoxedBigInt(value) {
    _classCallCheck(this, BoxedBigInt);

    try {
      this.value = global.BigInt.asIntN(64, value);
    } catch (_) {
      /* istanbul ignore next */
      this.value = null;
    }

    Object.defineProperty(this, _type, {
      value: INTEGER
    });
  }

  _createClass(BoxedBigInt, [{
    key: "isNaN",
    value: function isNaN() {
      return this.value === null;
    }
    /* istanbul ignore next */

  }, {
    key: "toString",
    value: function toString() {
      return String(this.value);
    }
    /* istanbul ignore next */

  }, {
    key: _inspect,
    value: function value() {
      return "[BigInt: ".concat(this.toString(), "]}");
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }]);

  return BoxedBigInt;
}();

var INTEGER = Symbol('integer');

function Integer(_value) {
  var num = Number(_value); // -0 is a float thing, not an int thing

  if (Object.is(num, -0)) num = 0;
  /* istanbul ignore else */

  if (global.BigInt && !Number.isSafeInteger(num)) {
    return new BoxedBigInt(_value);
  } else {
    var _Object$definePropert5;

    /* istanbul ignore next */
    return Object.defineProperties(new Number(num), (_Object$definePropert5 = {
      isNaN: {
        value: function value() {
          return isNaN(this);
        }
      }
    }, _defineProperty(_Object$definePropert5, _type, {
      value: INTEGER
    }), _defineProperty(_Object$definePropert5, _inspect, {
      value: function value() {
        return "[Integer: ".concat(_value, "]");
      }
    }), _Object$definePropert5));
  }
}

function isInteger(obj) {
  if (obj === null || _typeof(obj) !== 'object') return false;
  return obj[_type] === INTEGER;
}

var FLOAT = Symbol('float');

function Float(_value2) {
  var _Object$definePropert6;

  /* istanbul ignore next */
  return Object.defineProperties(new Number(_value2), (_Object$definePropert6 = {}, _defineProperty(_Object$definePropert6, _type, {
    value: FLOAT
  }), _defineProperty(_Object$definePropert6, _inspect, {
    value: function value() {
      return "[Float: ".concat(_value2, "]");
    }
  }), _Object$definePropert6));
}

function isFloat(obj) {
  if (obj === null || _typeof(obj) !== 'object') return false;
  return obj[_type] === FLOAT;
}

function tomlType(value) {
  var type = _typeof(value);

  if (type === 'object') {
    /* istanbul ignore if */
    if (value === null) return 'null';
    if (value instanceof Date) return 'datetime';
    /* istanbul ignore else */

    if (_type in value) {
      switch (value[_type]) {
        case INLINE_TABLE:
          return 'inline-table';

        case INLINE_LIST:
          return 'inline-list';

        /* istanbul ignore next */

        case TABLE:
          return 'table';

        /* istanbul ignore next */

        case LIST:
          return 'list';

        case FLOAT:
          return 'float';

        case INTEGER:
          return 'integer';
      }
    }
  }

  return type;
}

function makeParserClass(Parser) {
  var TOMLParser =
  /*#__PURE__*/
  function (_Parser) {
    _inherits(TOMLParser, _Parser);

    function TOMLParser() {
      var _this2;

      _classCallCheck(this, TOMLParser);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(TOMLParser).call(this));
      _this2.ctx = _this2.obj = Table();
      return _this2;
    }
    /* MATCH HELPER */


    _createClass(TOMLParser, [{
      key: "atEndOfWord",
      value: function atEndOfWord() {
        return this["char"] === CHAR_NUM || this["char"] === CTRL_I || this["char"] === CHAR_SP || this.atEndOfLine();
      }
    }, {
      key: "atEndOfLine",
      value: function atEndOfLine() {
        return this["char"] === Parser.END || this["char"] === CTRL_J || this["char"] === CTRL_M;
      }
    }, {
      key: "parseStart",
      value: function parseStart() {
        if (this["char"] === Parser.END) {
          return null;
        } else if (this["char"] === CHAR_LSQB) {
          return this.call(this.parseTableOrList);
        } else if (this["char"] === CHAR_NUM) {
          return this.call(this.parseComment);
        } else if (this["char"] === CTRL_J || this["char"] === CHAR_SP || this["char"] === CTRL_I || this["char"] === CTRL_M) {
          return null;
        } else if (isAlphaNumQuoteHyphen(this["char"])) {
          return this.callNow(this.parseAssignStatement);
        } else {
          throw this.error(new TomlError("Unknown character \"".concat(this["char"], "\"")));
        }
      } // HELPER, this strips any whitespace and comments to the end of the line
      // then RETURNS. Last state in a production.

    }, {
      key: "parseWhitespaceToEOL",
      value: function parseWhitespaceToEOL() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I || this["char"] === CTRL_M) {
          return null;
        } else if (this["char"] === CHAR_NUM) {
          return this["goto"](this.parseComment);
        } else if (this["char"] === Parser.END || this["char"] === CTRL_J) {
          return this["return"]();
        } else {
          throw this.error(new TomlError('Unexpected character, expected only whitespace or comments till end of line'));
        }
      }
      /* ASSIGNMENT: key = value */

    }, {
      key: "parseAssignStatement",
      value: function parseAssignStatement() {
        return this.callNow(this.parseAssign, this.recordAssignStatement);
      }
    }, {
      key: "recordAssignStatement",
      value: function recordAssignStatement(kv) {
        var target = this.ctx;
        var finalKey = kv.key.pop();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = kv.key[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var kw = _step.value;

            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            }

            target = target[kw] = target[kw] || Table();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (hasKey(target, finalKey)) {
          throw this.error(new TomlError("Can't redefine existing key"));
        } // unbox our numbers


        if (isInteger(kv.value) || isFloat(kv.value)) {
          target[finalKey] = kv.value.valueOf();
        } else {
          target[finalKey] = kv.value;
        }

        return this["goto"](this.parseWhitespaceToEOL);
      }
      /* ASSSIGNMENT expression, key = value possibly inside an inline table */

    }, {
      key: "parseAssign",
      value: function parseAssign() {
        return this.callNow(this.parseKeyword, this.recordAssignKeyword);
      }
    }, {
      key: "recordAssignKeyword",
      value: function recordAssignKeyword(key) {
        if (this.state.resultTable) {
          this.state.resultTable.push(key);
        } else {
          this.state.resultTable = [key];
        }

        return this["goto"](this.parseAssignKeywordPreDot);
      }
    }, {
      key: "parseAssignKeywordPreDot",
      value: function parseAssignKeywordPreDot() {
        if (this["char"] === CHAR_PERIOD) {
          return this.next(this.parseAssignKeywordPostDot);
        } else if (this["char"] !== CHAR_SP && this["char"] !== CTRL_I) {
          return this["goto"](this.parseAssignEqual);
        }
      }
    }, {
      key: "parseAssignKeywordPostDot",
      value: function parseAssignKeywordPostDot() {
        if (this["char"] !== CHAR_SP && this["char"] !== CTRL_I) {
          return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
      }
    }, {
      key: "parseAssignEqual",
      value: function parseAssignEqual() {
        if (this["char"] === CHAR_EQUALS) {
          return this.next(this.parseAssignPreValue);
        } else {
          throw this.error(new TomlError('Invalid character, expected "="'));
        }
      }
    }, {
      key: "parseAssignPreValue",
      value: function parseAssignPreValue() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else {
          return this.callNow(this.parseValue, this.recordAssignValue);
        }
      }
    }, {
      key: "recordAssignValue",
      value: function recordAssignValue(value) {
        return this.returnNow({
          key: this.state.resultTable,
          value: value
        });
      }
      /* COMMENTS: #...eol */

    }, {
      key: "parseComment",
      value: function parseComment() {
        do {
          if (this["char"] === Parser.END || this["char"] === CTRL_J) {
            return this["return"]();
          }
        } while (this.nextChar());
      }
      /* TABLES AND LISTS, [foo] and [[foo]] */

    }, {
      key: "parseTableOrList",
      value: function parseTableOrList() {
        if (this["char"] === CHAR_LSQB) {
          this.next(this.parseList);
        } else {
          return this["goto"](this.parseTable);
        }
      }
      /* TABLE [foo.bar.baz] */

    }, {
      key: "parseTable",
      value: function parseTable() {
        this.ctx = this.obj;
        return this["goto"](this.parseTableNext);
      }
    }, {
      key: "parseTableNext",
      value: function parseTableNext() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else {
          return this.callNow(this.parseKeyword, this.parseTableMore);
        }
      }
    }, {
      key: "parseTableMore",
      value: function parseTableMore(keyword) {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else if (this["char"] === CHAR_RSQB) {
          if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {
            throw this.error(new TomlError("Can't redefine existing key"));
          } else {
            this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
            this.ctx[_declared] = true;
          }

          return this.next(this.parseWhitespaceToEOL);
        } else if (this["char"] === CHAR_PERIOD) {
          if (!hasKey(this.ctx, keyword)) {
            this.ctx = this.ctx[keyword] = Table();
          } else if (isTable(this.ctx[keyword])) {
            this.ctx = this.ctx[keyword];
          } else if (isList(this.ctx[keyword])) {
            this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
          } else {
            throw this.error(new TomlError("Can't redefine existing key"));
          }

          return this.next(this.parseTableNext);
        } else {
          throw this.error(new TomlError('Unexpected character, expected whitespace, . or ]'));
        }
      }
      /* LIST [[a.b.c]] */

    }, {
      key: "parseList",
      value: function parseList() {
        this.ctx = this.obj;
        return this["goto"](this.parseListNext);
      }
    }, {
      key: "parseListNext",
      value: function parseListNext() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else {
          return this.callNow(this.parseKeyword, this.parseListMore);
        }
      }
    }, {
      key: "parseListMore",
      value: function parseListMore(keyword) {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else if (this["char"] === CHAR_RSQB) {
          if (!hasKey(this.ctx, keyword)) {
            this.ctx[keyword] = List();
          }

          if (isInlineList(this.ctx[keyword])) {
            throw this.error(new TomlError("Can't extend an inline array"));
          } else if (isList(this.ctx[keyword])) {
            var next = Table();
            this.ctx[keyword].push(next);
            this.ctx = next;
          } else {
            throw this.error(new TomlError("Can't redefine an existing key"));
          }

          return this.next(this.parseListEnd);
        } else if (this["char"] === CHAR_PERIOD) {
          if (!hasKey(this.ctx, keyword)) {
            this.ctx = this.ctx[keyword] = Table();
          } else if (isInlineList(this.ctx[keyword])) {
            throw this.error(new TomlError("Can't extend an inline array"));
          } else if (isInlineTable(this.ctx[keyword])) {
            throw this.error(new TomlError("Can't extend an inline table"));
          } else if (isList(this.ctx[keyword])) {
            this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
          } else if (isTable(this.ctx[keyword])) {
            this.ctx = this.ctx[keyword];
          } else {
            throw this.error(new TomlError("Can't redefine an existing key"));
          }

          return this.next(this.parseListNext);
        } else {
          throw this.error(new TomlError('Unexpected character, expected whitespace, . or ]'));
        }
      }
    }, {
      key: "parseListEnd",
      value: function parseListEnd(keyword) {
        if (this["char"] === CHAR_RSQB) {
          return this.next(this.parseWhitespaceToEOL);
        } else {
          throw this.error(new TomlError('Unexpected character, expected whitespace, . or ]'));
        }
      }
      /* VALUE string, number, boolean, inline list, inline object */

    }, {
      key: "parseValue",
      value: function parseValue() {
        if (this["char"] === Parser.END) {
          throw this.error(new TomlError('Key without value'));
        } else if (this["char"] === CHAR_QUOT) {
          return this.next(this.parseDoubleString);
        }

        if (this["char"] === CHAR_APOS) {
          return this.next(this.parseSingleString);
        } else if (this["char"] === CHAR_HYPHEN || this["char"] === CHAR_PLUS) {
          return this["goto"](this.parseNumberSign);
        } else if (this["char"] === CHAR_i) {
          return this.next(this.parseInf);
        } else if (this["char"] === CHAR_n) {
          return this.next(this.parseNan);
        } else if (isDigit(this["char"])) {
          return this["goto"](this.parseNumberOrDateTime);
        } else if (this["char"] === CHAR_t || this["char"] === CHAR_f) {
          return this["goto"](this.parseBoolean);
        } else if (this["char"] === CHAR_LSQB) {
          return this.call(this.parseInlineList, this.recordValue);
        } else if (this["char"] === CHAR_LCUB) {
          return this.call(this.parseInlineTable, this.recordValue);
        } else {
          throw this.error(new TomlError('Unexpected character, expecting string, number, datetime, boolean, inline array or inline table'));
        }
      }
    }, {
      key: "recordValue",
      value: function recordValue(value) {
        return this.returnNow(value);
      }
    }, {
      key: "parseInf",
      value: function parseInf() {
        if (this["char"] === CHAR_n) {
          return this.next(this.parseInf2);
        } else {
          throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
      }
    }, {
      key: "parseInf2",
      value: function parseInf2() {
        if (this["char"] === CHAR_f) {
          if (this.state.buf === '-') {
            return this["return"](-Infinity);
          } else {
            return this["return"](Infinity);
          }
        } else {
          throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
      }
    }, {
      key: "parseNan",
      value: function parseNan() {
        if (this["char"] === CHAR_a) {
          return this.next(this.parseNan2);
        } else {
          throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
      }
    }, {
      key: "parseNan2",
      value: function parseNan2() {
        if (this["char"] === CHAR_n) {
          return this["return"](NaN);
        } else {
          throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
      }
      /* KEYS, barewords or basic, literal, or dotted */

    }, {
      key: "parseKeyword",
      value: function parseKeyword() {
        if (this["char"] === CHAR_QUOT) {
          return this.next(this.parseBasicString);
        } else if (this["char"] === CHAR_APOS) {
          return this.next(this.parseLiteralString);
        } else {
          return this["goto"](this.parseBareKey);
        }
      }
      /* KEYS: barewords */

    }, {
      key: "parseBareKey",
      value: function parseBareKey() {
        do {
          if (this["char"] === Parser.END) {
            throw this.error(new TomlError('Key ended without value'));
          } else if (isAlphaNumHyphen(this["char"])) {
            this.consume();
          } else if (this.state.buf.length === 0) {
            throw this.error(new TomlError('Empty bare keys are not allowed'));
          } else {
            return this.returnNow();
          }
        } while (this.nextChar());
      }
      /* STRINGS, single quoted (literal) */

    }, {
      key: "parseSingleString",
      value: function parseSingleString() {
        if (this["char"] === CHAR_APOS) {
          return this.next(this.parseLiteralMultiStringMaybe);
        } else {
          return this["goto"](this.parseLiteralString);
        }
      }
    }, {
      key: "parseLiteralString",
      value: function parseLiteralString() {
        do {
          if (this["char"] === CHAR_APOS) {
            return this["return"]();
          } else if (this.atEndOfLine()) {
            throw this.error(new TomlError('Unterminated string'));
          } else if (this["char"] === CHAR_DEL || this["char"] <= CTRL_CHAR_BOUNDARY && this["char"] !== CTRL_I) {
            throw this.errorControlCharInString();
          } else {
            this.consume();
          }
        } while (this.nextChar());
      }
    }, {
      key: "parseLiteralMultiStringMaybe",
      value: function parseLiteralMultiStringMaybe() {
        if (this["char"] === CHAR_APOS) {
          return this.next(this.parseLiteralMultiString);
        } else {
          return this.returnNow();
        }
      }
    }, {
      key: "parseLiteralMultiString",
      value: function parseLiteralMultiString() {
        if (this["char"] === CTRL_M) {
          return null;
        } else if (this["char"] === CTRL_J) {
          return this.next(this.parseLiteralMultiStringContent);
        } else {
          return this["goto"](this.parseLiteralMultiStringContent);
        }
      }
    }, {
      key: "parseLiteralMultiStringContent",
      value: function parseLiteralMultiStringContent() {
        do {
          if (this["char"] === CHAR_APOS) {
            return this.next(this.parseLiteralMultiEnd);
          } else if (this["char"] === Parser.END) {
            throw this.error(new TomlError('Unterminated multi-line string'));
          } else if (this["char"] === CHAR_DEL || this["char"] <= CTRL_CHAR_BOUNDARY && this["char"] !== CTRL_I && this["char"] !== CTRL_J && this["char"] !== CTRL_M) {
            throw this.errorControlCharInString();
          } else {
            this.consume();
          }
        } while (this.nextChar());
      }
    }, {
      key: "parseLiteralMultiEnd",
      value: function parseLiteralMultiEnd() {
        if (this["char"] === CHAR_APOS) {
          return this.next(this.parseLiteralMultiEnd2);
        } else {
          this.state.buf += "'";
          return this["goto"](this.parseLiteralMultiStringContent);
        }
      }
    }, {
      key: "parseLiteralMultiEnd2",
      value: function parseLiteralMultiEnd2() {
        if (this["char"] === CHAR_APOS) {
          return this["return"]();
        } else {
          this.state.buf += "''";
          return this["goto"](this.parseLiteralMultiStringContent);
        }
      }
      /* STRINGS double quoted */

    }, {
      key: "parseDoubleString",
      value: function parseDoubleString() {
        if (this["char"] === CHAR_QUOT) {
          return this.next(this.parseMultiStringMaybe);
        } else {
          return this["goto"](this.parseBasicString);
        }
      }
    }, {
      key: "parseBasicString",
      value: function parseBasicString() {
        do {
          if (this["char"] === CHAR_BSOL) {
            return this.call(this.parseEscape, this.recordEscapeReplacement);
          } else if (this["char"] === CHAR_QUOT) {
            return this["return"]();
          } else if (this.atEndOfLine()) {
            throw this.error(new TomlError('Unterminated string'));
          } else if (this["char"] === CHAR_DEL || this["char"] <= CTRL_CHAR_BOUNDARY && this["char"] !== CTRL_I) {
            throw this.errorControlCharInString();
          } else {
            this.consume();
          }
        } while (this.nextChar());
      }
    }, {
      key: "recordEscapeReplacement",
      value: function recordEscapeReplacement(replacement) {
        this.state.buf += replacement;
        return this["goto"](this.parseBasicString);
      }
    }, {
      key: "parseMultiStringMaybe",
      value: function parseMultiStringMaybe() {
        if (this["char"] === CHAR_QUOT) {
          return this.next(this.parseMultiString);
        } else {
          return this.returnNow();
        }
      }
    }, {
      key: "parseMultiString",
      value: function parseMultiString() {
        if (this["char"] === CTRL_M) {
          return null;
        } else if (this["char"] === CTRL_J) {
          return this.next(this.parseMultiStringContent);
        } else {
          return this["goto"](this.parseMultiStringContent);
        }
      }
    }, {
      key: "parseMultiStringContent",
      value: function parseMultiStringContent() {
        do {
          if (this["char"] === CHAR_BSOL) {
            return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
          } else if (this["char"] === CHAR_QUOT) {
            return this.next(this.parseMultiEnd);
          } else if (this["char"] === Parser.END) {
            throw this.error(new TomlError('Unterminated multi-line string'));
          } else if (this["char"] === CHAR_DEL || this["char"] <= CTRL_CHAR_BOUNDARY && this["char"] !== CTRL_I && this["char"] !== CTRL_J && this["char"] !== CTRL_M) {
            throw this.errorControlCharInString();
          } else {
            this.consume();
          }
        } while (this.nextChar());
      }
    }, {
      key: "errorControlCharInString",
      value: function errorControlCharInString() {
        var displayCode = "\\u00";

        if (this["char"] < 16) {
          displayCode += '0';
        }

        displayCode += this["char"].toString(16);
        return this.error(new TomlError("Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ".concat(displayCode, " instead")));
      }
    }, {
      key: "recordMultiEscapeReplacement",
      value: function recordMultiEscapeReplacement(replacement) {
        this.state.buf += replacement;
        return this["goto"](this.parseMultiStringContent);
      }
    }, {
      key: "parseMultiEnd",
      value: function parseMultiEnd() {
        if (this["char"] === CHAR_QUOT) {
          return this.next(this.parseMultiEnd2);
        } else {
          this.state.buf += '"';
          return this["goto"](this.parseMultiStringContent);
        }
      }
    }, {
      key: "parseMultiEnd2",
      value: function parseMultiEnd2() {
        if (this["char"] === CHAR_QUOT) {
          return this["return"]();
        } else {
          this.state.buf += '""';
          return this["goto"](this.parseMultiStringContent);
        }
      }
    }, {
      key: "parseMultiEscape",
      value: function parseMultiEscape() {
        if (this["char"] === CTRL_M || this["char"] === CTRL_J) {
          return this.next(this.parseMultiTrim);
        } else if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return this.next(this.parsePreMultiTrim);
        } else {
          return this["goto"](this.parseEscape);
        }
      }
    }, {
      key: "parsePreMultiTrim",
      value: function parsePreMultiTrim() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else if (this["char"] === CTRL_M || this["char"] === CTRL_J) {
          return this.next(this.parseMultiTrim);
        } else {
          throw this.error(new TomlError("Can't escape whitespace"));
        }
      }
    }, {
      key: "parseMultiTrim",
      value: function parseMultiTrim() {
        // explicitly whitespace here, END should follow the same path as chars
        if (this["char"] === CTRL_J || this["char"] === CHAR_SP || this["char"] === CTRL_I || this["char"] === CTRL_M) {
          return null;
        } else {
          return this.returnNow();
        }
      }
    }, {
      key: "parseEscape",
      value: function parseEscape() {
        if (this["char"] in escapes) {
          return this["return"](escapes[this["char"]]);
        } else if (this["char"] === CHAR_u) {
          return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
        } else if (this["char"] === CHAR_U) {
          return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
        } else {
          throw this.error(new TomlError('Unknown escape character: ' + this["char"]));
        }
      }
    }, {
      key: "parseUnicodeReturn",
      value: function parseUnicodeReturn(_char) {
        try {
          var codePoint = parseInt(_char, 16);

          if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {
            throw this.error(new TomlError('Invalid unicode, character in range 0xD800 - 0xDFFF is reserved'));
          }

          return this.returnNow(String.fromCodePoint(codePoint));
        } catch (err) {
          throw this.error(TomlError.wrap(err));
        }
      }
    }, {
      key: "parseSmallUnicode",
      value: function parseSmallUnicode() {
        if (!isHexit(this["char"])) {
          throw this.error(new TomlError('Invalid character in unicode sequence, expected hex'));
        } else {
          this.consume();
          if (this.state.buf.length >= 4) return this["return"]();
        }
      }
    }, {
      key: "parseLargeUnicode",
      value: function parseLargeUnicode() {
        if (!isHexit(this["char"])) {
          throw this.error(new TomlError('Invalid character in unicode sequence, expected hex'));
        } else {
          this.consume();
          if (this.state.buf.length >= 8) return this["return"]();
        }
      }
      /* NUMBERS */

    }, {
      key: "parseNumberSign",
      value: function parseNumberSign() {
        this.consume();
        return this.next(this.parseMaybeSignedInfOrNan);
      }
    }, {
      key: "parseMaybeSignedInfOrNan",
      value: function parseMaybeSignedInfOrNan() {
        if (this["char"] === CHAR_i) {
          return this.next(this.parseInf);
        } else if (this["char"] === CHAR_n) {
          return this.next(this.parseNan);
        } else {
          return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
        }
      }
    }, {
      key: "parseNumberIntegerStart",
      value: function parseNumberIntegerStart() {
        if (this["char"] === CHAR_0) {
          this.consume();
          return this.next(this.parseNumberIntegerExponentOrDecimal);
        } else {
          return this["goto"](this.parseNumberInteger);
        }
      }
    }, {
      key: "parseNumberIntegerExponentOrDecimal",
      value: function parseNumberIntegerExponentOrDecimal() {
        if (this["char"] === CHAR_PERIOD) {
          this.consume();
          return this.call(this.parseNoUnder, this.parseNumberFloat);
        } else if (this["char"] === CHAR_E || this["char"] === CHAR_e) {
          this.consume();
          return this.next(this.parseNumberExponentSign);
        } else {
          return this.returnNow(Integer(this.state.buf));
        }
      }
    }, {
      key: "parseNumberInteger",
      value: function parseNumberInteger() {
        if (isDigit(this["char"])) {
          this.consume();
        } else if (this["char"] === CHAR_LOWBAR) {
          return this.call(this.parseNoUnder);
        } else if (this["char"] === CHAR_E || this["char"] === CHAR_e) {
          this.consume();
          return this.next(this.parseNumberExponentSign);
        } else if (this["char"] === CHAR_PERIOD) {
          this.consume();
          return this.call(this.parseNoUnder, this.parseNumberFloat);
        } else {
          var result = Integer(this.state.buf);
          /* istanbul ignore if */

          if (result.isNaN()) {
            throw this.error(new TomlError('Invalid number'));
          } else {
            return this.returnNow(result);
          }
        }
      }
    }, {
      key: "parseNoUnder",
      value: function parseNoUnder() {
        if (this["char"] === CHAR_LOWBAR || this["char"] === CHAR_PERIOD || this["char"] === CHAR_E || this["char"] === CHAR_e) {
          throw this.error(new TomlError('Unexpected character, expected digit'));
        } else if (this.atEndOfWord()) {
          throw this.error(new TomlError('Incomplete number'));
        }

        return this.returnNow();
      }
    }, {
      key: "parseNoUnderHexOctBinLiteral",
      value: function parseNoUnderHexOctBinLiteral() {
        if (this["char"] === CHAR_LOWBAR || this["char"] === CHAR_PERIOD) {
          throw this.error(new TomlError('Unexpected character, expected digit'));
        } else if (this.atEndOfWord()) {
          throw this.error(new TomlError('Incomplete number'));
        }

        return this.returnNow();
      }
    }, {
      key: "parseNumberFloat",
      value: function parseNumberFloat() {
        if (this["char"] === CHAR_LOWBAR) {
          return this.call(this.parseNoUnder, this.parseNumberFloat);
        } else if (isDigit(this["char"])) {
          this.consume();
        } else if (this["char"] === CHAR_E || this["char"] === CHAR_e) {
          this.consume();
          return this.next(this.parseNumberExponentSign);
        } else {
          return this.returnNow(Float(this.state.buf));
        }
      }
    }, {
      key: "parseNumberExponentSign",
      value: function parseNumberExponentSign() {
        if (isDigit(this["char"])) {
          return this["goto"](this.parseNumberExponent);
        } else if (this["char"] === CHAR_HYPHEN || this["char"] === CHAR_PLUS) {
          this.consume();
          this.call(this.parseNoUnder, this.parseNumberExponent);
        } else {
          throw this.error(new TomlError('Unexpected character, expected -, + or digit'));
        }
      }
    }, {
      key: "parseNumberExponent",
      value: function parseNumberExponent() {
        if (isDigit(this["char"])) {
          this.consume();
        } else if (this["char"] === CHAR_LOWBAR) {
          return this.call(this.parseNoUnder);
        } else {
          return this.returnNow(Float(this.state.buf));
        }
      }
      /* NUMBERS or DATETIMES  */

    }, {
      key: "parseNumberOrDateTime",
      value: function parseNumberOrDateTime() {
        if (this["char"] === CHAR_0) {
          this.consume();
          return this.next(this.parseNumberBaseOrDateTime);
        } else {
          return this["goto"](this.parseNumberOrDateTimeOnly);
        }
      }
    }, {
      key: "parseNumberOrDateTimeOnly",
      value: function parseNumberOrDateTimeOnly() {
        // note, if two zeros are in a row then it MUST be a date
        if (this["char"] === CHAR_LOWBAR) {
          return this.call(this.parseNoUnder, this.parseNumberInteger);
        } else if (isDigit(this["char"])) {
          this.consume();
          if (this.state.buf.length > 4) this.next(this.parseNumberInteger);
        } else if (this["char"] === CHAR_E || this["char"] === CHAR_e) {
          this.consume();
          return this.next(this.parseNumberExponentSign);
        } else if (this["char"] === CHAR_PERIOD) {
          this.consume();
          return this.call(this.parseNoUnder, this.parseNumberFloat);
        } else if (this["char"] === CHAR_HYPHEN) {
          return this["goto"](this.parseDateTime);
        } else if (this["char"] === CHAR_COLON) {
          return this["goto"](this.parseOnlyTimeHour);
        } else {
          return this.returnNow(Integer(this.state.buf));
        }
      }
    }, {
      key: "parseDateTimeOnly",
      value: function parseDateTimeOnly() {
        if (this.state.buf.length < 4) {
          if (isDigit(this["char"])) {
            return this.consume();
          } else if (this["char"] === CHAR_COLON) {
            return this["goto"](this.parseOnlyTimeHour);
          } else {
            throw this.error(new TomlError('Expected digit while parsing year part of a date'));
          }
        } else {
          if (this["char"] === CHAR_HYPHEN) {
            return this["goto"](this.parseDateTime);
          } else {
            throw this.error(new TomlError('Expected hyphen (-) while parsing year part of date'));
          }
        }
      }
    }, {
      key: "parseNumberBaseOrDateTime",
      value: function parseNumberBaseOrDateTime() {
        if (this["char"] === CHAR_b) {
          this.consume();
          return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin);
        } else if (this["char"] === CHAR_o) {
          this.consume();
          return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct);
        } else if (this["char"] === CHAR_x) {
          this.consume();
          return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex);
        } else if (this["char"] === CHAR_PERIOD) {
          return this["goto"](this.parseNumberInteger);
        } else if (isDigit(this["char"])) {
          return this["goto"](this.parseDateTimeOnly);
        } else {
          return this.returnNow(Integer(this.state.buf));
        }
      }
    }, {
      key: "parseIntegerHex",
      value: function parseIntegerHex() {
        if (isHexit(this["char"])) {
          this.consume();
        } else if (this["char"] === CHAR_LOWBAR) {
          return this.call(this.parseNoUnderHexOctBinLiteral);
        } else {
          var result = Integer(this.state.buf);
          /* istanbul ignore if */

          if (result.isNaN()) {
            throw this.error(new TomlError('Invalid number'));
          } else {
            return this.returnNow(result);
          }
        }
      }
    }, {
      key: "parseIntegerOct",
      value: function parseIntegerOct() {
        if (isOctit(this["char"])) {
          this.consume();
        } else if (this["char"] === CHAR_LOWBAR) {
          return this.call(this.parseNoUnderHexOctBinLiteral);
        } else {
          var result = Integer(this.state.buf);
          /* istanbul ignore if */

          if (result.isNaN()) {
            throw this.error(new TomlError('Invalid number'));
          } else {
            return this.returnNow(result);
          }
        }
      }
    }, {
      key: "parseIntegerBin",
      value: function parseIntegerBin() {
        if (isBit(this["char"])) {
          this.consume();
        } else if (this["char"] === CHAR_LOWBAR) {
          return this.call(this.parseNoUnderHexOctBinLiteral);
        } else {
          var result = Integer(this.state.buf);
          /* istanbul ignore if */

          if (result.isNaN()) {
            throw this.error(new TomlError('Invalid number'));
          } else {
            return this.returnNow(result);
          }
        }
      }
      /* DATETIME */

    }, {
      key: "parseDateTime",
      value: function parseDateTime() {
        // we enter here having just consumed the year and about to consume the hyphen
        if (this.state.buf.length < 4) {
          throw this.error(new TomlError('Years less than 1000 must be zero padded to four characters'));
        }

        this.state.result = this.state.buf;
        this.state.buf = '';
        return this.next(this.parseDateMonth);
      }
    }, {
      key: "parseDateMonth",
      value: function parseDateMonth() {
        if (this["char"] === CHAR_HYPHEN) {
          if (this.state.buf.length < 2) {
            throw this.error(new TomlError('Months less than 10 must be zero padded to two characters'));
          }

          this.state.result += '-' + this.state.buf;
          this.state.buf = '';
          return this.next(this.parseDateDay);
        } else if (isDigit(this["char"])) {
          this.consume();
        } else {
          throw this.error(new TomlError('Incomplete datetime'));
        }
      }
    }, {
      key: "parseDateDay",
      value: function parseDateDay() {
        if (this["char"] === CHAR_T || this["char"] === CHAR_SP) {
          if (this.state.buf.length < 2) {
            throw this.error(new TomlError('Days less than 10 must be zero padded to two characters'));
          }

          this.state.result += '-' + this.state.buf;
          this.state.buf = '';
          return this.next(this.parseStartTimeHour);
        } else if (this.atEndOfWord()) {
          return this.returnNow(createDate(this.state.result + '-' + this.state.buf));
        } else if (isDigit(this["char"])) {
          this.consume();
        } else {
          throw this.error(new TomlError('Incomplete datetime'));
        }
      }
    }, {
      key: "parseStartTimeHour",
      value: function parseStartTimeHour() {
        if (this.atEndOfWord()) {
          return this.returnNow(createDate(this.state.result));
        } else {
          return this["goto"](this.parseTimeHour);
        }
      }
    }, {
      key: "parseTimeHour",
      value: function parseTimeHour() {
        if (this["char"] === CHAR_COLON) {
          if (this.state.buf.length < 2) {
            throw this.error(new TomlError('Hours less than 10 must be zero padded to two characters'));
          }

          this.state.result += 'T' + this.state.buf;
          this.state.buf = '';
          return this.next(this.parseTimeMin);
        } else if (isDigit(this["char"])) {
          this.consume();
        } else {
          throw this.error(new TomlError('Incomplete datetime'));
        }
      }
    }, {
      key: "parseTimeMin",
      value: function parseTimeMin() {
        if (this.state.buf.length < 2 && isDigit(this["char"])) {
          this.consume();
        } else if (this.state.buf.length === 2 && this["char"] === CHAR_COLON) {
          this.state.result += ':' + this.state.buf;
          this.state.buf = '';
          return this.next(this.parseTimeSec);
        } else {
          throw this.error(new TomlError('Incomplete datetime'));
        }
      }
    }, {
      key: "parseTimeSec",
      value: function parseTimeSec() {
        if (isDigit(this["char"])) {
          this.consume();

          if (this.state.buf.length === 2) {
            this.state.result += ':' + this.state.buf;
            this.state.buf = '';
            return this.next(this.parseTimeZoneOrFraction);
          }
        } else {
          throw this.error(new TomlError('Incomplete datetime'));
        }
      }
    }, {
      key: "parseOnlyTimeHour",
      value: function parseOnlyTimeHour() {
        /* istanbul ignore else */
        if (this["char"] === CHAR_COLON) {
          if (this.state.buf.length < 2) {
            throw this.error(new TomlError('Hours less than 10 must be zero padded to two characters'));
          }

          this.state.result = this.state.buf;
          this.state.buf = '';
          return this.next(this.parseOnlyTimeMin);
        } else {
          throw this.error(new TomlError('Incomplete time'));
        }
      }
    }, {
      key: "parseOnlyTimeMin",
      value: function parseOnlyTimeMin() {
        if (this.state.buf.length < 2 && isDigit(this["char"])) {
          this.consume();
        } else if (this.state.buf.length === 2 && this["char"] === CHAR_COLON) {
          this.state.result += ':' + this.state.buf;
          this.state.buf = '';
          return this.next(this.parseOnlyTimeSec);
        } else {
          throw this.error(new TomlError('Incomplete time'));
        }
      }
    }, {
      key: "parseOnlyTimeSec",
      value: function parseOnlyTimeSec() {
        if (isDigit(this["char"])) {
          this.consume();

          if (this.state.buf.length === 2) {
            return this.next(this.parseOnlyTimeFractionMaybe);
          }
        } else {
          throw this.error(new TomlError('Incomplete time'));
        }
      }
    }, {
      key: "parseOnlyTimeFractionMaybe",
      value: function parseOnlyTimeFractionMaybe() {
        this.state.result += ':' + this.state.buf;

        if (this["char"] === CHAR_PERIOD) {
          this.state.buf = '';
          this.next(this.parseOnlyTimeFraction);
        } else {
          return this["return"](createTime(this.state.result));
        }
      }
    }, {
      key: "parseOnlyTimeFraction",
      value: function parseOnlyTimeFraction() {
        if (isDigit(this["char"])) {
          this.consume();
        } else if (this.atEndOfWord()) {
          if (this.state.buf.length === 0) throw this.error(new TomlError('Expected digit in milliseconds'));
          return this.returnNow(createTime(this.state.result + '.' + this.state.buf));
        } else {
          throw this.error(new TomlError('Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z'));
        }
      }
    }, {
      key: "parseTimeZoneOrFraction",
      value: function parseTimeZoneOrFraction() {
        if (this["char"] === CHAR_PERIOD) {
          this.consume();
          this.next(this.parseDateTimeFraction);
        } else if (this["char"] === CHAR_HYPHEN || this["char"] === CHAR_PLUS) {
          this.consume();
          this.next(this.parseTimeZoneHour);
        } else if (this["char"] === CHAR_Z) {
          this.consume();
          return this["return"](createDateTime(this.state.result + this.state.buf));
        } else if (this.atEndOfWord()) {
          return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
        } else {
          throw this.error(new TomlError('Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z'));
        }
      }
    }, {
      key: "parseDateTimeFraction",
      value: function parseDateTimeFraction() {
        if (isDigit(this["char"])) {
          this.consume();
        } else if (this.state.buf.length === 1) {
          throw this.error(new TomlError('Expected digit in milliseconds'));
        } else if (this["char"] === CHAR_HYPHEN || this["char"] === CHAR_PLUS) {
          this.consume();
          this.next(this.parseTimeZoneHour);
        } else if (this["char"] === CHAR_Z) {
          this.consume();
          return this["return"](createDateTime(this.state.result + this.state.buf));
        } else if (this.atEndOfWord()) {
          return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
        } else {
          throw this.error(new TomlError('Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z'));
        }
      }
    }, {
      key: "parseTimeZoneHour",
      value: function parseTimeZoneHour() {
        if (isDigit(this["char"])) {
          this.consume(); // FIXME: No more regexps

          if (/\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
        } else {
          throw this.error(new TomlError('Unexpected character in datetime, expected digit'));
        }
      }
    }, {
      key: "parseTimeZoneSep",
      value: function parseTimeZoneSep() {
        if (this["char"] === CHAR_COLON) {
          this.consume();
          this.next(this.parseTimeZoneMin);
        } else {
          throw this.error(new TomlError('Unexpected character in datetime, expected colon'));
        }
      }
    }, {
      key: "parseTimeZoneMin",
      value: function parseTimeZoneMin() {
        if (isDigit(this["char"])) {
          this.consume();
          if (/\d\d$/.test(this.state.buf)) return this["return"](createDateTime(this.state.result + this.state.buf));
        } else {
          throw this.error(new TomlError('Unexpected character in datetime, expected digit'));
        }
      }
      /* BOOLEAN */

    }, {
      key: "parseBoolean",
      value: function parseBoolean() {
        /* istanbul ignore else */
        if (this["char"] === CHAR_t) {
          this.consume();
          return this.next(this.parseTrue_r);
        } else if (this["char"] === CHAR_f) {
          this.consume();
          return this.next(this.parseFalse_a);
        }
      }
    }, {
      key: "parseTrue_r",
      value: function parseTrue_r() {
        if (this["char"] === CHAR_r) {
          this.consume();
          return this.next(this.parseTrue_u);
        } else {
          throw this.error(new TomlError('Invalid boolean, expected true or false'));
        }
      }
    }, {
      key: "parseTrue_u",
      value: function parseTrue_u() {
        if (this["char"] === CHAR_u) {
          this.consume();
          return this.next(this.parseTrue_e);
        } else {
          throw this.error(new TomlError('Invalid boolean, expected true or false'));
        }
      }
    }, {
      key: "parseTrue_e",
      value: function parseTrue_e() {
        if (this["char"] === CHAR_e) {
          return this["return"](true);
        } else {
          throw this.error(new TomlError('Invalid boolean, expected true or false'));
        }
      }
    }, {
      key: "parseFalse_a",
      value: function parseFalse_a() {
        if (this["char"] === CHAR_a) {
          this.consume();
          return this.next(this.parseFalse_l);
        } else {
          throw this.error(new TomlError('Invalid boolean, expected true or false'));
        }
      }
    }, {
      key: "parseFalse_l",
      value: function parseFalse_l() {
        if (this["char"] === CHAR_l) {
          this.consume();
          return this.next(this.parseFalse_s);
        } else {
          throw this.error(new TomlError('Invalid boolean, expected true or false'));
        }
      }
    }, {
      key: "parseFalse_s",
      value: function parseFalse_s() {
        if (this["char"] === CHAR_s) {
          this.consume();
          return this.next(this.parseFalse_e);
        } else {
          throw this.error(new TomlError('Invalid boolean, expected true or false'));
        }
      }
    }, {
      key: "parseFalse_e",
      value: function parseFalse_e() {
        if (this["char"] === CHAR_e) {
          return this["return"](false);
        } else {
          throw this.error(new TomlError('Invalid boolean, expected true or false'));
        }
      }
      /* INLINE LISTS */

    }, {
      key: "parseInlineList",
      value: function parseInlineList() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I || this["char"] === CTRL_M || this["char"] === CTRL_J) {
          return null;
        } else if (this["char"] === Parser.END) {
          throw this.error(new TomlError('Unterminated inline array'));
        } else if (this["char"] === CHAR_NUM) {
          return this.call(this.parseComment);
        } else if (this["char"] === CHAR_RSQB) {
          return this["return"](this.state.resultArr || InlineList());
        } else {
          return this.callNow(this.parseValue, this.recordInlineListValue);
        }
      }
    }, {
      key: "recordInlineListValue",
      value: function recordInlineListValue(value) {
        if (this.state.resultArr) {
          var listType = this.state.resultArr[_contentType];
          var valueType = tomlType(value);

          if (listType !== valueType) {
            throw this.error(new TomlError("Inline lists must be a single type, not a mix of ".concat(listType, " and ").concat(valueType)));
          }
        } else {
          this.state.resultArr = InlineList(tomlType(value));
        }

        if (isFloat(value) || isInteger(value)) {
          // unbox now that we've verified they're ok
          this.state.resultArr.push(value.valueOf());
        } else {
          this.state.resultArr.push(value);
        }

        return this["goto"](this.parseInlineListNext);
      }
    }, {
      key: "parseInlineListNext",
      value: function parseInlineListNext() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I || this["char"] === CTRL_M || this["char"] === CTRL_J) {
          return null;
        } else if (this["char"] === CHAR_NUM) {
          return this.call(this.parseComment);
        } else if (this["char"] === CHAR_COMMA) {
          return this.next(this.parseInlineList);
        } else if (this["char"] === CHAR_RSQB) {
          return this["goto"](this.parseInlineList);
        } else {
          throw this.error(new TomlError('Invalid character, expected whitespace, comma (,) or close bracket (])'));
        }
      }
      /* INLINE TABLE */

    }, {
      key: "parseInlineTable",
      value: function parseInlineTable() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else if (this["char"] === Parser.END || this["char"] === CHAR_NUM || this["char"] === CTRL_J || this["char"] === CTRL_M) {
          throw this.error(new TomlError('Unterminated inline array'));
        } else if (this["char"] === CHAR_RCUB) {
          return this["return"](this.state.resultTable || InlineTable());
        } else {
          if (!this.state.resultTable) this.state.resultTable = InlineTable();
          return this.callNow(this.parseAssign, this.recordInlineTableValue);
        }
      }
    }, {
      key: "recordInlineTableValue",
      value: function recordInlineTableValue(kv) {
        var target = this.state.resultTable;
        var finalKey = kv.key.pop();
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = kv.key[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var kw = _step2.value;

            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            }

            target = target[kw] = target[kw] || Table();
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (hasKey(target, finalKey)) {
          throw this.error(new TomlError("Can't redefine existing key"));
        }

        if (isInteger(kv.value) || isFloat(kv.value)) {
          target[finalKey] = kv.value.valueOf();
        } else {
          target[finalKey] = kv.value;
        }

        return this["goto"](this.parseInlineTableNext);
      }
    }, {
      key: "parseInlineTableNext",
      value: function parseInlineTableNext() {
        if (this["char"] === CHAR_SP || this["char"] === CTRL_I) {
          return null;
        } else if (this["char"] === Parser.END || this["char"] === CHAR_NUM || this["char"] === CTRL_J || this["char"] === CTRL_M) {
          throw this.error(new TomlError('Unterminated inline array'));
        } else if (this["char"] === CHAR_COMMA) {
          return this.next(this.parseInlineTable);
        } else if (this["char"] === CHAR_RCUB) {
          return this["goto"](this.parseInlineTable);
        } else {
          throw this.error(new TomlError('Invalid character, expected whitespace, comma (,) or close bracket (])'));
        }
      }
    }]);

    return TOMLParser;
  }(Parser);

  return TOMLParser;
}