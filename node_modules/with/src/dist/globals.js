"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
var assert_never_1 = require("assert-never");
var babel_walk_1 = require("babel-walk");
var t = require("@babel/types");
var reference_1 = require("./reference");
var isScope = function (node) { return t.isFunctionParent(node) || t.isProgram(node); };
var isBlockScope = function (node) {
    return t.isBlockStatement(node) || isScope(node);
};
var declaresArguments = function (node) {
    return t.isFunction(node) && !t.isArrowFunctionExpression(node);
};
var declaresThis = declaresArguments;
var LOCALS_SYMBOL = Symbol('locals');
var getLocals = function (node) {
    return node[LOCALS_SYMBOL];
};
var declareLocals = function (node) {
    return (node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set());
};
var setLocal = function (node, name) { return declareLocals(node).add(name); };
// First pass
function declareFunction(node) {
    for (var _i = 0, _a = node.params; _i < _a.length; _i++) {
        var param = _a[_i];
        declarePattern(param, node);
    }
    var id = node.id;
    if (id) {
        setLocal(node, id.name);
    }
}
function declarePattern(node, parent) {
    switch (node.type) {
        case 'Identifier':
            setLocal(parent, node.name);
            break;
        case 'ObjectPattern':
            for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                var prop = _a[_i];
                switch (prop.type) {
                    case 'RestElement':
                        declarePattern(prop.argument, parent);
                        break;
                    case 'ObjectProperty':
                        declarePattern(prop.value, parent);
                        break;
                    default:
                        assert_never_1["default"](prop);
                        break;
                }
            }
            break;
        case 'ArrayPattern':
            for (var _b = 0, _c = node.elements; _b < _c.length; _b++) {
                var element = _c[_b];
                if (element)
                    declarePattern(element, parent);
            }
            break;
        case 'RestElement':
            declarePattern(node.argument, parent);
            break;
        case 'AssignmentPattern':
            declarePattern(node.left, parent);
            break;
        // istanbul ignore next
        default:
            throw new Error('Unrecognized pattern type: ' + node.type);
    }
}
function declareModuleSpecifier(node, _state, parents) {
    for (var i = parents.length - 2; i >= 0; i--) {
        if (isScope(parents[i])) {
            setLocal(parents[i], node.local.name);
            return;
        }
    }
}
var firstPass = babel_walk_1.ancestor({
    VariableDeclaration: function (node, _state, parents) {
        for (var i = parents.length - 2; i >= 0; i--) {
            if (node.kind === 'var'
                ? t.isFunctionParent(parents[i])
                : isBlockScope(parents[i])) {
                for (var _i = 0, _a = node.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    declarePattern(declaration.id, parents[i]);
                }
                return;
            }
        }
    },
    FunctionDeclaration: function (node, _state, parents) {
        if (node.id) {
            for (var i = parents.length - 2; i >= 0; i--) {
                if (isScope(parents[i])) {
                    setLocal(parents[i], node.id.name);
                    return;
                }
            }
        }
    },
    Function: declareFunction,
    ClassDeclaration: function (node, _state, parents) {
        for (var i = parents.length - 2; i >= 0; i--) {
            if (isScope(parents[i])) {
                setLocal(parents[i], node.id.name);
                return;
            }
        }
    },
    TryStatement: function (node) {
        if (node.handler === null)
            return;
        if (node.handler.param === null)
            return;
        declarePattern(node.handler.param, node.handler);
    },
    ImportDefaultSpecifier: declareModuleSpecifier,
    ImportSpecifier: declareModuleSpecifier,
    ImportNamespaceSpecifier: declareModuleSpecifier
});
// Second pass
var secondPass = babel_walk_1.ancestor({
    Identifier: function (node, state, parents) {
        var _a;
        var name = node.name;
        if (name === 'undefined')
            return;
        var lastParent = parents[parents.length - 2];
        if (lastParent) {
            if (!reference_1["default"](node, lastParent))
                return;
            for (var _i = 0, parents_1 = parents; _i < parents_1.length; _i++) {
                var parent = parents_1[_i];
                if (name === 'arguments' && declaresArguments(parent)) {
                    return;
                }
                if ((_a = getLocals(parent)) === null || _a === void 0 ? void 0 : _a.has(name)) {
                    return;
                }
            }
        }
        state.globals.push(node);
    },
    ThisExpression: function (node, state, parents) {
        for (var _i = 0, parents_2 = parents; _i < parents_2.length; _i++) {
            var parent = parents_2[_i];
            if (declaresThis(parent)) {
                return;
            }
        }
        state.globals.push(node);
    }
});
function findGlobals(ast) {
    var globals = [];
    // istanbul ignore if
    if (!t.isNode(ast)) {
        throw new TypeError('Source must be a Babylon AST');
    }
    firstPass(ast, undefined);
    secondPass(ast, { globals: globals });
    var groupedGlobals = new Map();
    for (var _i = 0, globals_1 = globals; _i < globals_1.length; _i++) {
        var node = globals_1[_i];
        var name = node.type === 'ThisExpression' ? 'this' : node.name;
        var existing = groupedGlobals.get(name);
        if (existing) {
            existing.push(node);
        }
        else {
            groupedGlobals.set(name, [node]);
        }
    }
    return __spreadArrays(groupedGlobals).map(function (_a) {
        var name = _a[0], nodes = _a[1];
        return ({ name: name, nodes: nodes });
    })
        .sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
}
exports["default"] = findGlobals;
