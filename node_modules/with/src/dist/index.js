"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
var parser_1 = require("@babel/parser");
var babel_walk_1 = require("babel-walk");
var t = require("@babel/types");
var globals_1 = require("./globals");
var parseOptions = {
    allowReturnOutsideFunction: true,
    allowImportExportEverywhere: true
};
/**
 * Mimic `with` as far as possible but at compile time
 *
 * @param obj The object part of a with expression
 * @param src The body of the with expression
 * @param exclude A list of variable names to explicitly exclude
 */
function addWith(obj, src, exclude) {
    if (exclude === void 0) { exclude = []; }
    // tslint:disable-next-line: no-parameter-reassignment
    obj = obj + '';
    // tslint:disable-next-line: no-parameter-reassignment
    src = src + '';
    var ast;
    try {
        ast = parser_1.parse(src, parseOptions);
    }
    catch (e) {
        throw Object.assign(new Error('Error parsing body of the with expression'), {
            component: 'src',
            babylonError: e
        });
    }
    var objAst;
    try {
        objAst = parser_1.parse(obj, parseOptions);
    }
    catch (e) {
        throw Object.assign(new Error('Error parsing object part of the with expression'), {
            component: 'obj',
            babylonError: e
        });
    }
    var excludeSet = new Set(__spreadArrays([
        'undefined',
        'this'
    ], exclude, globals_1["default"](objAst).map(function (g) { return g.name; })));
    var vars = new Set(globals_1["default"](ast)
        .map(function (global) { return global.name; })
        .filter(function (v) { return !excludeSet.has(v); }));
    if (vars.size === 0)
        return src;
    var declareLocal = '';
    var local = 'locals_for_with';
    var result = 'result_of_with';
    if (t.isValidIdentifier(obj)) {
        local = obj;
    }
    else {
        while (vars.has(local) || excludeSet.has(local)) {
            local += '_';
        }
        declareLocal = "var " + local + " = (" + obj + ");";
    }
    while (vars.has(result) || excludeSet.has(result)) {
        result += '_';
    }
    var args = __spreadArrays([
        'this'
    ], Array.from(vars).map(function (v) {
        return JSON.stringify(v) + " in " + local + " ?\n        " + local + "." + v + " :\n        typeof " + v + " !== 'undefined' ? " + v + " : undefined";
    }));
    var unwrapped = unwrapReturns(ast, src, result);
    return ";\n    " + declareLocal + "\n    " + unwrapped.before + "\n    (function (" + Array.from(vars).join(', ') + ") {\n      " + unwrapped.body + "\n    }.call(" + args.join(', ') + "));\n    " + unwrapped.after + ";";
}
exports["default"] = addWith;
var unwrapReturnsVisitors = babel_walk_1.recursive({
    Function: function (_node, _state, _c) {
        // returns in these functions are not applicable
    },
    ReturnStatement: function (node, state) {
        state.hasReturn = true;
        var value = '';
        if (node.argument) {
            value = "value: (" + state.source(node.argument) + ")";
        }
        state.replace(node, "return {" + value + "};");
    }
});
/**
 * Take a self calling function, and unwrap it such that return inside the function
 * results in return outside the function
 *
 * @param src    Some JavaScript code representing a self-calling function
 * @param result A temporary variable to store the result in
 */
function unwrapReturns(ast, src, result) {
    var charArray = src.split('');
    var state = {
        hasReturn: false,
        source: function (node) {
            return src.slice(node.start, node.end);
        },
        replace: function (node, str) {
            charArray.fill('', node.start, node.end);
            charArray[node.start] = str;
        }
    };
    unwrapReturnsVisitors(ast, state);
    return {
        before: state.hasReturn ? "var " + result + " = " : '',
        body: charArray.join(''),
        after: state.hasReturn ? ";if (" + result + ") return " + result + ".value" : ''
    };
}
module.exports = addWith;
module.exports["default"] = addWith;
