"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var parser_1 = require("@babel/parser");

var babel_walk_1 = require("babel-walk");

var t = __importStar(require("@babel/types"));

var globals_1 = __importDefault(require("./globals"));

var parseOptions = {
  allowReturnOutsideFunction: true,
  allowImportExportEverywhere: true
};
/**
 * Mimic `with` as far as possible but at compile time
 *
 * @param obj The object part of a with expression
 * @param src The body of the with expression
 * @param exclude A list of variable names to explicitly exclude
 */

function addWith(obj, src) {
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  // tslint:disable-next-line: no-parameter-reassignment
  obj = obj + ''; // tslint:disable-next-line: no-parameter-reassignment

  src = src + '';
  var ast;

  try {
    ast = parser_1.parse(src, parseOptions);
  } catch (e) {
    throw Object.assign(new Error('Error parsing body of the with expression'), {
      component: 'src',
      babylonError: e
    });
  }

  var objAst;

  try {
    objAst = parser_1.parse(obj, parseOptions);
  } catch (e) {
    throw Object.assign(new Error('Error parsing object part of the with expression'), {
      component: 'obj',
      babylonError: e
    });
  }

  var excludeSet = new Set(['undefined', 'this'].concat(_toConsumableArray(exclude), _toConsumableArray(globals_1["default"](objAst).map(function (g) {
    return g.name;
  }))));
  var vars = new Set(globals_1["default"](ast).map(function (global) {
    return global.name;
  }).filter(function (v) {
    return !excludeSet.has(v);
  }));
  if (vars.size === 0) return src;
  var declareLocal = '';
  var local = 'locals_for_with';
  var result = 'result_of_with';

  if (t.isValidIdentifier(obj)) {
    local = obj;
  } else {
    while (vars.has(local) || excludeSet.has(local)) {
      local += '_';
    }

    declareLocal = "var ".concat(local, " = (").concat(obj, ");");
  }

  while (vars.has(result) || excludeSet.has(result)) {
    result += '_';
  }

  var args = ['this'].concat(_toConsumableArray(Array.from(vars).map(function (v) {
    return "".concat(JSON.stringify(v), " in ").concat(local, " ?\n        ").concat(local, ".").concat(v, " :\n        typeof ").concat(v, " !== 'undefined' ? ").concat(v, " : undefined");
  })));
  var unwrapped = unwrapReturns(ast, src, result);
  return ";\n    ".concat(declareLocal, "\n    ").concat(unwrapped.before, "\n    (function (").concat(Array.from(vars).join(', '), ") {\n      ").concat(unwrapped.body, "\n    }.call(").concat(args.join(', '), "));\n    ").concat(unwrapped.after, ";");
}

exports["default"] = addWith;
var unwrapReturnsVisitors = babel_walk_1.recursive({
  Function: function Function(_node, _state, _c) {// returns in these functions are not applicable
  },
  ReturnStatement: function ReturnStatement(node, state) {
    state.hasReturn = true;
    var value = '';

    if (node.argument) {
      value = "value: (".concat(state.source(node.argument), ")");
    }

    state.replace(node, "return {".concat(value, "};"));
  }
});
/**
 * Take a self calling function, and unwrap it such that return inside the function
 * results in return outside the function
 *
 * @param src    Some JavaScript code representing a self-calling function
 * @param result A temporary variable to store the result in
 */

function unwrapReturns(ast, src, result) {
  var charArray = src.split('');
  var state = {
    hasReturn: false,
    source: function source(node) {
      return src.slice(node.start, node.end);
    },
    replace: function replace(node, str) {
      charArray.fill('', node.start, node.end);
      charArray[node.start] = str;
    }
  };
  unwrapReturnsVisitors(ast, state);
  return {
    before: state.hasReturn ? "var ".concat(result, " = ") : '',
    body: charArray.join(''),
    after: state.hasReturn ? ";if (".concat(result, ") return ").concat(result, ".value") : ''
  };
}

module.exports = addWith;
module.exports["default"] = addWith;