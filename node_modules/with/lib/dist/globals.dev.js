"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var assert_never_1 = __importDefault(require("assert-never"));

var babel_walk_1 = require("babel-walk");

var t = __importStar(require("@babel/types"));

var reference_1 = __importDefault(require("./reference"));

var isScope = function isScope(node) {
  return t.isFunctionParent(node) || t.isProgram(node);
};

var isBlockScope = function isBlockScope(node) {
  return t.isBlockStatement(node) || isScope(node);
};

var declaresArguments = function declaresArguments(node) {
  return t.isFunction(node) && !t.isArrowFunctionExpression(node);
};

var declaresThis = declaresArguments;
var LOCALS_SYMBOL = Symbol('locals');

var getLocals = function getLocals(node) {
  return node[LOCALS_SYMBOL];
};

var declareLocals = function declareLocals(node) {
  return node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set();
};

var setLocal = function setLocal(node, name) {
  return declareLocals(node).add(name);
}; // First pass


function declareFunction(node) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = node.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var param = _step.value;
      declarePattern(param, node);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var id = node.id;

  if (id) {
    setLocal(node, id.name);
  }
}

function declarePattern(node, parent) {
  switch (node.type) {
    case 'Identifier':
      setLocal(parent, node.name);
      break;

    case 'ObjectPattern':
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var prop = _step2.value;

          switch (prop.type) {
            case 'RestElement':
              declarePattern(prop.argument, parent);
              break;

            case 'ObjectProperty':
              declarePattern(prop.value, parent);
              break;

            default:
              assert_never_1["default"](prop);
              break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      break;

    case 'ArrayPattern':
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = node.elements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var element = _step3.value;
          if (element) declarePattern(element, parent);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      break;

    case 'RestElement':
      declarePattern(node.argument, parent);
      break;

    case 'AssignmentPattern':
      declarePattern(node.left, parent);
      break;
    // istanbul ignore next

    default:
      throw new Error('Unrecognized pattern type: ' + node.type);
  }
}

function declareModuleSpecifier(node, _state, parents) {
  for (var i = parents.length - 2; i >= 0; i--) {
    if (isScope(parents[i])) {
      setLocal(parents[i], node.local.name);
      return;
    }
  }
}

var firstPass = babel_walk_1.ancestor({
  VariableDeclaration: function VariableDeclaration(node, _state, parents) {
    for (var i = parents.length - 2; i >= 0; i--) {
      if (node.kind === 'var' ? t.isFunctionParent(parents[i]) : isBlockScope(parents[i])) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = node.declarations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var declaration = _step4.value;
            declarePattern(declaration.id, parents[i]);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        return;
      }
    }
  },
  FunctionDeclaration: function FunctionDeclaration(node, _state, parents) {
    if (node.id) {
      for (var i = parents.length - 2; i >= 0; i--) {
        if (isScope(parents[i])) {
          setLocal(parents[i], node.id.name);
          return;
        }
      }
    }
  },
  Function: declareFunction,
  ClassDeclaration: function ClassDeclaration(node, _state, parents) {
    for (var i = parents.length - 2; i >= 0; i--) {
      if (isScope(parents[i])) {
        setLocal(parents[i], node.id.name);
        return;
      }
    }
  },
  TryStatement: function TryStatement(node) {
    if (node.handler === null) return;
    if (node.handler.param === null) return;
    declarePattern(node.handler.param, node.handler);
  },
  ImportDefaultSpecifier: declareModuleSpecifier,
  ImportSpecifier: declareModuleSpecifier,
  ImportNamespaceSpecifier: declareModuleSpecifier
}); // Second pass

var secondPass = babel_walk_1.ancestor({
  Identifier: function Identifier(node, state, parents) {
    var _a;

    var name = node.name;
    if (name === 'undefined') return;
    var lastParent = parents[parents.length - 2];

    if (lastParent) {
      if (!reference_1["default"](node, lastParent)) return;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = parents[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var parent = _step5.value;

          if (name === 'arguments' && declaresArguments(parent)) {
            return;
          }

          if ((_a = getLocals(parent)) === null || _a === void 0 ? void 0 : _a.has(name)) {
            return;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }

    state.globals.push(node);
  },
  ThisExpression: function ThisExpression(node, state, parents) {
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      for (var _iterator6 = parents[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var parent = _step6.value;

        if (declaresThis(parent)) {
          return;
        }
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
          _iterator6["return"]();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }

    state.globals.push(node);
  }
});

function findGlobals(ast) {
  var globals = []; // istanbul ignore if

  if (!t.isNode(ast)) {
    throw new TypeError('Source must be a Babylon AST');
  }

  firstPass(ast, undefined);
  secondPass(ast, {
    globals: globals
  });
  var groupedGlobals = new Map();

  for (var _i = 0, _globals = globals; _i < _globals.length; _i++) {
    var node = _globals[_i];
    var name = node.type === 'ThisExpression' ? 'this' : node.name;
    var existing = groupedGlobals.get(name);

    if (existing) {
      existing.push(node);
    } else {
      groupedGlobals.set(name, [node]);
    }
  }

  return _toConsumableArray(groupedGlobals).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        nodes = _ref2[1];

    return {
      name: name,
      nodes: nodes
    };
  }).sort(function (a, b) {
    return a.name < b.name ? -1 : 1;
  });
}

exports["default"] = findGlobals;