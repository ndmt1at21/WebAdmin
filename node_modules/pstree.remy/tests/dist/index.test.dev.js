"use strict";

var tap = require('tap');

var test = tap.test;

var readFile = require('fs').readFileSync;

var spawn = require('child_process').spawn;

var pstree = require('../');

var _require = require('../lib/utils'),
    tree = _require.tree,
    pidsForTree = _require.pidsForTree,
    getStat = _require.getStat;

if (process.platform !== 'darwin') {
  test('reads from /proc', function _callee(t) {
    var ps;
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return regeneratorRuntime.awrap(getStat());

          case 2:
            ps = _context.sent;
            t.ok(ps.split('\n').length > 1);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    });
  });
}

test('tree for live env', function _callee2(t) {
  var pid, fixture, ps;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          pid = 4079;
          fixture = readFile(__dirname + '/fixtures/out2', 'utf8');
          _context2.next = 4;
          return regeneratorRuntime.awrap(tree(fixture));

        case 4:
          ps = _context2.sent;
          t.deepEqual(pidsForTree(ps, pid).map(function (_) {
            return _.PID;
          }), ['4080']);

        case 6:
        case "end":
          return _context2.stop();
      }
    }
  });
});

function testTree(t, runCallCount) {
  var sub = spawn('node', ["".concat(__dirname, "/fixtures/index.js"), runCallCount], {
    stdio: 'pipe'
  });
  setTimeout(function () {
    var pid = sub.pid;
    pstree(pid, function (error, pids) {
      pids.concat([pid]).forEach(function (p) {
        spawn('kill', ['-s', 'SIGTERM', p]);
      }); // the fixture launches `sh` which launches node which is why we
      // are looking for two processes.
      // Important: IDKW but MacOS seems to skip the `sh` process. no idea.

      t.equal(pids.length, runCallCount * 2);
      t.end();
    });
  }, 1000);
}

test('can read full process tree', function (t) {
  testTree(t, 1);
});
test('can read full process tree with multiple processes', function (t) {
  testTree(t, 2);
});