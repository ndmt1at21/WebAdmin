"use strict";

var SINGLE_TAGS = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];
var ATTRIBUTE_QUOTES_REQUIRED = /[\t\n\f\r "'`=<>]/;
/** Render PostHTML Tree to HTML
 *
 * @param  {Array|Object} tree PostHTML Tree @param  {Object} options Options
 *
 * @return {String} HTML
 */

function render(tree, options) {
  /** Options
   *
   * @type {Object}
   *
   * @prop {Array<String|RegExp>} singleTags  Custom single tags (selfClosing)
   * @prop {String} closingSingleTag Closing format for single tag @prop
   * @prop {Boolean} quoteAllAttributes If all attributes should be quoted.
   * Otherwise attributes will be unquoted when allowed.
   * @prop {Boolean} replaceQuote Replaces quotes in attribute values with `&quote;`
   *
   * Formats:
   *
   * ``` tag: `<br></br>` ```, slash: `<br />` ```, ```default: `<br>` ```
   */
  options = options || {};
  var singleTags = options.singleTags ? SINGLE_TAGS.concat(options.singleTags) : SINGLE_TAGS;
  var singleRegExp = singleTags.filter(function (tag) {
    return tag instanceof RegExp;
  });
  var _options = options,
      closingSingleTag = _options.closingSingleTag;
  var _options2 = options,
      quoteAllAttributes = _options2.quoteAllAttributes;

  if (quoteAllAttributes === undefined) {
    quoteAllAttributes = true;
  }

  var _options3 = options,
      replaceQuote = _options3.replaceQuote;

  if (replaceQuote === undefined) {
    replaceQuote = true;
  }

  var _options4 = options,
      quoteStyle = _options4.quoteStyle;

  if (quoteStyle === undefined) {
    quoteStyle = 2;
  }

  return html(tree);
  /** @private */

  function isSingleTag(tag) {
    if (singleRegExp.length > 0) {
      return singleRegExp.some(function (reg) {
        return reg.test(tag);
      });
    }

    if (!singleTags.includes(tag)) {
      return false;
    }

    return true;
  }
  /** @private */


  function attrs(object) {
    var attr = '';

    for (var key in object) {
      if (typeof object[key] === 'string') {
        if (quoteAllAttributes || object[key].match(ATTRIBUTE_QUOTES_REQUIRED)) {
          var attrValue = object[key];

          if (replaceQuote) {
            attrValue = object[key].replace(/"/g, '&quot;');
          }

          attr += makeAttr(key, attrValue, quoteStyle);
        } else if (object[key] === '') {
          attr += ' ' + key;
        } else {
          attr += ' ' + key + '=' + object[key];
        }
      } else if (object[key] === true) {
        attr += ' ' + key;
      } else if (typeof object[key] === 'number') {
        attr += makeAttr(key, object[key], quoteStyle);
      }
    }

    return attr;
  }
  /** @private */


  function traverse(tree, cb) {
    if (tree !== undefined) {
      for (var i = 0, length = tree.length; i < length; i++) {
        traverse(cb(tree[i]), cb);
      }
    }
  }
  /** @private */


  function makeAttr(key, attrValue) {
    var quoteStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    if (quoteStyle === 1) {
      // Single Quote
      return " ".concat(key, "='").concat(attrValue, "'");
    }

    if (quoteStyle === 2) {
      // Double Quote
      return " ".concat(key, "=\"").concat(attrValue, "\"");
    } // Smart Quote


    if (attrValue.includes('"')) {
      return " ".concat(key, "='").concat(attrValue, "'");
    }

    return " ".concat(key, "=\"").concat(attrValue, "\"");
  }
  /**
   * HTML Stringifier
   *
   * @param  {Array|Object} tree PostHTML Tree
   *
   * @return {String} result HTML
   */


  function html(tree) {
    var result = '';

    if (!Array.isArray(tree)) {
      tree = [tree];
    }

    traverse(tree, function (node) {
      // Undefined, null, '', [], NaN
      if (node === undefined || node === null || node === false || node.length === 0 || Number.isNaN(node)) {
        return;
      } // Treat as new root tree if node is an array


      if (Array.isArray(node)) {
        result += html(node);
        return;
      }

      if (typeof node === 'string' || typeof node === 'number') {
        result += node;
        return;
      } // Skip node


      if (node.tag === false) {
        result += html(node.content);
        return;
      }

      var tag = node.tag || 'div';
      result += '<' + tag;

      if (node.attrs) {
        result += attrs(node.attrs);
      }

      if (isSingleTag(tag)) {
        switch (closingSingleTag) {
          case 'tag':
            result += '></' + tag + '>';
            break;

          case 'slash':
            result += ' />';
            break;

          default:
            result += '>';
        }

        result += html(node.content);
      } else {
        result += '>' + html(node.content) + '</' + tag + '>';
      }
    });
    return result;
  }
}
/**
 * @module posthtml-render
 *
 * @version 1.1.5
 * @license MIT
 */


module.exports = render;